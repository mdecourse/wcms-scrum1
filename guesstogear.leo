<?xml version="1.0" encoding="utf-8"?>
<!-- Created by Leo: http://leoeditor.com/leo_toc.html -->
<?xml-stylesheet ekr_test ?>
<leo_file xmlns:leo="http://leoeditor.com/namespaces/leo-python-editor/1.1" >
<leo_header file_format="2" tnodes="0" max_tnode_index="0" clone_windows="0"/>
<globals body_outline_ratio="0.5" body_secondary_ratio="0.5">
	<global_window_position top="50" left="50" height="500" width="700"/>
	<global_log_window_position top="0" left="0" height="0" width="0"/>
</globals>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="amd.20151121225042.1"><vh>@settings</vh>
<v t="amd.20151121225042.2"><vh>@data qt-gui-plugin-style-sheet</vh></v>
<v t="amd.20151121225042.3"><vh>@string initial_split_orientation = horizontal</vh></v>
</v>
<v t="amd.20151121234937.1" a="E"><vh>有關專案</vh>
<v t="amd.20151121234947.1"><vh>OpenShift 與 filezilla</vh></v>
<v t="amd.20151121235037.1"><vh>對應的 OpenShift</vh></v>
<v t="amd.20151122072557.1"><vh>flask socket.io.js 與 OpenShift</vh></v>
<v t="amd.20151122100250.1"><vh>Brython 繪圖</vh>
<v t="amd.20151122100546.1"><vh>畫五芒星</vh></v>
<v t="amd.20151122100400.1"><vh>台灣國旗</vh></v>
<v t="amd.20151124205805.1"><vh>Gear Utility</vh></v>
<v t="amd.20151125094850.1" a="E"><vh>Cango</vh>
<v t="amd.20151125105508.1"><vh>spur gear example</vh></v>
</v>
<v t="amd.20151125094858.1"><vh>Cango2D</vh></v>
<v t="amd.20151125094905.1"><vh>Cango3D</vh></v>
</v>
<v t="amd.20151122093651.1"><vh>Pro/Web.Link 程式範例</vh>
<v t="amd.20151122094302.1"><vh>正齒輪繪圖設計參數</vh>
<v t="amd.20151122094302.2"><vh>cube pro/web.link</vh></v>
<v t="amd.20151122094302.3"><vh>四連桿自動組立</vh></v>
</v>
<v t="amd.20151122094542.1"><vh>newHeadline</vh></v>
<v t="amd.20151122094546.1" a="E"><vh>@@clean gear.py</vh>
<v t="amd.20151122094546.2"><vh>&lt;&lt;declarations&gt;&gt; (application)</vh></v>
<v t="amd.20151122094546.3" a="E"><vh>class Gear</vh>
<v t="amd.20151122094546.4"><vh>__init__</vh></v>
<v t="amd.20151122094546.5"><vh>default</vh></v>
<v t="amd.20151122094546.6"><vh>index</vh></v>
<v t="amd.20151122094546.7"><vh>interpolation</vh></v>
<v t="amd.20151122094546.8"><vh>gear_width</vh></v>
<v t="amd.20151122094546.9"><vh>cube_weblink</vh></v>
<v t="amd.20151122094546.10"><vh>gear_weblink</vh></v>
</v>
</v>
<v t="amd.20151122094835.1"><vh>@@clean wsgi.py</vh>
<v t="amd.20151122094835.2"><vh>&lt;&lt;declarations&gt;&gt; (wsgi)</vh></v>
<v t="amd.20151122094835.3"><vh>sizeof_fmt</vh></v>
<v t="amd.20151122094835.4"><vh>class Brython</vh>
<v t="amd.20151122094835.5"><vh>__init__</vh></v>
<v t="amd.20151122094835.6"><vh>index</vh></v>
<v t="amd.20151122094835.7"><vh>spur</vh></v>
<v t="amd.20151122094835.8"><vh>spuraction</vh></v>
<v t="amd.20151122094835.9"><vh>drawspur</vh></v>
<v t="amd.20151122094835.10"><vh>drawspuraction</vh></v>
<v t="amd.20151122094835.11"><vh>cube</vh></v>
<v t="amd.20151122094835.12"><vh>cubeaction</vh></v>
<v t="amd.20151122094835.13"><vh>fileuploadform</vh></v>
<v t="amd.20151122094835.14"><vh>fileaxupload</vh></v>
<v t="amd.20151122094835.15"><vh>download_list</vh></v>
<v t="amd.20151122094835.16"><vh>threegears</vh></v>
</v>
<v t="amd.20151122094835.17"><vh>class Download</vh>
<v t="amd.20151122094835.18"><vh>index</vh></v>
</v>
</v>
<v t="amd.20151122094920.1"><vh>@@edit Brython_spur.py</vh></v>
<v t="amd.20151122095255.1"><vh>樂高人偶組立 man1</vh></v>
<v t="amd.20151122095546.1"><vh>樂高人偶組立 man2</vh></v>
</v>
<v t="amd.20151122095724.1"><vh>STL 零件檔轉換</vh>
<v t="amd.20151122095840.1"><vh>建立 Binary STL</vh></v>
</v>
<v t="amd.20151122102956.1"><vh>網際機構模擬</vh></v>
<v t="amd.20151122214658.1"><vh>Gitlab on Ubuntu</vh></v>
<v t="amd.20151204234542.1"><vh>猜顏色遊戲</vh></v>
</v>
<v t="amd.20151122075148.1"><vh>建立資料庫指令</vh></v>
<v t="amd.20151122075205.1"><vh>@edit schema.sql</vh></v>
<v t="amd.20151122075220.1"><vh>@button create db</vh></v>
<v t="amd.20151121233734.1"><vh>@edit README.md</vh></v>
<v t="amd.20151121233918.1"><vh>@edit setup.py</vh></v>
<v t="amd.20151122065955.1"><vh>@edit wsgi.py</vh></v>
<v t="amd.20151122075104.1"><vh>@edit pybean.py</vh></v>
<v t="amd.20151121225024.2"><vh>@clean guess.py</vh>
<v t="amd.20151121225723.1"><vh>&lt;&lt; declarations &gt;&gt;</vh></v>
<v t="amd.20151121225321.1"><vh>index</vh></v>
<v t="amd.20151121225340.1"><vh>guessform</vh></v>
<v t="amd.20151121225334.1"><vh>docheck</vh></v>
<v t="amd.20151124172242.1"><vh>drawflag</vh></v>
<v t="amd.20151124205123.1"><vh>drawstar</vh></v>
<v t="amd.20151124210158.1"><vh>drawcango</vh></v>
<v t="amd.20151124215720.1"><vh>drag</vh></v>
</v>
<v t="amd.20151122075345.1"><vh>@clean gear.py</vh>
<v t="amd.20151122075345.2"><vh>&lt;&lt;declarations&gt;&gt; (application)</vh></v>
<v t="amd.20151122075345.3"><vh>class Gear</vh>
<v t="amd.20151122075345.4"><vh>__init__</vh></v>
<v t="amd.20151122075345.6"><vh>index</vh></v>
<v t="amd.20151122075345.7"><vh>interpolation</vh></v>
<v t="amd.20151122075345.8"><vh>gear_width</vh></v>
</v>
</v>
<v t="amd.20151204234812.1"><vh>@clean guess_color.py</vh>
<v t="amd.20151204234907.1"><vh>&lt;&lt;declarations&gt;&gt; (application)</vh></v>
<v t="amd.20151204235016.1" a="E"><vh>class Guesscolor</vh>
<v t="amd.20151204235016.2"><vh>__init__</vh></v>
<v t="amd.20151204235016.3"><vh>index</vh></v>
<v t="amd.20151204235323.1"><vh>guessform</vh></v>
<v t="amd.20151204235349.1"><vh>docheck</vh></v>
</v>
</v>
<v t="amd.20151121225346.1"><vh>@path templates</vh>
<v t="amd.20151121225407.1"><vh>@edit index.html</vh></v>
<v t="amd.20151121225415.1"><vh>@edit guessform.html</vh></v>
<v t="amd.20151121225445.1"><vh>@edit docheck.html</vh></v>
<v t="amd.20151121230507.1"><vh>@edit toobig.html</vh></v>
<v t="amd.20151121230514.1"><vh>@edit toosmall.html</vh></v>
</v>
<v t="amd.20160105222759.1" a="E"><vh>@clean ga_nutcracker1.py</vh>
<v t="amd.20160105223221.2"><vh>&lt;&lt; declarations &gt;&gt;</vh></v>
<v t="amd.20160105223221.3" a="E"><vh>class Individual</vh>
<v t="amd.20160105223221.4"><vh>__init__</vh></v>
<v t="amd.20160105223221.5"><vh>_getvar</vh></v>
<v t="amd.20160105223221.6"><vh>_makechromosome</vh></v>
<v t="amd.20160105223221.7"><vh>evaluate</vh></v>
<v t="amd.20160105223221.8"><vh>crossover</vh></v>
<v t="amd.20160105223221.9"><vh>mutate</vh></v>
<v t="amd.20160105223221.10"><vh>_pick</vh></v>
<v t="amd.20160105223221.11"><vh>_twopoint</vh></v>
<v t="amd.20160105223221.12"><vh>_repair</vh></v>
<v t="amd.20160105223221.13"><vh>_pickpivots</vh></v>
<v t="amd.20160105223221.14"><vh>__repr__</vh></v>
<v t="amd.20160105223221.15"><vh>__cmp__</vh></v>
<v t="amd.20160105223221.16"><vh>__lt__</vh></v>
<v t="amd.20160105223221.17"><vh>__le__</vh></v>
<v t="amd.20160105223221.18"><vh>__gt__</vh></v>
<v t="amd.20160105223221.19"><vh>__ge__</vh></v>
<v t="amd.20160105223221.20"><vh>copy</vh></v>
</v>
<v t="amd.20160105223221.21"><vh>class Environment</vh>
<v t="amd.20160105223221.22"><vh>__init__</vh></v>
<v t="amd.20160105223221.23"><vh>_makepopulation</vh></v>
<v t="amd.20160105223221.24"><vh>run</vh></v>
<v t="amd.20160105223221.25"><vh>_goal</vh></v>
<v t="amd.20160105223221.26"><vh>step</vh></v>
<v t="amd.20160105223221.27"><vh>_crossover</vh></v>
<v t="amd.20160105223221.28"><vh>_select</vh></v>
<v t="amd.20160105223221.29"><vh>_mutate</vh></v>
<v t="amd.20160105223221.30"><vh>_tournament</vh></v>
<v t="amd.20160105223221.31"><vh>best</vh></v>
<v t="amd.20160105223221.32"><vh>report</vh></v>
</v>
<v t="amd.20160105223221.33"><vh>sum</vh></v>
<v t="amd.20160105224401.1" a="E"><vh>class Onemax</vh>
<v t="amd.20160105224431.1"><vh>evaluate</vh></v>
<v t="amd.20160105224459.1"><vh>mutate</vh></v>
</v>
<v t="amd.20160105223221.34" a="E"><vh>class Volume</vh>
<v t="amd.20160105223221.35"><vh>evaluate</vh></v>
<v t="amd.20160105223221.36"><vh>mutate</vh></v>
</v>
<v t="amd.20160105223221.37" a="E"><vh>class Intersect</vh>
<v t="amd.20160105223221.38"><vh>evaluate</vh></v>
<v t="amd.20160105223221.39"><vh>mutate</vh></v>
</v>
</v>
</vnodes>
<tnodes>
<t tx="amd.20151121225024.2">@language python
# 以下為宣告 ################################## (1)
&lt;&lt; declarations &gt;&gt;

# 以下為全域變數宣告 ############################# (2)
# 確定程式檔案所在目錄, 在 Windows 有最後的反斜線
_curdir = os.path.join(os.getcwd(), os.path.dirname(__file__))

# 設定在雲端與近端的資料儲存目錄
if 'OPENSHIFT_REPO_DIR' in os.environ.keys():
    # 表示程式在雲端執行
    download_root_dir = os.environ['OPENSHIFT_DATA_DIR']
    data_dir = os.environ['OPENSHIFT_DATA_DIR']
    template_root_dir = os.environ['OPENSHIFT_REPO_DIR']+"/static"
else:
    # 表示程式在近端執行
    download_root_dir = _curdir + "/local_data/"
    data_dir = _curdir + "/local_data/"
    template_root_dir = _curdir + "/static"

# 啟動 app
app = Flask(__name__)

# 使用 session 必須要設定 secret_key
app.secret_key = 'A0Zr9@8j/3yX R~XHH!jmN]LWX/,?R@T'

# 以下為相關各方法的定義 ########################### (3)
@others


</t>
<t tx="amd.20151121225042.1"></t>
<t tx="amd.20151121225042.2">QSplitter::handle {
    background-color: #CAE1FF; /* lightSteelBlue1 */
}

QStackedWidget {
    /* background-color:lightpink; */
    border-color: red;
    padding: 0px;
    /* border-width: 0px; */
    /* background-color: yellow; */
}

QSplitter {
    border-color: white;
    background-color: white;
    border-style: solid;
}

QTreeWidget {
    /* These apply to the selected item, but not to editing items.*/
    background-color: #ffffec; /* Leo's traditional tree color */
    selection-color: black; /* was white */
    selection-background-color: lightgrey;
    /* font-family: SansSerif; */
    /*font-family: DejaVu Sans Mono;*/
    font-family:YaHei Mono;
    /* 標題字型大小設定 */
    font-size: 20px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal, italic,oblique */
 }

/* Headline edit widgets */
QTreeWidget QLineEdit {
    background-color: cornsilk;
    selection-color: white;
    selection-background-color: blue;
    /*font-family: DejaVu Sans Mono;*/    
    font-family:YaHei Mono;
    /* 沒有特別對應字型大小 */
    font-size: 20px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal, italic,oblique */
}

/* The log panes */
QTextEdit {
    background-color: #f2fdff;
    selection-color: red;
    selection-background-color: blue;
    /* font-family: Courier New; */
    font-family:YaHei Mono;
    /* log font 大小 */
    font-size: 20px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal, italic,oblique */
}

/* The body pane */
QTextEdit#richTextEdit {
    background-color: #fdf5f5; /* A kind of pink. */
    selection-color: white;
    selection-background-color: red;
    /*font-family: DejaVu Sans Mono;*/
    /* font-family: Courier New; */
    font-family:YaHei Mono;
    /* 內文字型大小 */
    font-size: 20px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal,italic,oblique */
}

QLabel {
    font-family:YaHei Mono;
    /* 下方的 Minibuffer 標題字型大小 */
    font-size: 20px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal,italic,oblique */
}

/* Editor labels */
QLineEdit#editorLabel {
    background-color: #ffffec;
    font-family:YaHei Mono;
    /* 沒有直接對應字型大小 */
    font-size: 20px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal,italic,oblique */
    border: 2px;
    margin: 2px;
}</t>
<t tx="amd.20151121225042.3">horizontal: body pane to the left
vertical: body pane on the botton</t>
<t tx="amd.20151121225321.1">@app.route("/")
def index():
    #這是猜數字遊戲的起始表單, 主要在產生答案, 並且將 count 歸零
    # 將標準答案存入 answer session 對應區
    theanswer = random.randint(1, 100)
    thecount = 0
    # 將答案與計算次數變數存進 session 對應變數
    session['answer'] = theanswer
    session['count'] = thecount

    return render_template("index.html", answer=theanswer, count=thecount)</t>
<t tx="amd.20151121225334.1">@app.route('/docheck', methods=['POST'])
def docheck():
    # session[] 存資料
    # session.get() 取 session 資料
    # 利用 request.form[] 取得表單欄位資料, 然後送到 template
    guess = request.form["guess"]
    session["guess"] = guess
    # 假如使用者直接執行 doCheck, 則設法轉回根方法
    if guess is None:
        redirect("/")
    # 從 session 取出 answer 對應資料, 且處理直接執行 docheck 時無法取 session 值情況
    try:
        theanswer = int(session.get('answer'))
    except:
        redirect("/")
    # 經由表單所取得的 guess 資料型別為 string
    try:
        theguess = int(guess)
    except:
        return redirect("/guessform")
    # 每執行 doCheck 一次,次數增量一次
    session["count"] += 1
    count = session.get("count")
    # 答案與所猜數字進行比對
    if theanswer &lt; theguess:
        return render_template("toobig.html", guess=guess, answer=theanswer, count=count)
    elif theanswer &gt; theguess:
        return render_template("toosmall.html", guess=guess, answer=theanswer, count=count)
    else:
        # 已經猜對, 從 session 取出累計猜測次數
        thecount = session.get('count')
        return "猜了 "+str(thecount)+" 次, 終於猜對了, 正確答案為 "+str(theanswer)+": &lt;a href='/'&gt;再猜&lt;/a&gt;"
    # 應該不會執行下列一行
    return render_template("docheck.html", guess=guess)</t>
<t tx="amd.20151121225340.1">@app.route('/guessform')
def guessform():
    session["count"] += 1
    guess = session.get("guess")
    theanswer = session.get("answer")
    count = session.get("count")
    
    return render_template("guessform.html", guess=guess, answer=theanswer, count=count)</t>
<t tx="amd.20151121225346.1"></t>
<t tx="amd.20151121225723.1"># 導入 os 模組, 主要用來判斷是否在 OpenShift 上執行
import os
from flask import Flask, request, redirect, render_template, session
import random
</t>
<t tx="amd.20151121234937.1">程式語言二 (2014 Spring C2): http://2014c2-mdenfu.rhcloud.com/

2015CD: http://cd-cadp.rhcloud.com/

往年課程網頁:

http://blog.kmol.info/indexd65e.html?cat=8

http://wiki.mde.tw

2014 Fall 計算機程式:

http://cp.kmol.info

http://2014cp.kmol.info

2014 Fall 電腦助設計實習:

http://2014-cadp.rhcloud.com/

http://cadp.kmol.info

http://2014cadp.kmol.info</t>
<t tx="amd.20151121234947.1">ssh-add ~/.ssh/id_rsa</t>
<t tx="amd.20151121235037.1">ssh://56508f8689f5cf0897000188@cptocadp-2015fallhw.rhcloud.com/~/git/cptocadp.git/</t>
<t tx="amd.20151122072557.1">http://vene.ro/blog/flask-socketio-openshift-fallback-xhr-polling.html</t>
<t tx="amd.20151122075148.1">sqlite3 local_data/db/database.db &lt; schema.sql</t>
<t tx="amd.20151122075220.1">@language python
'''
local_data/db/database.db
'''
import os

os.system("sqlite3 local_data/db/database.db &lt; schema.sql")
# echo string
'''
for Leo Editor:
c is the commander of the outline containing the script.
g is Leo’s leo.core.leoGlobals module.
p is the presently selected position, the same as c.p.
'''
g.es("database.db created")</t>
<t tx="amd.20151122075345.1">@language python
@tabwidth -4
&lt;&lt;declarations&gt;&gt;
@others


</t>
<t tx="amd.20151122075345.2">@language python

from flask import Flask, request, redirect, render_template, session
import os
import sys
# 這個程式要計算正齒輪的齒面寬, 資料庫連結希望使用 pybean 與 SQLite
# 導入 pybean 模組與所要使用的 Store 及 SQLiteWriter 方法
from pybean import Store, SQLiteWriter
import math

# 確定程式檔案所在目錄, 在 Windows 有最後的反斜線
_curdir = os.path.join(os.getcwd(), os.path.dirname(__file__))
# 將所在目錄設為系統搜尋目錄
sys.path.append(_curdir)
if 'OPENSHIFT_REPO_DIR' in os.environ.keys():
    # while program is executed in OpenShift
    download_root_dir = os.environ['OPENSHIFT_DATA_DIR']
    data_dir = os.environ['OPENSHIFT_DATA_DIR']
else:
    # while program is executed in localhost
    download_root_dir = _curdir + "/local_data/"
    data_dir = _curdir + "/local_data/"

# 這是 Gear 設計資料表的定義
'''

lewis.db 中有兩個資料表, steel 與 lewis

 CREATE TABLE steel ( 
    serialno      INTEGER,
    unsno         TEXT,
    aisino        TEXT,
    treatment     TEXT,
    yield_str     INTEGER,
    tensile_str   INTEGER,
    stretch_ratio INTEGER,
    sectional_shr INTEGER,
    brinell       INTEGER 
);

CREATE TABLE lewis ( 
    serialno INTEGER PRIMARY KEY
                     NOT NULL,
    gearno   INTEGER,
    type1    NUMERIC,
    type4    NUMERIC,
    type3    NUMERIC,
    type2    NUMERIC 
);
'''

</t>
<t tx="amd.20151122075345.3">class Gear(object):
    @others
</t>
<t tx="amd.20151122075345.4">def __init__(self):
    # hope to create downloads and images directories　
    if not os.path.isdir(download_root_dir+"downloads"):
        try:
            os.makedirs(download_root_dir+"downloads")
        except:
            print("mkdir error")
    if not os.path.isdir(download_root_dir+"images"):
        try:
            os.makedirs(download_root_dir+"images")
        except:
            print("mkdir error")
    if not os.path.isdir(download_root_dir+"tmp"):
        try:
            os.makedirs(download_root_dir+"tmp")
        except:
            print("mkdir error")
</t>
<t tx="amd.20151122075345.6"># 各組利用 index 引導隨後的程式執行
#@app.route("/gear_index")
def index(self, *args, **kwargs):
    # 進行資料庫檔案連結,  並且取出所有資料
    try:
        # 利用 Store  建立資料庫檔案對應物件, 並且設定 frozen=True 表示不要開放動態資料表的建立
        # 因為程式以 application 所在目錄執行, 因此利用相對目錄連結 lewis.db 資料庫檔案
        SQLite連結 = Store(SQLiteWriter(_curdir+"/lewis.db", frozen=True))
        #material = SQLite連結.find_one("steel","serialno = ?",[序號])
        # str(SQLite連結.count("steel")) 將傳回 70, 表示資料庫中有 70 筆資料
        material = SQLite連結.find("steel")
        # 所傳回的 material 為 iterator
        '''
        outstring = ""
        for material_item in material:
            outstring += str(material_item.serialno) + ":" + material_item.unsno + "_" + material_item.treatment + "&lt;br /&gt;"
        return outstring
        '''
    except:
        return "抱歉! 資料庫無法連線&lt;br /&gt;"

    outstring = '''
&lt;form id=entry method=post action="/gear_width"&gt;
請填妥下列參數，以完成適當的齒尺寸大小設計。&lt;br /&gt;
馬達馬力:&lt;input type=text name=horsepower id=horsepower value=100 size=10&gt;horse power&lt;br /&gt;
馬達轉速:&lt;input type=text name=rpm id=rpm value=1120 size=10&gt;rpm&lt;br /&gt;
齒輪減速比: &lt;input type=text name=ratio id=ratio value=4 size=10&gt;&lt;br /&gt;
齒形:&lt;select name=toothtype id=toothtype&gt;
&lt;option value=type1&gt;壓力角20度,a=0.8,b=1.0
&lt;option value=type2&gt;壓力角20度,a=1.0,b=1.25
&lt;option value=type3&gt;壓力角25度,a=1.0,b=1.25
&lt;option value=type4&gt;壓力角25度,a=1.0,b=1.35
&lt;/select&gt;&lt;br /&gt;
安全係數:&lt;input type=text name=safetyfactor id=safetyfactor value=3 size=10&gt;&lt;br /&gt;
齒輪材質:&lt;select name=material_serialno id=material_serialno&gt;
'''
    for material_item in material:
        outstring += "&lt;option value=" + str(material_item.serialno) + "&gt;UNS - " + \
            material_item.unsno + " - " + material_item.treatment
    outstring += "&lt;/select&gt;&lt;br /&gt;"
    
    outstring += "小齒輪齒數:&lt;input type=text name=npinion id=npinion value=18 size=10&gt;&lt;br /&gt;"
    outstring += "&lt;input type=submit id=submit value=進行運算&gt;"
    outstring += "&lt;/form&gt;"

    return outstring
</t>
<t tx="amd.20151122075345.7">#@app.route("/interpoloation")
def interpolation(self, small_gear_no=18, gear_type=1):
    SQLite連結 = Store(SQLiteWriter(_curdir+"/lewis.db", frozen=True))
    # 使用內插法求值
    # 找出比目標齒數大的其中的最小的,就是最鄰近的大值
    lewis_factor = SQLite連結.find_one("lewis","gearno &gt; ?",[small_gear_no])
    if(gear_type == 1):
        larger_formfactor = lewis_factor.type1
    elif(gear_type == 2):
        larger_formfactor = lewis_factor.type2
    elif(gear_type == 3):
        larger_formfactor = lewis_factor.type3
    else:
        larger_formfactor = lewis_factor.type4
    larger_toothnumber = lewis_factor.gearno
 
    # 找出比目標齒數小的其中的最大的,就是最鄰近的小值
    lewis_factor = SQLite連結.find_one("lewis","gearno &lt; ? order by gearno DESC",[small_gear_no])
    if(gear_type == 1):
        smaller_formfactor = lewis_factor.type1
    elif(gear_type == 2):
        smaller_formfactor = lewis_factor.type2
    elif(gear_type == 3):
        smaller_formfactor = lewis_factor.type3
    else:
        smaller_formfactor = lewis_factor.type4
    smaller_toothnumber = lewis_factor.gearno
    calculated_factor = larger_formfactor + (small_gear_no - larger_toothnumber) * (larger_formfactor - smaller_formfactor) / (larger_toothnumber - smaller_toothnumber)
    # 只傳回小數點後五位數
    return str(round(calculated_factor, 5))
</t>
<t tx="amd.20151122075345.8"># 改寫為齒面寬的設計函式
#@app.route("/gear_width")
#def gear_width(self, horsepower=100, rpm=1000, ratio=4, toothtype=1, safetyfactor=2, material_serialno=1, npinion=18):
def gear_width(self):
    horsepower = request.form["horsepower"]
    rpm = request.form["rpm"]
    ratio = request.form["ratio"]
    toothtype = request.form["toothtype"]
    safetyfactor = request.form["safetyfactor"]
    material_serialno = request.form["material_serialno"]
    npinion= request.form["npinion"]
    SQLite連結 = Store(SQLiteWriter(_curdir+"/lewis.db", frozen=True))
    outstring = ""
    # 根據所選用的齒形決定壓力角
    if(toothtype == 1 or toothtype == 2):
        壓力角 = 20
    else:
        壓力角 = 25
 
    # 根據壓力角決定最小齒數
    if(壓力角== 20):
        最小齒數 = 18
    else:
        最小齒數 = 12
 
    # 直接設最小齒數
    if int(npinion) &lt;= 最小齒數:
        npinion = 最小齒數
    # 大於400的齒數則視為齒條(Rack)
    if int(npinion) &gt;= 400:
        npinion = 400
 
    # 根據所選用的材料查詢強度值
    # 由 material之序號查 steel 表以得材料之降伏強度S單位為 kpsi 因此查得的值要成乘上1000
    # 利用 Store  建立資料庫檔案對應物件, 並且設定 frozen=True 表示不要開放動態資料表的建立
    #SQLite連結 = Store(SQLiteWriter("lewis.db", frozen=True))
    # 指定 steel 資料表
    steel = SQLite連結.new("steel")
    # 資料查詢
    #material = SQLite連結.find_one("steel","unsno=? and treatment=?",[unsno, treatment])
    material = SQLite連結.find_one("steel","serialno=?",[material_serialno])
    # 列出 steel 資料表中的資料筆數
    #print(SQLite連結.count("steel"))
    #print (material.yield_str)
    strengthstress = material.yield_str*1000
    # 由小齒輪的齒數與齒形類別,查詢lewis form factor
    # 先查驗是否有直接對應值
    on_table = SQLite連結.count("lewis","gearno=?",[npinion])
    if on_table == 1:
        # 直接進入設計運算
        #print("直接運算")
        #print(on_table)
        lewis_factor = SQLite連結.find_one("lewis","gearno=?",[npinion])
        #print(lewis_factor.type1)
        # 根據齒形查出 formfactor 值
        if(toothtype == 1):
            formfactor = lewis_factor.type1
        elif(toothtype == 2):
            formfactor = lewis_factor.type2
        elif(toothtype == 3):
            formfactor = lewis_factor.type3
        else:
            formfactor = lewis_factor.type4
    else:
        # 沒有直接對應值, 必須進行查表內插運算後, 再執行設計運算
        #print("必須內插")
        #print(interpolation(npinion, gear_type))
        formfactor = self.interpolation(npinion, toothtype)
 
    # 開始進行設計運算
 
    ngear = int(npinion) * int(ratio)
 
    # 重要的最佳化設計---儘量用整數的diametralpitch
    # 先嘗試用整數算若 diametralpitch 找到100 仍無所獲則改用 0.25 作為增量再不行則宣告 fail
    counter = 0
    i = 0.1
    facewidth = 0
    circularpitch = 0
    while (facewidth &lt;= 3 * circularpitch or facewidth &gt;= 5 * circularpitch):
        diametralpitch = i
        #circularpitch = 3.14159/diametralpitch
        circularpitch = math.pi/diametralpitch
        pitchdiameter = int(npinion)/diametralpitch
        #pitchlinevelocity = 3.14159*pitchdiameter*rpm/12
        pitchlinevelocity = math.pi*pitchdiameter * float(rpm)/12
        transmittedload = 33000*float(horsepower)/pitchlinevelocity
        velocityfactor = 1200/(1200 + pitchlinevelocity)
        # formfactor is Lewis form factor
        # formfactor need to get from table 13-3 and determined ty teeth number and type of tooth
        # formfactor = 0.293
        # 90 is the value get from table corresponding to material type
        facewidth = transmittedload*diametralpitch*float(safetyfactor)/velocityfactor/formfactor/strengthstress
        if(counter&gt;5000):
            outstring += "超過5000次的設計運算,仍無法找到答案!&lt;br /&gt;"
            outstring += "可能所選用的傳遞功率過大,或無足夠強度的材料可以使用!&lt;br /&gt;"
            # 離開while迴圈
            break
        i += 0.1
        counter += 1
    facewidth = round(facewidth, 4)
    if(counter&lt;5000):
        outstring = "進行"+str(counter)+"次重複運算後,得到合用的facewidth值為:"+str(facewidth)
    return outstring
</t>
<t tx="amd.20151122093651.1">Creo Pro/Web.Link

零件尺寸控制

零件自動組立

全球資訊網的 E2E 協同設計流程:

設計者完成參數化零件繪圖
設計者根據所設想的設計標的, 完成參數化零件組立
設計者提供一個全球資訊網輔助設計程式表單, 讓使用者自行輸入所需要的設計標的
系統根據使用者所輸入的設計參數進行演算, 得到符合設計需求的各零組件尺寸
系統根據演算所得各零件的尺寸, 以參數化變更各零件尺寸後在使用者端存檔
系統啟動自動組立程式, 以演算所得的零件進行自動組立
使用者檢視系統所完成的設計結果, 決定下一步動作

2014cadp 網際程式結合 Pro/Web.Link 齒輪尺寸變更: https://copy.com/lPRwb2vGYMyfRncX</t>
<t tx="amd.20151122094302.1">dp=1/module
wholedepth=2.25*module

ADDENDUM = 1/dp
clearance = wholedepth-(2*ADDENDUM)
DEDENDUM = wholedepth-ADDENDUM-clearance

D147 = clearance
invpressangle=tan(pressangle)-(pressangle/180)*pi
PITCHDIA = n/dp
ROOT_DIA=PITCHDIA-(2*DEDENDUM)-(2*clearance)
THK_P = (pi/2)/dp
TANGP=(2*THK_P/PITCHDIA)*180/PI
toverd=THK_P/PITCHDIA
ADDENDUMDIA=PITCHDIA+(2*ADDENDUM)
PITCHDIAMETER = PITCHDIA
BASEDIA = pitchdia*cos(pressangle)
BASEDIAMETER = BASEDIA
z=invpressangle+toverd
THK_B = (z)*BASEDIA
TANGBASE=(2*THK_B/BASEDIA)*180/PI
pd = n/dp
a = pressangle
ad = ADDENDUM
D_O = pd+(2*(ad))
r_b = .5*pd*cos(pressangle)
D320 = tangbase/2
D325 = tangbase/2
D335 = 360/n
P337=n-1
D336 = 360/N
D327 = face_width
D334 = face_width

D566 = .39/dp
D686 = BORE_DIA

D722 = (PITCHDIAMETER+(2*ADDENDUM))/2
D720 = .8*ADDENDUM
/*D748 = .4*d739
/*D747 = .4*d739</t>
<t tx="amd.20151122094302.2">&lt;h1&gt;Creo 參數化零件&lt;/h1&gt;
&lt;script type="text/javascript" src="/static/weblink/pfcUtils.js"&gt;&lt;/script&gt;
&lt;script type="text/javascript" src="/static/weblink/wl_header.js"&gt;// &lt;![CDATA[
document.writeln ("Error loading Pro/Web.Link header!");
// ]]&gt;&lt;/script&gt;
&lt;script type="text/javascript" language="JavaScript"&gt;// &lt;![CDATA[
if (!pfcIsWindows()) netscape.security.PrivilegeManager.enablePrivilege("UniversalXPConnect");
// 若第三輸入為 false, 表示僅載入 session, 但是不顯示
// ret 為 model open return
 var ret = document.pwl.pwlMdlOpen("cube.prt", "v:/tmp", false);
if (!ret.Status) {
    alert("pwlMdlOpen failed (" + ret.ErrorCode + ")");
}
    //將 ProE 執行階段設為變數 session
    var session = pfcGetProESession();
    // 在視窗中打開零件檔案, 並且顯示出來
    var window = session.OpenFile(pfcCreate("pfcModelDescriptor").CreateFromFileName("cube.prt"));
    var solid = session.GetModel("cube.prt",pfcCreate("pfcModelType").MDL_PART);
    var length,width,myf,myn,i,j,volume,count,d1Value,d2Value;
    // 將模型檔中的 length 變數設為 javascript 中的 length 變數
    length = solid.GetParam("a1");
    // 將模型檔中的 width 變數設為 javascript 中的 width 變數
    width = solid.GetParam("a2");
//改變零件尺寸
    //myf=20;
    //myn=20;
    volume=0;
    count=0;
    try
    {
            // 以下採用 URL 輸入對應變數
            //createParametersFromArguments ();
            // 以下則直接利用 javascript 程式改變零件參數
            for(i=0;i&lt;=5;i++)
            {
                //for(j=0;j&lt;=2;j++)
                //{
                    myf=100.0;
                    myn=100.0+i*5.0;
// 設定變數值, 利用 ModelItem 中的 CreateDoubleParamValue 轉換成 Pro/Web.Link 所需要的浮點數值
         d1Value = pfcCreate ("MpfcModelItem").CreateDoubleParamValue(myf);
         d2Value = pfcCreate ("MpfcModelItem").CreateDoubleParamValue(myn);
// 將處理好的變數值, 指定給對應的零件變數
                    length.Value = d1Value;
                    width.Value = d2Value;
                    //零件尺寸重新設定後, 呼叫 Regenerate 更新模型
                    solid.Regenerate(void null);
                    //利用 GetMassProperty 取得模型的質量相關物件
                    properties = solid.GetMassProperty(void null);
                    //volume = volume + properties.Volume;
volume = properties.Volume;
                    count = count + 1;
alert("執行第"+count+"次,零件總體積:"+volume);
// 將零件存為新檔案
var newfile = document.pwl.pwlMdlSaveAs("cube.prt", "v:/tmp", "cube"+count+".prt");
if (!newfile.Status) {
    alert("pwlMdlSaveAs failed (" + newfile.ErrorCode + ")");
}
//} // 內圈 for 迴圈
            } //外圈 for 迴圈
            //alert("共執行:"+count+"次,零件總體積:"+volume);
            //alert("零件體積:"+properties.Volume);
            //alert("零件體積取整數:"+Math.round(properties.Volume));
        }
    catch(err)
        {
            alert ("Exception occurred: "+pfcGetExceptionType (err));
        }
// ]]&gt;&lt;/script&gt;</t>
<t tx="amd.20151122094302.3">&lt;script type="text/javascript" src="/static/weblink/pfcUtils.js"&gt;&lt;/script&gt;
&lt;script type="text/javascript" src="/static/weblink/wl_header.js"&gt;&lt;/script&gt;
&lt;script type="text/javascript"&gt;// &lt;![CDATA[
if (!pfcIsWindows())
netscape.security.PrivilegeManager.enablePrivilege("UniversalXPConnect");
var session = pfcGetProESession();
// 設定 config option
session.SetConfigOption("comp_placement_assumptions","no");
// 建立擺放零件的位置矩陣
var identityMatrix = pfcCreate ("pfcMatrix3D");
for (var x = 0; x &lt; 4; x++)
	for (var y = 0; y &lt; 4; y++)
	{
		if (x == y)
			identityMatrix.Set (x, y, 1.0);
		else
			identityMatrix.Set (x, y, 0.0);
	}
var transf = pfcCreate ("pfcTransform3D").Create (identityMatrix);
// 取得目前的工作目錄
var currentDir = session.getCurrentDirectory();
// 以目前已開檔, 作為 model
var model = session.CurrentModel;
// 查驗有無 model, 或 model 類別是否為組立件
if (model == void null || model.Type != pfcCreate ("pfcModelType").MDL_ASSEMBLY)
throw new Error (0, "Current model is not an assembly.");
var assembly = model;
/**----------------------------------------------- link0 -------------------------------------------------------------**/
    //檔案目錄，建議將圖檔放置工作目錄下較方便使用
	var descr = pfcCreate ("pfcModelDescriptor").CreateFromFileName ("v:/home/fourbar/link0.prt");
	// 若 link1.prt 在 session 則直接取用
	var componentModel = session.GetModelFromDescr (descr);
	//若 link1.prt 不在 session 則從工作目錄中載入 session
	var componentModel = session.RetrieveModel(descr);
	//若 link1.prt 已經在 session 則放入組立檔中
	if (componentModel != void null)
	{
		//注意這個 asmcomp 即為設定約束條件的本體
		//asmcomp 為特徵物件,直接將零件, 以 transf 座標轉換放入組立檔案中
		var asmcomp = assembly.AssembleComponent (componentModel, transf);
	}
// 建立約束條件變數
var constrs = pfcCreate ("pfcComponentConstraints");
//設定組立檔中的三個定位面, 注意內定名稱與 Pro/E WF 中的 ASM_D_FRONT 不同, 而是 ASM_FRONT
var asmDatums = new Array ("ASM_FRONT", "ASM_TOP", "ASM_RIGHT");
//設定零件檔中的三個定位面, 名稱與 Pro/E WF 中相同
var compDatums = new Array ("FRONT", "TOP", "RIGHT");
	//建立 ids 變數, intseq 為 sequence of integers 為資料類別, 使用者可以經由整數索引擷取此資料類別的元件, 第一個索引為 0
	var ids = pfcCreate ("intseq");
	//建立路徑變數
	var path = pfcCreate ("MpfcAssembly").CreateComponentPath (assembly, ids);
	//採用互動式設定相關的變數
	var MpfcSelect = pfcCreate ("MpfcSelect");
//利用迴圈分別約束組立與零件檔中的三個定位平面
for (var i = 0; i &lt; 3; i++)
{
	//設定組立參考面
	var asmItem = assembly.GetItemByName (pfcCreate ("pfcModelItemType").ITEM_SURFACE, asmDatums [i]);
	//若無對應的組立參考面, 則啟用互動式平面選擇表單 flag
	if (asmItem == void null)
	{
		interactFlag = true;
		continue;
	}
	//設定零件參考面
	var compItem = componentModel.GetItemByName (pfcCreate ("pfcModelItemType").ITEM_SURFACE, compDatums [i]);
	//若無對應的零件參考面, 則啟用互動式平面選擇表單 flag
	if (compItem == void null)
	{
		interactFlag = true;
		continue;
	}
	var asmSel = MpfcSelect.CreateModelItemSelection (asmItem, path);
	var compSel = MpfcSelect.CreateModelItemSelection (compItem, void null);
	var constr = pfcCreate ("pfcComponentConstraint").Create (pfcCreate ("pfcComponentConstraintType").ASM_CONSTRAINT_ALIGN);
	constr.AssemblyReference = asmSel;
	constr.ComponentReference = compSel;
	constr.Attributes = pfcCreate ("pfcConstraintAttributes").Create (false, false);
	//將互動選擇相關資料, 附加在程式約束變數之後
	constrs.Append (constr);
}
//設定組立約束條件
asmcomp.SetConstraints (constrs, void null);
/**-------------------------------------------------------------------------------------------------------------------**/
/**----------------------------------------------- link1 -------------------------------------------------------------**/
var descr = pfcCreate ("pfcModelDescriptor").CreateFromFileName ("v:/home/fourbar/link1.prt");
var componentModel = session.GetModelFromDescr (descr);
var componentModel = session.RetrieveModel(descr);
if (componentModel != void null)
{
	var asmcomp = assembly.AssembleComponent (componentModel, transf);
}
var components = assembly.ListFeaturesByType(true, pfcCreate ("pfcFeatureType").FEATTYPE_COMPONENT);
var featID = components.Item(0).Id;
ids.Append(featID);
var subPath = pfcCreate ("MpfcAssembly").CreateComponentPath( assembly, ids );
subassembly = subPath.Leaf;
var asmDatums = new Array ("A_1", "TOP", "ASM_TOP");
var compDatums = new Array ("A_1", "TOP", "TOP");
var relation = new Array (pfcCreate ("pfcComponentConstraintType").ASM_CONSTRAINT_ALIGN, pfcCreate ("pfcComponentConstraintType").ASM_CONSTRAINT_MATE);
var relationItem = new Array(pfcCreate("pfcModelItemType").ITEM_AXIS,pfcCreate("pfcModelItemType").ITEM_SURFACE);
var constrs = pfcCreate ("pfcComponentConstraints");
for (var i = 0; i &lt; 2; i++)
	{
		var asmItem = subassembly.GetItemByName (relationItem[i], asmDatums [i]);
		if (asmItem == void null)
		{
			interactFlag = true;
			continue;
		}
		var compItem = componentModel.GetItemByName (relationItem[i], compDatums [i]);
		if (compItem == void null)
		{
			interactFlag = true;
			continue;
		}
		var MpfcSelect = pfcCreate ("MpfcSelect");
		var asmSel = MpfcSelect.CreateModelItemSelection (asmItem, subPath);
		var compSel = MpfcSelect.CreateModelItemSelection (compItem, void null);
		var constr = pfcCreate ("pfcComponentConstraint").Create (relation[i]);
		constr.AssemblyReference  = asmSel;
		constr.ComponentReference = compSel;
		constr.Attributes = pfcCreate ("pfcConstraintAttributes").Create (true, false);
		constrs.Append (constr);
	}
asmcomp.SetConstraints (constrs, void null);
	
/**-------------------------------------------------------------------------------------------------------------------**/
/**----------------------------------------------- link2 -------------------------------------------------------------**/
var descr = pfcCreate ("pfcModelDescriptor").CreateFromFileName ("v:/home/fourbar/link2.prt");
var componentModel = session.GetModelFromDescr (descr);
var componentModel = session.RetrieveModel(descr);
if (componentModel != void null)
{
	var asmcomp = assembly.AssembleComponent (componentModel, transf);
}
var ids = pfcCreate ("intseq");
ids.Append(featID+1);
var subPath = pfcCreate ("MpfcAssembly").CreateComponentPath( assembly, ids );
subassembly = subPath.Leaf;
var asmDatums = new Array ("A_2", "TOP", "ASM_TOP");
var compDatums = new Array ("A_1", "TOP", "TOP");
var relation = new Array (pfcCreate ("pfcComponentConstraintType").ASM_CONSTRAINT_ALIGN, pfcCreate ("pfcComponentConstraintType").ASM_CONSTRAINT_MATE);
var relationItem = new Array(pfcCreate("pfcModelItemType").ITEM_AXIS,pfcCreate("pfcModelItemType").ITEM_SURFACE);
var constrs = pfcCreate ("pfcComponentConstraints");
for (var i = 0; i &lt; 2; i++)
	{
		var asmItem = subassembly.GetItemByName (relationItem[i], asmDatums [i]);
		if (asmItem == void null)
		{
			interactFlag = true;
			continue;
		}
		var compItem = componentModel.GetItemByName (relationItem[i], compDatums [i]);
		if (compItem == void null)
		{
			interactFlag = true;
			continue;
		}
		var MpfcSelect = pfcCreate ("MpfcSelect");
		var asmSel = MpfcSelect.CreateModelItemSelection (asmItem, subPath);
		var compSel = MpfcSelect.CreateModelItemSelection (compItem, void null);
		var constr = pfcCreate ("pfcComponentConstraint").Create (relation[i]);
		constr.AssemblyReference  = asmSel;
		constr.ComponentReference = compSel;
		constr.Attributes = pfcCreate ("pfcConstraintAttributes").Create (true, false);
		constrs.Append (constr);
	}
asmcomp.SetConstraints (constrs, void null);
	
/**-------------------------------------------------------------------------------------------------------------------**/
/**----------------------------------------------- link3 -------------------------------------------------------------**/
var descr = pfcCreate ("pfcModelDescriptor").CreateFromFileName ("v:/home/fourbar/link3.prt");
var componentModel = session.GetModelFromDescr (descr);
var componentModel = session.RetrieveModel(descr);
if (componentModel != void null)
{
	var asmcomp = assembly.AssembleComponent (componentModel, transf);
}
var relation = new Array (pfcCreate ("pfcComponentConstraintType").ASM_CONSTRAINT_ALIGN, pfcCreate ("pfcComponentConstraintType").ASM_CONSTRAINT_MATE);
var relationItem = new Array(pfcCreate("pfcModelItemType").ITEM_AXIS,pfcCreate("pfcModelItemType").ITEM_SURFACE);
var constrs = pfcCreate ("pfcComponentConstraints");
var ids = pfcCreate ("intseq");
ids.Append(featID+2);
var subPath = pfcCreate ("MpfcAssembly").CreateComponentPath( assembly, ids );
subassembly = subPath.Leaf;
var asmDatums = new Array ("A_2");
var compDatums = new Array ("A_1");
for (var i = 0; i &lt; 1; i++)
	{
		var asmItem = subassembly.GetItemByName (relationItem[i], asmDatums [i]);
		if (asmItem == void null)
		{
			interactFlag = true;
			continue;
		}
		var compItem = componentModel.GetItemByName (relationItem[i], compDatums [i]);
		if (compItem == void null)
		{
			interactFlag = true;
			continue;
		}
		var MpfcSelect = pfcCreate ("MpfcSelect");
		var asmSel = MpfcSelect.CreateModelItemSelection (asmItem, subPath);
		var compSel = MpfcSelect.CreateModelItemSelection (compItem, void null);
		var constr = pfcCreate ("pfcComponentConstraint").Create (relation[i]);
		constr.AssemblyReference  = asmSel;
		constr.ComponentReference = compSel;
		constr.Attributes = pfcCreate ("pfcConstraintAttributes").Create (true, false);
		constrs.Append (constr);
	}
asmcomp.SetConstraints (constrs, void null);
var ids = pfcCreate ("intseq");
ids.Append(featID);
var subPath = pfcCreate ("MpfcAssembly").CreateComponentPath( assembly, ids );
subassembly = subPath.Leaf;
var asmDatums = new Array ("A_2", "TOP");
var compDatums = new Array ("A_2", "BOTTON");
for (var i = 0; i &lt; 2; i++)
	{
		var asmItem = subassembly.GetItemByName (relationItem[i], asmDatums [i]);
		if (asmItem == void null)
		{
			interactFlag = true;
			continue;
		}
		var compItem = componentModel.GetItemByName (relationItem[i], compDatums [i]);
		if (compItem == void null)
		{
			interactFlag = true;
			continue;
		}
		var MpfcSelect = pfcCreate ("MpfcSelect");
		var asmSel = MpfcSelect.CreateModelItemSelection (asmItem, subPath);
		var compSel = MpfcSelect.CreateModelItemSelection (compItem, void null);
		var constr = pfcCreate ("pfcComponentConstraint").Create (relation[i]);
		constr.AssemblyReference  = asmSel;
		constr.ComponentReference = compSel;
		constr.Attributes = pfcCreate ("pfcConstraintAttributes").Create (true, true);
		constrs.Append (constr);
	}
asmcomp.SetConstraints (constrs, void null);
/**-------------------------------------------------------------------------------------------------------------------**/
var session = pfcGetProESession ();
var solid = session.CurrentModel;
properties = solid.GetMassProperty(void null);
var COG = properties.GravityCenter;
document.write("MassProperty:&lt;br /&gt;");
document.write("Mass:"+(properties.Mass.toFixed(2))+"       pound&lt;br /&gt;");
document.write("Average Density:"+(properties.Density.toFixed(2))+"       pound/inch^3&lt;br /&gt;");
document.write("Surface area:"+(properties.SurfaceArea.toFixed(2))+"           inch^2&lt;br /&gt;");
document.write("Volume:"+(properties.Volume.toFixed(2))+"   inch^3&lt;br /&gt;");
document.write("COG_X:"+COG.Item(0).toFixed(2)+"&lt;br /&gt;");
document.write("COG_Y:"+COG.Item(1).toFixed(2)+"&lt;br /&gt;");
document.write("COG_Z:"+COG.Item(2).toFixed(2)+"&lt;br /&gt;");
try
{
document.write("Current Directory:&lt;br /&gt;"+currentDir);
}
catch (err)
{
alert ("Exception occurred: "+pfcGetExceptionType (err));
}
assembly.Regenerate (void null);
session.GetModelWindow (assembly).Repaint();
// ]]&gt;&lt;/script&gt;</t>
<t tx="amd.20151122094542.1"></t>
<t tx="amd.20151122094546.1">@language python
@tabwidth -4

&lt;&lt;declarations&gt;&gt;
@others
root = Gear()

# setup static, images and downloads directories
application_conf = {
        '/static':{
        'tools.staticdir.on': True,
        'tools.staticdir.dir': _curdir+"/static"},
        '/images':{
        'tools.staticdir.on': True,
        'tools.staticdir.dir': data_dir+"/images"},
        '/downloads':{
        'tools.staticdir.on': True,
        'tools.staticdir.dir': data_dir+"/downloads"}
    }

# if inOpenshift ('OPENSHIFT_REPO_DIR' exists in environment variables) or not inOpenshift
if __name__ == '__main__':
    if 'OPENSHIFT_REPO_DIR' in os.environ.keys():
        # operate in OpenShift
        application = cherrypy.Application(root, config = application_conf)
    else:
        # operate in localhost
        cherrypy.quickstart(root, config = application_conf)

</t>
<t tx="amd.20151122094546.10">@cherrypy.expose
def gear_weblink(self, facewidth=5, n=18):
    outstring = '''&lt;script type="text/javascript" src="/static/pfcUtils.js"&gt;&lt;/script&gt;
&lt;script type="text/javascript" src="/static/wl_header.js"&gt;// &lt;![CDATA[
document.writeln ("Error loading Pro/Web.Link header!");
// ]]&gt;&lt;/script&gt;
&lt;script type="text/javascript" language="JavaScript"&gt;// &lt;![CDATA[
if (!pfcIsWindows()) netscape.security.PrivilegeManager.enablePrivilege("UniversalXPConnect");
// 若第三輸入為 false, 表示僅載入 session, 但是不顯示
// ret 為 model open return
 var ret = document.pwl.pwlMdlOpen("gear.prt", "v:/", false);
if (!ret.Status) {
    alert("pwlMdlOpen failed (" + ret.ErrorCode + ")");
}
    //將 ProE 執行階段設為變數 session
    var session = pfcGetProESession();
    // 在視窗中打開零件檔案, 並且顯示出來
    var window = session.OpenFile(pfcCreate("pfcModelDescriptor").CreateFromFileName("gear.prt"));
    var solid = session.GetModel("gear.prt",pfcCreate("pfcModelType").MDL_PART);
    var length,width,myf,myn,i,j,volume,count,d1Value,d2Value;
    // 將模型檔中的 length 變數設為 javascript 中的 length 變數
    length = solid.GetParam("n");
    // 將模型檔中的 width 變數設為 javascript 中的 width 變數
    width = solid.GetParam("face_width");
//改變零件尺寸
    //myf=20;
    //myn=20;
    volume=0;
    count=0;
    try
    {
            // 以下採用 URL 輸入對應變數
            //createParametersFromArguments ();
            // 以下則直接利用 javascript 程式改變零件參數
            for(i=0;i&lt;=5;i++)
            {
                //for(j=0;j&lt;=2;j++)
                //{
                    myf=25+i*2;
                    myn=10.0+i*0.5;
// 設定變數值, 利用 ModelItem 中的 CreateDoubleParamValue 轉換成 Pro/Web.Link 所需要的浮點數值
         //d1Value = pfcCreate ("MpfcModelItem").CreateDoubleParamValue(myf);
         d1Value = pfcCreate ("MpfcModelItem").CreateIntParamValue(myf);
         d2Value = pfcCreate ("MpfcModelItem").CreateDoubleParamValue(myn);

// 將處理好的變數值, 指定給對應的零件變數
                    length.Value = d1Value;
                    width.Value = d2Value;
                    //零件尺寸重新設定後, 呼叫 Regenerate 更新模型
                    solid.Regenerate(void null);
                    //利用 GetMassProperty 取得模型的質量相關物件
                    properties = solid.GetMassProperty(void null);
                    //volume = volume + properties.Volume;
volume = properties.Volume;
                    count = count + 1;
alert("執行第"+count+"次,零件總體積:"+volume);
// 將零件存為新檔案
var newfile = document.pwl.pwlMdlSaveAs("gear.prt", "v:/", "mygear_"+count+".prt");
if (!newfile.Status) {
    alert("pwlMdlSaveAs failed (" + newfile.ErrorCode + ")");
}
//} // 內圈 for 迴圈
            } //外圈 for 迴圈
            //alert("共執行:"+count+"次,零件總體積:"+volume);
            //alert("零件體積:"+properties.Volume);
            //alert("零件體積取整數:"+Math.round(properties.Volume));
        }
    catch(err)
        {
            alert ("Exception occurred: "+pfcGetExceptionType (err));
        }
// ]]&gt;&lt;/script&gt;
'''
    return outstring
</t>
<t tx="amd.20151122094546.2">@language python

import cherrypy
import os
import sys
# 這個程式要計算正齒輪的齒面寬, 資料庫連結希望使用 pybean 與 SQLite
# 導入 pybean 模組與所要使用的 Store 及 SQLiteWriter 方法
from pybean import Store, SQLiteWriter
import math

# 確定程式檔案所在目錄, 在 Windows 有最後的反斜線
_curdir = os.path.join(os.getcwd(), os.path.dirname(__file__))
# 將所在目錄設為系統搜尋目錄
sys.path.append(_curdir)
if 'OPENSHIFT_REPO_DIR' in os.environ.keys():
    # while program is executed in OpenShift
    download_root_dir = os.environ['OPENSHIFT_DATA_DIR']
    data_dir = os.environ['OPENSHIFT_DATA_DIR']
else:
    # while program is executed in localhost
    download_root_dir = _curdir + "/local_data/"
    data_dir = _curdir + "/local_data/"

# 這是 Gear 設計資料表的定義
'''

lewis.db 中有兩個資料表, steel 與 lewis

 CREATE TABLE steel ( 
    serialno      INTEGER,
    unsno         TEXT,
    aisino        TEXT,
    treatment     TEXT,
    yield_str     INTEGER,
    tensile_str   INTEGER,
    stretch_ratio INTEGER,
    sectional_shr INTEGER,
    brinell       INTEGER 
);

CREATE TABLE lewis ( 
    serialno INTEGER PRIMARY KEY
                     NOT NULL,
    gearno   INTEGER,
    type1    NUMERIC,
    type4    NUMERIC,
    type3    NUMERIC,
    type2    NUMERIC 
);
'''

</t>
<t tx="amd.20151122094546.3">class Gear(object):
    @others
</t>
<t tx="amd.20151122094546.4">def __init__(self):
    # hope to create downloads and images directories　
    if not os.path.isdir(download_root_dir+"downloads"):
        try:
            os.makedirs(download_root_dir+"downloads")
        except:
            print("mkdir error")
    if not os.path.isdir(download_root_dir+"images"):
        try:
            os.makedirs(download_root_dir+"images")
        except:
            print("mkdir error")
    if not os.path.isdir(download_root_dir+"tmp"):
        try:
            os.makedirs(download_root_dir+"tmp")
        except:
            print("mkdir error")
</t>
<t tx="amd.20151122094546.5">@cherrypy.expose
def default(self, attr='default', *args, **kwargs):
    raise cherrypy.HTTPRedirect("/")
</t>
<t tx="amd.20151122094546.6"># 各組利用 index 引導隨後的程式執行
@cherrypy.expose
def index(self, *args, **kwargs):
    # 進行資料庫檔案連結,  並且取出所有資料
    try:
        # 利用 Store  建立資料庫檔案對應物件, 並且設定 frozen=True 表示不要開放動態資料表的建立
        # 因為程式以 application 所在目錄執行, 因此利用相對目錄連結 lewis.db 資料庫檔案
        SQLite連結 = Store(SQLiteWriter(_curdir+"/lewis.db", frozen=True))
        #material = SQLite連結.find_one("steel","serialno = ?",[序號])
        # str(SQLite連結.count("steel")) 將傳回 70, 表示資料庫中有 70 筆資料
        material = SQLite連結.find("steel")
        # 所傳回的 material 為 iterator
        '''
        outstring = ""
        for material_item in material:
            outstring += str(material_item.serialno) + ":" + material_item.unsno + "_" + material_item.treatment + "&lt;br /&gt;"
        return outstring
        '''
    except:
        return "抱歉! 資料庫無法連線&lt;br /&gt;"

    outstring = '''
\\-4.&lt;form id=entry method=post action="gear_width"&gt;
\\-4.請填妥下列參數，以完成適當的齒尺寸大小設計。&lt;br /&gt;
\\-4.馬達馬力:&lt;input type=text name=horsepower id=horsepower value=100 size=10&gt;horse power&lt;br /&gt;
\\-4.馬達轉速:&lt;input type=text name=rpm id=rpm value=1120 size=10&gt;rpm&lt;br /&gt;
\\-4.齒輪減速比: &lt;input type=text name=ratio id=ratio value=4 size=10&gt;&lt;br /&gt;
\\-4.齒形:&lt;select name=toothtype id=toothtype&gt;
\\-4.&lt;option value=type1&gt;壓力角20度,a=0.8,b=1.0
\\-4.&lt;option value=type2&gt;壓力角20度,a=1.0,b=1.25
\\-4.&lt;option value=type3&gt;壓力角25度,a=1.0,b=1.25
\\-4.&lt;option value=type4&gt;壓力角25度,a=1.0,b=1.35
\\-4.&lt;/select&gt;&lt;br /&gt;
\\-4.安全係數:&lt;input type=text name=safetyfactor id=safetyfactor value=3 size=10&gt;&lt;br /&gt;
\\-4.齒輪材質:&lt;select name=material_serialno id=material_serialno&gt;
\\-4.'''
    for material_item in material:
        outstring += "&lt;option value=" + str(material_item.serialno) + "&gt;UNS - " + \
            material_item.unsno + " - " + material_item.treatment
    outstring += "&lt;/select&gt;&lt;br /&gt;"
    
    outstring += "小齒輪齒數:&lt;input type=text name=npinion id=npinion value=18 size=10&gt;&lt;br /&gt;"
    outstring += "&lt;input type=submit id=submit value=進行運算&gt;"
    outstring += "&lt;/form&gt;"

    return outstring
</t>
<t tx="amd.20151122094546.7">@cherrypy.expose
def interpolation(self, small_gear_no=18, gear_type=1):
    SQLite連結 = Store(SQLiteWriter(_curdir+"/lewis.db", frozen=True))
    # 使用內插法求值
    # 找出比目標齒數大的其中的最小的,就是最鄰近的大值
    lewis_factor = SQLite連結.find_one("lewis","gearno &gt; ?",[small_gear_no])
    if(gear_type == 1):
        larger_formfactor = lewis_factor.type1
    elif(gear_type == 2):
        larger_formfactor = lewis_factor.type2
    elif(gear_type == 3):
        larger_formfactor = lewis_factor.type3
    else:
        larger_formfactor = lewis_factor.type4
    larger_toothnumber = lewis_factor.gearno
 
    # 找出比目標齒數小的其中的最大的,就是最鄰近的小值
    lewis_factor = SQLite連結.find_one("lewis","gearno &lt; ? order by gearno DESC",[small_gear_no])
    if(gear_type == 1):
        smaller_formfactor = lewis_factor.type1
    elif(gear_type == 2):
        smaller_formfactor = lewis_factor.type2
    elif(gear_type == 3):
        smaller_formfactor = lewis_factor.type3
    else:
        smaller_formfactor = lewis_factor.type4
    smaller_toothnumber = lewis_factor.gearno
    calculated_factor = larger_formfactor + (small_gear_no - larger_toothnumber) * (larger_formfactor - smaller_formfactor) / (larger_toothnumber - smaller_toothnumber)
    # 只傳回小數點後五位數
    return str(round(calculated_factor, 5))
</t>
<t tx="amd.20151122094546.8"># 改寫為齒面寬的設計函式
@cherrypy.expose
def gear_width(self, horsepower=100, rpm=1000, ratio=4, toothtype=1, safetyfactor=2, material_serialno=1, npinion=18):
    SQLite連結 = Store(SQLiteWriter(_curdir+"/lewis.db", frozen=True))
    outstring = ""
    # 根據所選用的齒形決定壓力角
    if(toothtype == 1 or toothtype == 2):
        壓力角 = 20
    else:
        壓力角 = 25
 
    # 根據壓力角決定最小齒數
    if(壓力角== 20):
        最小齒數 = 18
    else:
        最小齒數 = 12
 
    # 直接設最小齒數
    if int(npinion) &lt;= 最小齒數:
        npinion = 最小齒數
    # 大於400的齒數則視為齒條(Rack)
    if int(npinion) &gt;= 400:
        npinion = 400
 
    # 根據所選用的材料查詢強度值
    # 由 material之序號查 steel 表以得材料之降伏強度S單位為 kpsi 因此查得的值要成乘上1000
    # 利用 Store  建立資料庫檔案對應物件, 並且設定 frozen=True 表示不要開放動態資料表的建立
    #SQLite連結 = Store(SQLiteWriter("lewis.db", frozen=True))
    # 指定 steel 資料表
    steel = SQLite連結.new("steel")
    # 資料查詢
    #material = SQLite連結.find_one("steel","unsno=? and treatment=?",[unsno, treatment])
    material = SQLite連結.find_one("steel","serialno=?",[material_serialno])
    # 列出 steel 資料表中的資料筆數
    #print(SQLite連結.count("steel"))
    #print (material.yield_str)
    strengthstress = material.yield_str*1000
    # 由小齒輪的齒數與齒形類別,查詢lewis form factor
    # 先查驗是否有直接對應值
    on_table = SQLite連結.count("lewis","gearno=?",[npinion])
    if on_table == 1:
        # 直接進入設計運算
        #print("直接運算")
        #print(on_table)
        lewis_factor = SQLite連結.find_one("lewis","gearno=?",[npinion])
        #print(lewis_factor.type1)
        # 根據齒形查出 formfactor 值
        if(toothtype == 1):
            formfactor = lewis_factor.type1
        elif(toothtype == 2):
            formfactor = lewis_factor.type2
        elif(toothtype == 3):
            formfactor = lewis_factor.type3
        else:
            formfactor = lewis_factor.type4
    else:
        # 沒有直接對應值, 必須進行查表內插運算後, 再執行設計運算
        #print("必須內插")
        #print(interpolation(npinion, gear_type))
        formfactor = self.interpolation(npinion, toothtype)
 
    # 開始進行設計運算
 
    ngear = int(npinion) * int(ratio)
 
    # 重要的最佳化設計---儘量用整數的diametralpitch
    # 先嘗試用整數算若 diametralpitch 找到100 仍無所獲則改用 0.25 作為增量再不行則宣告 fail
    counter = 0
    i = 0.1
    facewidth = 0
    circularpitch = 0
    while (facewidth &lt;= 3 * circularpitch or facewidth &gt;= 5 * circularpitch):
        diametralpitch = i
        #circularpitch = 3.14159/diametralpitch
        circularpitch = math.pi/diametralpitch
        pitchdiameter = int(npinion)/diametralpitch
        #pitchlinevelocity = 3.14159*pitchdiameter*rpm/12
        pitchlinevelocity = math.pi*pitchdiameter * float(rpm)/12
        transmittedload = 33000*float(horsepower)/pitchlinevelocity
        velocityfactor = 1200/(1200 + pitchlinevelocity)
        # formfactor is Lewis form factor
        # formfactor need to get from table 13-3 and determined ty teeth number and type of tooth
        # formfactor = 0.293
        # 90 is the value get from table corresponding to material type
        facewidth = transmittedload*diametralpitch*float(safetyfactor)/velocityfactor/formfactor/strengthstress
        if(counter&gt;5000):
            outstring += "超過5000次的設計運算,仍無法找到答案!&lt;br /&gt;"
            outstring += "可能所選用的傳遞功率過大,或無足夠強度的材料可以使用!&lt;br /&gt;"
            # 離開while迴圈
            break
        i += 0.1
        counter += 1
    facewidth = round(facewidth, 4)
    if(counter&lt;5000):
        # 先載入 cube 程式測試
        #outstring = self.cube_weblink()
        # 再載入 gear 程式測試
        outstring = self.gear_weblink()

        outstring += "進行"+str(counter)+"次重複運算後,得到合用的facewidth值為:"+str(facewidth)
    return outstring
</t>
<t tx="amd.20151122094546.9">@cherrypy.expose
def cube_weblink(self):
    outstring = '''&lt;script type="text/javascript" src="/static/pfcUtils.js"&gt;&lt;/script&gt;
&lt;script type="text/javascript" src="/static/wl_header.js"&gt;
document.writeln ("Error loading Pro/Web.Link header!");
&lt;/script&gt;
&lt;script type="text/javascript" language="JavaScript"&gt;
// 若第三輸入為 false, 表示僅載入 session, 但是不顯示
// ret 為 model open return
 var ret = document.pwl.pwlMdlOpen("cube.prt", "v:/tmp", false);
if (!ret.Status) {
    alert("pwlMdlOpen failed (" + ret.ErrorCode + ")");
}
    //將 ProE 執行階段設為變數 session
    var session = pfcGetProESession();
    // 在視窗中打開零件檔案, 並且顯示出來
    var window = session.OpenFile(pfcCreate("pfcModelDescriptor").CreateFromFileName("cube.prt"));
    var solid = session.GetModel("cube.prt",pfcCreate("pfcModelType").MDL_PART);
    var length,width,myf,myn,i,j,volume,count,d1Value,d2Value;
    // 將模型檔中的 length 變數設為 javascript 中的 length 變數
    length = solid.GetParam("a1");
    // 將模型檔中的 width 變數設為 javascript 中的 width 變數
    width = solid.GetParam("a2");
//改變零件尺寸
    //myf=20;
    //myn=20;
    volume=0;
    count=0;
    try
    {
            // 以下採用 URL 輸入對應變數
            //createParametersFromArguments ();
            // 以下則直接利用 javascript 程式改變零件參數
            for(i=0;i&lt;=5;i++)
            {
                //for(j=0;j&lt;=2;j++)
                //{
                    myf=20.0;
                    myn=10.0+i*0.5;
// 設定變數值, 利用 ModelItem 中的 CreateDoubleParamValue 轉換成 Pro/Web.Link 所需要的浮點數值
         d1Value = pfcCreate ("MpfcModelItem").CreateDoubleParamValue(myf);
         d2Value = pfcCreate ("MpfcModelItem").CreateDoubleParamValue(myn);
// 將處理好的變數值, 指定給對應的零件變數
                    length.Value = d1Value;
                    width.Value = d2Value;
                    //零件尺寸重新設定後, 呼叫 Regenerate 更新模型
                    solid.Regenerate(void null);
                    //利用 GetMassProperty 取得模型的質量相關物件
                    properties = solid.GetMassProperty(void null);
                    //volume = volume + properties.Volume;
volume = properties.Volume;
                    count = count + 1;
alert("執行第"+count+"次,零件總體積:"+volume);
// 將零件存為新檔案
var newfile = document.pwl.pwlMdlSaveAs("cube.prt", "v:/tmp", "cube"+count+".prt");
if (!newfile.Status) {
    alert("pwlMdlSaveAs failed (" + newfile.ErrorCode + ")");
}
//} // 內圈 for 迴圈
            } //外圈 for 迴圈
            //alert("共執行:"+count+"次,零件總體積:"+volume);
            //alert("零件體積:"+properties.Volume);
            //alert("零件體積取整數:"+Math.round(properties.Volume));
        }
    catch(err)
        {
            alert ("Exception occurred: "+pfcGetExceptionType (err));
        }
&lt;/script&gt;
'''
    return outstring
</t>
<t tx="amd.20151122094835.1"># coding=utf-8
# 上面的程式內容編碼必須在程式的第一或者第二行才會有作用

@language python
@tabwidth -4

&lt;&lt;declarations&gt;&gt;
@others
################# (4) 程式啟動區
# 配合程式檔案所在目錄設定靜態目錄或靜態檔案
application_conf = {'/static':{
        'tools.staticdir.on': True,
        # 程式執行目錄下, 必須自行建立 static 目錄
        'tools.staticdir.dir': _curdir+"/static"},
        '/downloads':{
        'tools.staticdir.on': True,
        'tools.staticdir.dir': data_dir+"/downloads"},
        '/images':{
        'tools.staticdir.on': True,
        'tools.staticdir.dir': data_dir+"/images"}
    }
    
root = Brython()
root.download = Download()

#root.gear = gear.Gear()

if 'OPENSHIFT_REPO_DIR' in os.environ.keys():
    # 表示在 OpenSfhit 執行
    application = cherrypy.Application(root, config=application_conf)
else:
    # 避開 winreg 模組無法找到的問題"
    # Ubuntu 14.04, Python 3.4.0, CherryPy 3.5.0
    #cherrypy.config.update({'engine.autoreload_on':False})
    # 表示在近端執行(假如在近端採用 wsgi 模式啟動, 則與 OpenShift 相同
    cherrypy.quickstart(root, config=application_conf)
</t>
<t tx="amd.20151122094835.10">@cherrypy.expose
# N 為齒數, M 為模數, P 為壓力角
def drawspuraction(self, N=20, M=5, P=15):
    outstring = '''
&lt;!DOCTYPE html&gt; 
&lt;html&gt;
&lt;head&gt;
&lt;meta http-equiv="content-type" content="text/html;charset=utf-8"&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;a href="index"&gt;index&lt;/a&gt;&lt;br /&gt;
    
&lt;!-- 以下為 canvas 畫圖程式 --&gt;
&lt;script type="text/python"&gt;
# 從 browser 導入 document
from browser import document
from math import *
# 請注意, 這裡導入位於 Lib/site-packages 目錄下的 spur.py 檔案
import spur

# 準備在 id="plotarea" 的 canvas 中繪圖
canvas = document["plotarea"]
ctx = canvas.getContext("2d")

# 以下利用 spur.py 程式進行繪圖
# N 為齒數
N = '''+str(N)+'''
# M 為模數
M = '''+str(M)+'''
# 壓力角 P 單位為角度
P = '''+str(P)+'''
# 計算兩齒輪的節圓半徑
rp = N*M/2

spur.Spur(ctx).Gear(600, 600, rp, N, P, "blue")

&lt;/script&gt;
&lt;canvas id="plotarea" width="1200" height="1200"&gt;&lt;/canvas&gt;
&lt;!-- 載入 brython.js --&gt;
&lt;script type="text/javascript" src="/static/Brython3.1.3-20150514-095342/brython.js"&gt;&lt;/script&gt;
&lt;script&gt;
window.onload=function(){
brython();
}
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
'''

    return outstring</t>
<t tx="amd.20151122094835.11">@cherrypy.expose
# W 為正方體的邊長
def cube(self, W=10):
    outstring = '''
&lt;!DOCTYPE html&gt; 
&lt;html&gt;
&lt;head&gt;
&lt;meta http-equiv="content-type" content="text/html;charset=utf-8"&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;!-- 使用者輸入表單的參數交由 cubeaction 方法處理 --&gt;
&lt;form method=POST action=cubeaction&gt;
正方體邊長:&lt;input type=text name=W value='''+str(W)+'''&gt;&lt;br /&gt;
&lt;input type=submit value=送出&gt;
&lt;/form&gt;
&lt;br /&gt;&lt;a href="index"&gt;index&lt;/a&gt;&lt;br /&gt;
&lt;/body&gt;
&lt;/html&gt;
'''

    return outstring</t>
<t tx="amd.20151122094835.12">@cherrypy.expose
# W 為正方體邊長, 內定值為 10
def cubeaction(self, W=10):
    outstring = '''
&lt;!DOCTYPE html&gt; 
&lt;html&gt;
&lt;head&gt;
&lt;meta http-equiv="content-type" content="text/html;charset=utf-8"&gt;
&lt;!-- 先載入 pfcUtils.js 與 wl_header.js --&gt;
&lt;script type="text/javascript" src="/static/weblink/pfcUtils.js"&gt;&lt;/script&gt;
&lt;script type="text/javascript" src="/static/weblink/wl_header.js"&gt;
&lt;!-- 載入 brython.js --&gt;
&lt;script type="text/javascript" src="/static/Brython3.1.3-20150514-095342/brython.js"&gt;&lt;/script&gt;
document.writeln ("Error loading Pro/Web.Link header!");
&lt;/script&gt;
&lt;script&gt;
window.onload=function(){
brython();
}
&lt;/script&gt;
&lt;/head&gt;
&lt;!-- 不要使用 body 啟動 brython() 改為 window level 啟動 --&gt;
&lt;body onload=""&gt;
&lt;h1&gt;Creo 參數化零件&lt;/h1&gt;
&lt;a href="index"&gt;index&lt;/a&gt;&lt;br /&gt;

&lt;!-- 以下為 Creo Pro/Web.Link 程式, 將 JavaScrip 改為 Brython 程式 --&gt;

&lt;script type="text/python"&gt;
from browser import document, window
from math import *

# 這個區域為 Brython 程式範圍, 註解必須採用 Python 格式
# 因為 pfcIsWindows() 為原生的 JavaScript 函式, 在 Brython 中引用必須透過 window 物件
if (!window.pfcIsWindows()) window.netscape.security.PrivilegeManager.enablePrivilege("UniversalXPConnect");
# 若第三輸入為 false, 表示僅載入 session, 但是不顯示
# ret 為 model open return
ret = document.pwl.pwlMdlOpen("cube.prt", "v:/tmp", false)
if (!ret.Status):
    window.alert("pwlMdlOpen failed (" + ret.ErrorCode + ")")
    # 將 ProE 執行階段設為變數 session
    session = window.pfcGetProESession()
    # 在視窗中打開零件檔案, 並且顯示出來
    pro_window = session.OpenFile(pfcCreate("pfcModelDescriptor").CreateFromFileName("cube.prt"))
    solid = session.GetModel("cube.prt", window.pfcCreate("pfcModelType").MDL_PART)
    # 在 Brython 中與 Python 語法相同, 只有初值設定問題, 無需宣告變數
    # length, width, myf, myn, i, j, volume, count, d1Value, d2Value
    # 將模型檔中的 length 變數設為 javascript 中的 length 變數
    length = solid.GetParam("a1")
    # 將模型檔中的 width 變數設為 javascript 中的 width 變數
    width = solid.GetParam("a2")
    # 改變零件尺寸
    # myf=20
    # myn=20
    volume = 0
    count = 0
    try:
        # 以下採用 URL 輸入對應變數
        # createParametersFromArguments ();
        # 以下則直接利用 javascript 程式改變零件參數
        for i in range(5):
            myf ='''+str(W)+'''
            myn ='''+str(W)+''' + i*2.0
            # 設定變數值, 利用 ModelItem 中的 CreateDoubleParamValue 轉換成 Pro/Web.Link 所需要的浮點數值
            d1Value = window.pfcCreate ("MpfcModelItem").CreateDoubleParamValue(myf)
            d2Value = window.pfcCreate ("MpfcModelItem").CreateDoubleParamValue(myn)
            # 將處理好的變數值, 指定給對應的零件變數
            length.Value = d1Value
            width.Value = d2Value
            # 零件尺寸重新設定後, 呼叫 Regenerate 更新模型
            # 在 JavaScript 為 null 在 Brython 為 None
            solid.Regenerate(None)
            # 利用 GetMassProperty 取得模型的質量相關物件
            properties = solid.GetMassProperty(None)
            # volume = volume + properties.Volume
            volume = properties.Volume
            count = count + 1
            window.alert("執行第"+count+"次,零件總體積:"+volume)
            # 將零件存為新檔案
            newfile = document.pwl.pwlMdlSaveAs("cube.prt", "v:/tmp", "cube"+count+".prt")
            if (!newfile.Status):
                window.alert("pwlMdlSaveAs failed (" + newfile.ErrorCode + ")")
            # window.alert("共執行:"+count+"次,零件總體積:"+volume)
            # window.alert("零件體積:"+properties.Volume)
            # window.alert("零件體積取整數:"+Math.round(properties.Volume));
    except:
        window.alert ("Exception occurred: "+window.pfcGetExceptionType (err))
&lt;/script&gt;
'''

    return outstring</t>
<t tx="amd.20151122094835.13">@cherrypy.expose
def fileuploadform(self):
    return '''&lt;h1&gt;file upload&lt;/h1&gt;
&lt;script src="/static/jquery.js" type="text/javascript"&gt;&lt;/script&gt;
&lt;script src="/static/axuploader.js" type="text/javascript"&gt;&lt;/script&gt;
&lt;script&gt;
$(document).ready(function(){
$('.prova').axuploader({url:'fileaxupload', allowExt:['jpg','png','gif','7z','pdf','zip','flv','stl','swf'],
finish:function(x,files)
    {
        alert('All files have been uploaded: '+files);
    },
enable:true,
remotePath:function(){
return 'downloads/';
}
});
});
&lt;/script&gt;
&lt;div class="prova"&gt;&lt;/div&gt;
&lt;input type="button" onclick="$('.prova').axuploader('disable')" value="asd" /&gt;
&lt;input type="button" onclick="$('.prova').axuploader('enable')" value="ok" /&gt;
&lt;/section&gt;&lt;/body&gt;&lt;/html&gt;
'''</t>
<t tx="amd.20151122094835.14">@cherrypy.expose
def fileaxupload(self, *args, **kwargs):
    filename = kwargs["ax-file-name"]
    flag = kwargs["start"]
    if flag == "0":
        file = open(download_root_dir+"downloads/"+filename, "wb")
    else:
        file = open(download_root_dir+"downloads/"+filename, "ab")
    file.write(cherrypy.request.body.read())
    header= cherrypy.request.body.read(80)
    file.close()
    return "files uploaded!"+header.decode("UTF-8")
</t>
<t tx="amd.20151122094835.15">@cherrypy.expose
def download_list(self, item_per_page=5, page=1, keyword=None, *args, **kwargs):
    files = os.listdir(download_root_dir+"downloads/")
    total_rows = len(files)
    totalpage = math.ceil(total_rows/int(item_per_page))
    starti = int(item_per_page) * (int(page) - 1) + 1
    endi = starti + int(item_per_page) - 1
    outstring = "&lt;form method='post' action='delete_file'&gt;"
    notlast = False
    if total_rows &gt; 0:
        outstring += "&lt;br /&gt;"
        if (int(page) * int(item_per_page)) &lt; total_rows:
            notlast = True
        if int(page) &gt; 1:
            outstring += "&lt;a href='"
            outstring += "download_list?&amp;amp;page=1&amp;amp;item_per_page="+str(item_per_page)+"&amp;amp;keyword="+str(cherrypy.session.get('download_keyword'))
            outstring += "'&gt;&lt;&lt;&lt;/a&gt; "
            page_num = int(page) - 1
            outstring += "&lt;a href='"
            outstring += "download_list?&amp;amp;page="+str(page_num)+"&amp;amp;item_per_page="+str(item_per_page)+"&amp;amp;keyword="+str(cherrypy.session.get('download_keyword'))
            outstring += "'&gt;Previous&lt;/a&gt; "
        span = 10
        for index in range(int(page)-span, int(page)+span):
            if index&gt;= 0 and index&lt; totalpage:
                page_now = index + 1 
                if page_now == int(page):
                    outstring += "&lt;font size='+1' color='red'&gt;"+str(page)+" &lt;/font&gt;"
                else:
                    outstring += "&lt;a href='"
                    outstring += "download_list?&amp;amp;page="+str(page_now)+"&amp;amp;item_per_page="+str(item_per_page)+"&amp;amp;keyword="+str(cherrypy.session.get('download_keyword'))
                    outstring += "'&gt;"+str(page_now)+"&lt;/a&gt; "

        if notlast == True:
            nextpage = int(page) + 1
            outstring += " &lt;a href='"
            outstring += "download_list?&amp;amp;page="+str(nextpage)+"&amp;amp;item_per_page="+str(item_per_page)+"&amp;amp;keyword="+str(cherrypy.session.get('download_keyword'))
            outstring += "'&gt;Next&lt;/a&gt;"
            outstring += " &lt;a href='"
            outstring += "download_list?&amp;amp;page="+str(totalpage)+"&amp;amp;item_per_page="+str(item_per_page)+"&amp;amp;keyword="+str(cherrypy.session.get('download_keyword'))
            outstring += "'&gt;&gt;&gt;&lt;/a&gt;&lt;br /&gt;&lt;br /&gt;"
        if (int(page) * int(item_per_page)) &lt; total_rows:
            notlast = True
            outstring += downloadlist_access_list(files, starti, endi)+"&lt;br /&gt;"
        else:
            outstring += "&lt;br /&gt;&lt;br /&gt;"
            outstring += downloadlist_access_list(files, starti, total_rows)+"&lt;br /&gt;"
        
        if int(page) &gt; 1:
            outstring += "&lt;a href='"
            outstring += "download_list?&amp;amp;page=1&amp;amp;item_per_page="+str(item_per_page)+"&amp;amp;keyword="+str(cherrypy.session.get('download_keyword'))
            outstring += "'&gt;&lt;&lt;&lt;/a&gt; "
            page_num = int(page) - 1
            outstring += "&lt;a href='"
            outstring += "download_list?&amp;amp;page="+str(page_num)+"&amp;amp;item_per_page="+str(item_per_page)+"&amp;amp;keyword="+str(cherrypy.session.get('download_keyword'))
            outstring += "'&gt;Previous&lt;/a&gt; "
        span = 10
        for index in range(int(page)-span, int(page)+span):
        #for ($j=$page-$range;$j&lt;$page+$range;$j++)
            if index &gt;=0 and index &lt; totalpage:
                page_now = index + 1
                if page_now == int(page):
                    outstring += "&lt;font size='+1' color='red'&gt;"+str(page)+" &lt;/font&gt;"
                else:
                    outstring += "&lt;a href='"
                    outstring += "download_list?&amp;amp;page="+str(page_now)+"&amp;amp;item_per_page="+str(item_per_page)+"&amp;amp;keyword="+str(cherrypy.session.get('download_keyword'))
                    outstring += "'&gt;"+str(page_now)+"&lt;/a&gt; "
        if notlast == True:
            nextpage = int(page) + 1
            outstring += " &lt;a href='"
            outstring += "download_list?&amp;amp;page="+str(nextpage)+"&amp;amp;item_per_page="+str(item_per_page)+"&amp;amp;keyword="+str(cherrypy.session.get('download_keyword'))
            outstring += "'&gt;Next&lt;/a&gt;"
            outstring += " &lt;a href='"
            outstring += "download_list?&amp;amp;page="+str(totalpage)+"&amp;amp;item_per_page="+str(item_per_page)+"&amp;amp;keyword="+str(cherrypy.session.get('download_keyword'))
            outstring += "'&gt;&gt;&gt;&lt;/a&gt;"
    else:
        outstring += "no data!"
    outstring += "&lt;br /&gt;&lt;br /&gt;&lt;input type='submit' value='delete'&gt;&lt;input type='reset' value='reset'&gt;&lt;/form&gt;"

    return "&lt;div class='container'&gt;&lt;nav&gt;"+ \
        "&lt;/nav&gt;&lt;section&gt;&lt;h1&gt;Download List&lt;/h1&gt;"+outstring+"&lt;br/&gt;&lt;br /&gt;&lt;/body&gt;&lt;/html&gt;"
</t>
<t tx="amd.20151122094835.16">@cherrypy.expose
# N 為齒數, M 為模數, P 為壓力角
def threegears(self, N=20, M=5, P=15):
    outstring = '''
&lt;!DOCTYPE html&gt; 
&lt;html&gt;
&lt;head&gt;
&lt;meta http-equiv="content-type" content="text/html;charset=utf-8"&gt;
&lt;!-- 載入 brython.js --&gt;
&lt;script type="text/javascript" src="/static/Brython3.1.3-20150514-095342/brython.js"&gt;&lt;/script&gt;
&lt;script src="/static/Cango2D.js" type="text/javascript"&gt;&lt;/script&gt;
&lt;script src="/static/gearUtils-04.js" type="text/javascript"&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;!-- 啟動 brython() --&gt;
&lt;body onload="brython()"&gt;

&lt;!-- 以下為 canvas 畫圖程式 --&gt;
&lt;script type="text/python"&gt;
# 從 browser 導入 document
from browser import document
from math import *
# 請注意, 這裡導入位於 Lib/site-packages 目錄下的 spur.py 檔案
import spur

# 準備在 id="plotarea" 的 canvas 中繪圖
canvas = document["plotarea"]
ctx = canvas.getContext("2d")

# 以下利用 spur.py 程式進行繪圖, 接下來的協同設計運算必須要配合使用者的需求進行設計運算與繪圖
# 其中並將工作分配給其他組員建立類似 spur.py 的相關零件繪圖模組
# midx, midy 為齒輪圓心座標, rp 為節圓半徑, n 為齒數, pa 為壓力角, color 為線的顏色
# Gear(midx, midy, rp, n=20, pa=20, color="black"):
# 模數決定齒的尺寸大小, 囓合齒輪組必須有相同的模數與壓力角
# 壓力角 pa 單位為角度
pa = 20
# m 為模數
m = 20
# 第1齒輪齒數
n_g1 = 17
# 第2齒輪齒數
n_g2 = 19
# 第3齒輪齒數
n_g3 = 17
# 計算兩齒輪的節圓半徑
rp_g1 = m*n_g1/2
rp_g2 = m*n_g2/2
rp_g3 = m*n_g3/2

# 繪圖第1齒輪的圓心座標
x_g1 = 280
y_g1 = 400
# 第2齒輪的圓心座標, 假設排列成水平, 表示各齒輪圓心 y 座標相同
x_g2 = x_g1 + rp_g1 + rp_g2
y_g2 = y_g1
# 第3齒輪的圓心座標
x_g3 = x_g1 + rp_g1 + 2*rp_g2 + rp_g3
y_g3 = y_g1

# 將第1齒輪順時鐘轉 90 度
# 使用 ctx.save() 與 ctx.restore() 以確保各齒輪以相對座標進行旋轉繪圖
ctx.save()
# translate to the origin of second gear
ctx.translate(x_g1, y_g1)
# rotate to engage
ctx.rotate(pi/2)
# put it back
ctx.translate(-x_g1, -y_g1)
spur.Spur(ctx).Gear(x_g1, y_g1, rp_g1, n_g1, pa, "blue")
ctx.restore()

# 將第2齒輪逆時鐘轉 90 度之後, 再多轉一齒, 以便與第1齒輪進行囓合
ctx.save()
# translate to the origin of second gear
ctx.translate(x_g2, y_g2)
# rotate to engage
ctx.rotate(-pi/2-pi/n_g2)
# put it back
ctx.translate(-x_g2, -y_g2)
spur.Spur(ctx).Gear(x_g2, y_g2, rp_g2, n_g2, pa, "black")
ctx.restore()

# 將第3齒輪逆時鐘轉 90 度之後, 再往回轉第2齒輪定位帶動轉角, 然後再逆時鐘多轉一齒, 以便與第2齒輪進行囓合
ctx.save()
# translate to the origin of second gear
ctx.translate(x_g3, y_g3)
# rotate to engage
# pi+pi/n_g2 為第2齒輪從順時鐘轉 90 度之後, 必須配合目前的標記線所作的齒輪 2 轉動角度, 要轉換到齒輪3 的轉動角度
# 必須乘上兩齒輪齒數的比例, 若齒輪2 大, 則齒輪3 會轉動較快
# 第1個 -pi/2 為將原先垂直的第3齒輪定位線逆時鐘旋轉 90 度
# -pi/n_g3 則是第3齒與第2齒定位線重合後, 必須再逆時鐘多轉一齒的轉角, 以便進行囓合
# (pi+pi/n_g2)*n_g2/n_g3 則是第2齒原定位線為順時鐘轉動 90 度, 
# 但是第2齒輪為了與第1齒輪囓合, 已經距離定位線, 多轉了 180 度, 再加上第2齒輪的一齒角度, 因為要帶動第3齒輪定位, 
# 這個修正角度必須要再配合第2齒與第3齒的轉速比加以轉換成第3齒輪的轉角, 因此乘上 n_g2/n_g3
ctx.rotate(-pi/2-pi/n_g3+(pi+pi/n_g2)*n_g2/n_g3)
# put it back
ctx.translate(-x_g3, -y_g3)
spur.Spur(ctx).Gear(x_g3, y_g3, rp_g3, n_g3, pa, "red")
ctx.restore()

# 按照上面三個正齒輪的囓合轉角運算, 隨後的傳動齒輪轉角便可依此類推, 完成6個齒輪的囓合繪圖

&lt;/script&gt;
&lt;canvas id="plotarea" width="1200" height="1200"&gt;&lt;/canvas&gt;
&lt;/body&gt;
&lt;/html&gt;
'''

    return outstring
</t>
<t tx="amd.20151122094835.17">class Download:
    @others
</t>
<t tx="amd.20151122094835.18">@cherrypy.expose
def index(self, filepath):
    return serve_file(filepath, "application/x-download", "attachment")
</t>
<t tx="amd.20151122094835.2">################# (1) 模組導入區
# 導入 cherrypy 模組, 為了在 OpenShift 平台上使用 cherrypy 模組, 必須透過 setup.py 安裝
import cherrypy
# 導入 Python 內建的 os 模組, 因為 os 模組為 Python 內建, 所以無需透過 setup.py 安裝
import os
# 導入 random 模組
import random
import math
from cherrypy.lib.static import serve_file
# 導入 gear 模組
#import gear

################# (2) 廣域變數設定區
# 確定程式檔案所在目錄, 在 Windows 下有最後的反斜線
_curdir = os.path.join(os.getcwd(), os.path.dirname(__file__))
# 設定在雲端與近端的資料儲存目錄
if 'OPENSHIFT_REPO_DIR' in os.environ.keys():
    # 表示程式在雲端執行
    download_root_dir = os.environ['OPENSHIFT_DATA_DIR']
    data_dir = os.environ['OPENSHIFT_DATA_DIR']
else:
    # 表示程式在近端執行
    download_root_dir = _curdir + "/local_data/"
    data_dir = _curdir + "/local_data/"


</t>
<t tx="amd.20151122094835.3">def sizeof_fmt(num):
    for x in ['bytes','KB','MB','GB']:
        if num &lt; 1024.0:
            return "%3.1f%s" % (num, x)
        num /= 1024.0
    return "%3.1f%s" % (num, 'TB')
</t>
<t tx="amd.20151122094835.4">################# (3) 程式類別定義區
# 以下改用 CherryPy 網際框架程式架構
# 以下為 Hello 類別的設計內容, 其中的 object 使用, 表示 Hello 類別繼承 object 的所有特性, 包括方法與屬性設計
class Brython(object):

    # Midterm 類別的啟動設定
    _cp_config = {
    'tools.encode.encoding': 'utf-8',
    'tools.sessions.on' : True,
    'tools.sessions.storage_type' : 'file',
    #'tools.sessions.locking' : 'explicit',
    # session 以檔案儲存, 而且位於 data_dir 下的 tmp 目錄
    'tools.sessions.storage_path' : data_dir+'/tmp',
    # session 有效時間設為 60 分鐘
    'tools.sessions.timeout' : 60
    }

    @others
</t>
<t tx="amd.20151122094835.5">def __init__(self):
    # hope to create downloads and images directories　
    if not os.path.isdir(download_root_dir+"downloads"):
        try:
            os.makedirs(download_root_dir+"downloads")
        except:
            print("mkdir error")
    if not os.path.isdir(download_root_dir+"images"):
        try:
            os.makedirs(download_root_dir+"images")
        except:
            print("mkdir error")
    if not os.path.isdir(download_root_dir+"tmp"):
        try:
            os.makedirs(download_root_dir+"tmp")
        except:
            print("mkdir error")
</t>
<t tx="amd.20151122094835.6"># 以 @ 開頭的 cherrypy.expose 為 decorator, 用來表示隨後的成員方法, 可以直接讓使用者以 URL 連結執行
@cherrypy.expose
# index 方法為 CherryPy 各類別成員方法中的內建(default)方法, 當使用者執行時未指定方法, 系統將會優先執行 index 方法
# 有 self 的方法為類別中的成員方法, Python 程式透過此一 self 在各成員方法間傳遞物件內容
def index(self):
    outstring = '''
    &lt;!DOCTYPE html&gt; 
    &lt;html&gt;
    &lt;head&gt;
    &lt;meta http-equiv="content-type" content="text/html;charset=utf-8"&gt;
    &lt;/head&gt;
    &lt;body&gt;
    &lt;a href="spur"&gt;spur&lt;/a&gt;&lt;br /&gt;
    &lt;a href="drawspur"&gt;drawspur&lt;/a&gt;&lt;br /&gt;
    &lt;a href="fileuploadform"&gt;上傳檔案&lt;/a&gt;&lt;br /&gt;
    &lt;a href="download_list"&gt;列出上傳檔案&lt;/a&gt;&lt;br /&gt;
    &lt;a href="threegears"&gt;3個齒輪繪圖&lt;/a&gt;&lt;br /&gt;
    &lt;/body&gt;
    &lt;/html&gt;
    '''
    
    return outstring
</t>
<t tx="amd.20151122094835.7">@cherrypy.expose
# N 為齒數, M 為模數, P 為壓力角
def spur(self, N=20, M=5, P=15):
    outstring = '''
&lt;!DOCTYPE html&gt; 
&lt;html&gt;
&lt;head&gt;
&lt;meta http-equiv="content-type" content="text/html;charset=utf-8"&gt;
&lt;!-- 載入 brython.js --&gt;
&lt;script type="text/javascript" src="/static/Brython3.1.3-20150514-095342/brython.js"&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;!-- 啟動 brython() --&gt;
&lt;body onload="brython()"&gt;
    
&lt;form method=POST action=spuraction&gt;
齒數:&lt;input type=text name=N value='''+str(N)+'''&gt;&lt;br /&gt;
模數:&lt;input type=text name=M value = '''+str(M)+'''&gt;&lt;br /&gt;
壓力角:&lt;input type=text name=P value = '''+str(P)+'''&gt;&lt;br /&gt;
&lt;input type=submit value=send&gt;
&lt;/form&gt;
&lt;br /&gt;&lt;a href="index"&gt;index&lt;/a&gt;&lt;br /&gt;
&lt;/body&gt;
&lt;/html&gt;
'''

    return outstring</t>
<t tx="amd.20151122094835.8">@cherrypy.expose
# N 為齒數, M 為模數, P 為壓力角
def spuraction(self, N=20, M=5, P=15):
    output = '''
    &lt;!doctype html&gt;&lt;html&gt;
    &lt;head&gt;
    &lt;meta http-equiv="content-type" content="text/html;charset=utf-8"&gt;
    &lt;title&gt;2015CD Midterm&lt;/title&gt;
    &lt;/head&gt; 
    &lt;body&gt;
    '''
    output += "齒數為"+str(N)+"&lt;br /&gt;"
    output += "模數為"+str(M)+"&lt;br /&gt;"
    output += "壓力角為"+str(P)+"&lt;br /&gt;"
    output +='''&lt;br /&gt;&lt;a href="/spur"&gt;spur&lt;/a&gt;(按下後再輸入)&lt;br /&gt;'''
    output +='''&lt;br /&gt;&lt;a href="index"&gt;index&lt;/a&gt;&lt;br /&gt;
    &lt;/body&gt;
    &lt;/html&gt;
    '''
    
    return output
    
    </t>
<t tx="amd.20151122094835.9">@cherrypy.expose
# N 為齒數, M 為模數, P 為壓力角
def drawspur(self, N=20, M=5, P=15):
    outstring = '''
&lt;!DOCTYPE html&gt; 
&lt;html&gt;
&lt;head&gt;
&lt;meta http-equiv="content-type" content="text/html;charset=utf-8"&gt;
&lt;/head&gt;
&lt;body&gt;
    
&lt;form method=POST action=drawspuraction&gt;
齒數:&lt;input type=text name=N value='''+str(N)+'''&gt;&lt;br /&gt;
模數:&lt;input type=text name=M value = '''+str(M)+'''&gt;&lt;br /&gt;
壓力角:&lt;input type=text name=P value = '''+str(P)+'''&gt;&lt;br /&gt;
&lt;input type=submit value=畫出正齒輪輪廓&gt;
&lt;/form&gt;
&lt;br /&gt;&lt;a href="index"&gt;index&lt;/a&gt;&lt;br /&gt;
&lt;!-- 載入 brython.js --&gt;
&lt;script type="text/javascript" src="/static/Brython3.1.3-20150514-095342/brython.js"&gt;&lt;/script&gt;
&lt;script&gt;
window.onload=function(){
brython();
}
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
'''

    return outstring</t>
<t tx="amd.20151122094920.1">@language python
#coding: utf-8
import math
# 導入數學函式後, 圓周率為 pi
# deg 為角度轉為徑度的轉換因子
deg = math.pi/180.
class Spur(object):
    def __init__(self, ctx):
        self.ctx = ctx

    def create_line(self, x1, y1, x2, y2, width=3, fill="red"):
        self.ctx.beginPath()
        self.ctx.lineWidth = width
        self.ctx.moveTo(x1, y1)
        self.ctx.lineTo(x2, y2)
        self.ctx.strokeStyle = fill
        self.ctx.stroke()
    #
    # 以下分別為正齒輪繪圖與主 tkinter 畫布繪圖
    #
    # 定義一個繪正齒輪的繪圖函式
    # midx 為齒輪圓心 x 座標
    # midy 為齒輪圓心 y 座標
    # rp 為節圓半徑, n 為齒數
    # pa 為壓力角 (deg)
    # rot 為旋轉角 (deg)
    # 注意 n 為 52 齒時繪圖產生錯誤, 因為 base circle 與齒根圓大小未進行判斷, 必須要修正
    def Gear(self, midx, midy, rp, n=20, pa=20, color="black"):
        # 齒輪漸開線分成 15 線段繪製
        imax = 15
        # 在輸入的畫布上繪製直線, 由圓心到節圓 y 軸頂點畫一直線
        self.create_line(midx, midy, midx, midy-rp)
        # 畫出 rp 圓, 畫圓函式尚未定義
        #create_oval(midx-rp, midy-rp, midx+rp, midy+rp, width=2)
        # a 為模數 (代表公制中齒的大小), 模數為節圓直徑(稱為節徑)除以齒數
        # 模數也就是齒冠大小
        a=2*rp/n
        # d 為齒根大小, 為模數的 1.157 或 1.25倍, 這裡採 1.25 倍
        d=2.5*rp/n
        # ra 為齒輪的外圍半徑
        ra=rp+a
        # 畫出 ra 圓, 畫圓函式尚未定義
        #create_oval(midx-ra, midy-ra, midx+ra, midy+ra, width=1)
        # rb 則為齒輪的基圓半徑
        # 基圓為漸開線長齒之基準圓
        rb=rp*math.cos(pa*deg)
        # 畫出 rb 圓 (基圓), 畫圓函式尚未定義
        #create_oval(midx-rb, midy-rb, midx+rb, midy+rb, width=1)
        # rd 為齒根圓半徑
        rd=rp-d
        # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd
        # 畫出 rd 圓 (齒根圓), 畫圓函式尚未定義
        #create_oval(midx-rd, midy-rd, midx+rd, midy+rd, width=1)
        # dr 則為基圓到齒頂圓半徑分成 imax 段後的每段半徑增量大小
        # 將圓弧分成 imax 段來繪製漸開線
        # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd
        if rd&gt;rb:
            dr = (ra-rd)/imax
        else:
            dr=(ra-rb)/imax
        # tan(pa*deg)-pa*deg 為漸開線函數
        sigma=math.pi/(2*n)+math.tan(pa*deg)-pa*deg
        for j in range(n):
            ang=-2.*j*math.pi/n+sigma
            ang2=2.*j*math.pi/n+sigma
            lxd=midx+rd*math.sin(ang2-2.*math.pi/n)
            lyd=midy-rd*math.cos(ang2-2.*math.pi/n)
            for i in range(imax+1):
                # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd
                if rd&gt;rb:
                    r=rd+i*dr
                else:
                    r=rb+i*dr
                theta=math.sqrt((r*r)/(rb*rb)-1.)
                alpha=theta-math.atan(theta)
                xpt=r*math.sin(alpha-ang)
                ypt=r*math.cos(alpha-ang)
                xd=rd*math.sin(-ang)
                yd=rd*math.cos(-ang)
                # i=0 時, 繪線起點由齒根圓上的點, 作為起點
                if(i==0):
                    last_x = midx+xd
                    last_y = midy-yd
                # 由左側齒根圓作為起點, 除第一點 (xd,yd) 齒根圓上的起點外, 其餘的 (xpt,ypt)則為漸開線上的分段點
                self.create_line((midx+xpt),(midy-ypt),(last_x),(last_y),fill=color)
                # 最後一點, 則為齒頂圓
                if(i==imax):
                    lfx=midx+xpt
                    lfy=midy-ypt
                last_x = midx+xpt
                last_y = midy-ypt
            # the line from last end of dedendum point to the recent
            # end of dedendum point
            # lxd 為齒根圓上的左側 x 座標, lyd 則為 y 座標
            # 下列為齒根圓上用來近似圓弧的直線
            self.create_line((lxd),(lyd),(midx+xd),(midy-yd),fill=color)
            for i in range(imax+1):
                # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd
                if rd&gt;rb:
                    r=rd+i*dr
                else:
                    r=rb+i*dr
                theta=math.sqrt((r*r)/(rb*rb)-1.)
                alpha=theta-math.atan(theta)
                xpt=r*math.sin(ang2-alpha)
                ypt=r*math.cos(ang2-alpha)
                xd=rd*math.sin(ang2)
                yd=rd*math.cos(ang2)
                # i=0 時, 繪線起點由齒根圓上的點, 作為起點
                if(i==0):
                    last_x = midx+xd
                    last_y = midy-yd
                # 由右側齒根圓作為起點, 除第一點 (xd,yd) 齒根圓上的起點外, 其餘的 (xpt,ypt)則為漸開線上的分段點
                self.create_line((midx+xpt),(midy-ypt),(last_x),(last_y),fill=color)
                # 最後一點, 則為齒頂圓
                if(i==imax):
                    rfx=midx+xpt
                    rfy=midy-ypt
                last_x = midx+xpt
                last_y = midy-ypt
            # lfx 為齒頂圓上的左側 x 座標, lfy 則為 y 座標
            # 下列為齒頂圓上用來近似圓弧的直線
            self.create_line(lfx,lfy,rfx,rfy,fill=color)
</t>
<t tx="amd.20151122095255.1">@language python
 
import cherrypy
 
# 這是 MAN 類別的定義
'''
# 在 application 中導入子模組
import programs.cdag30.man as cdag30_man
# 加入 cdag30 模組下的 man.py 且以子模組 man 對應其 MAN() 類別
root.cdag30.man = cdag30_man.MAN()
 
# 完成設定後, 可以利用
/cdag30/man/assembly
# 呼叫 man.py 中 MAN 類別的 assembly 方法
'''
class MAN(object):
    # 各組利用 index 引導隨後的程式執行
    @cherrypy.expose
    def index(self, *args, **kwargs):
        outstring = '''
這是 2014CDA 協同專案下的 cdag30 模組下的 MAN 類別.&lt;br /&gt;&lt;br /&gt;
&lt;!-- 這裡採用相對連結, 而非網址的絕對連結 (這一段為 html 註解) --&gt;
&lt;a href="assembly"&gt;執行  MAN 類別中的 assembly 方法&lt;/a&gt;&lt;br /&gt;&lt;br /&gt;
請確定下列零件於 V:/home/lego/man 目錄中, 且開啟空白 Creo 組立檔案.&lt;br /&gt;
&lt;a href="/static/lego_man.7z"&gt;lego_man.7z&lt;/a&gt;(滑鼠右鍵存成 .7z 檔案)&lt;br /&gt;
'''
        return outstring
 
    @cherrypy.expose
    def assembly(self, *args, **kwargs):
        outstring = '''
&lt;!DOCTYPE html&gt; 
&lt;html&gt;
&lt;head&gt;
&lt;meta http-equiv="content-type" content="text/html;charset=utf-8"&gt;
&lt;script type="text/javascript" src="/static/weblink/examples/jscript/pfcUtils.js"&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;/script&gt;&lt;script language="JavaScript"&gt;
/*設計一個零件組立函式*/
// featID 為組立件第一個組立零件的編號
// inc 則為 part1 的組立順序編號, 第一個入組立檔編號為 featID+0
// part2 為外加的零件名稱
function axis_plane_assembly(session, assembly, transf, featID, inc, part2, axis1, plane1, axis2, plane2){
var descr = pfcCreate("pfcModelDescriptor").CreateFromFileName ("v:/home/lego/man/"+part2);
var componentModel = session.GetModelFromDescr(descr);
var componentModel = session.RetrieveModel(descr);
if (componentModel != void null)
{
    var asmcomp = assembly.AssembleComponent (componentModel, transf);
}
var ids = pfcCreate("intseq");
ids.Append(featID+inc);
var subPath = pfcCreate("MpfcAssembly").CreateComponentPath(assembly, ids);
subassembly = subPath.Leaf;
var asmDatums = new Array(axis1, plane1);
var compDatums = new Array(axis2, plane2);
var relation = new Array (pfcCreate("pfcComponentConstraintType").ASM_CONSTRAINT_ALIGN, pfcCreate("pfcComponentConstraintType").ASM_CONSTRAINT_MATE);
var relationItem = new Array(pfcCreate("pfcModelItemType").ITEM_AXIS, pfcCreate("pfcModelItemType").ITEM_SURFACE);
var constrs = pfcCreate("pfcComponentConstraints");
    for (var i = 0; i &lt; 2; i++)
    {
        var asmItem = subassembly.GetItemByName (relationItem[i], asmDatums [i]);
        if (asmItem == void null)
        {
            interactFlag = true;
            continue;
        }
        var compItem = componentModel.GetItemByName (relationItem[i], compDatums [i]);
        if (compItem == void null)
        {
            interactFlag = true;
            continue;
        }
        var MpfcSelect = pfcCreate ("MpfcSelect");
        var asmSel = MpfcSelect.CreateModelItemSelection (asmItem, subPath);
        var compSel = MpfcSelect.CreateModelItemSelection (compItem, void null);
        var constr = pfcCreate("pfcComponentConstraint").Create (relation[i]);
        constr.AssemblyReference  = asmSel;
        constr.ComponentReference = compSel;
        constr.Attributes = pfcCreate("pfcConstraintAttributes").Create (true, false);
        constrs.Append(constr);
    }
asmcomp.SetConstraints(constrs, void null);
}
// 以上為 axis_plane_assembly() 函式
//
function three_plane_assembly(session, assembly, transf, featID, inc, part2, plane1, plane2, plane3, plane4, plane5, plane6){
var descr = pfcCreate("pfcModelDescriptor").CreateFromFileName ("v:/home/lego/man/"+part2);
var componentModel = session.GetModelFromDescr(descr);
var componentModel = session.RetrieveModel(descr);
if (componentModel != void null)
{
    var asmcomp = assembly.AssembleComponent (componentModel, transf);
}
var ids = pfcCreate("intseq");
ids.Append(featID+inc);
var subPath = pfcCreate("MpfcAssembly").CreateComponentPath(assembly, ids);
subassembly = subPath.Leaf;
var constrs = pfcCreate("pfcComponentConstraints");
var asmDatums = new Array(plane1, plane2, plane3);
var compDatums = new Array(plane4, plane5, plane6);
var MpfcSelect = pfcCreate("MpfcSelect");
for (var i = 0; i &lt; 3; i++)
{
    var asmItem = subassembly.GetItemByName(pfcCreate("pfcModelItemType").ITEM_SURFACE, asmDatums[i]);
     
    if (asmItem == void null)
    {
        interactFlag = true;
        continue;
    }
    var compItem = componentModel.GetItemByName(pfcCreate("pfcModelItemType").ITEM_SURFACE, compDatums[i]);
    if (compItem == void null)
    {
        interactFlag = true;
        continue;
    }
    var asmSel = MpfcSelect.CreateModelItemSelection(asmItem, subPath);
    var compSel = MpfcSelect.CreateModelItemSelection(compItem, void null);
    var constr = pfcCreate("pfcComponentConstraint").Create(pfcCreate("pfcComponentConstraintType").ASM_CONSTRAINT_MATE);
    constr.AssemblyReference = asmSel;
    constr.ComponentReference = compSel;
    constr.Attributes = pfcCreate("pfcConstraintAttributes").Create (false, false);
    constrs.Append(constr);
}
asmcomp.SetConstraints(constrs, void null);
}
// 以上為 three_plane_assembly() 函式
//
// 假如 Creo 所在的操作系統不是 Windows 環境
if (!pfcIsWindows())
// 則啟動對應的 UniversalXPConnect 執行權限 (等同 Windows 下的 ActiveX)
netscape.security.PrivilegeManager.enablePrivilege("UniversalXPConnect");
// pfcGetProESession() 是位於 pfcUtils.js 中的函式, 確定此 JavaScript 是在嵌入式瀏覽器中執行
var session = pfcGetProESession();
// 設定 config option, 不要使用元件組立流程中內建的假設約束條件
session.SetConfigOption("comp_placement_assumptions","no");
// 建立擺放零件的位置矩陣, Pro/Web.Link 中的變數無法直接建立, 必須透過 pfcCreate() 建立
var identityMatrix = pfcCreate("pfcMatrix3D");
// 建立 identity 位置矩陣
for (var x = 0; x &lt; 4; x++)
for (var y = 0; y &lt; 4; y++)
{
    if (x == y)
        identityMatrix.Set(x, y, 1.0);
    else
        identityMatrix.Set(x, y, 0.0);
}
// 利用 identityMatrix 建立 transf 座標轉換矩陣
var transf = pfcCreate("pfcTransform3D").Create(identityMatrix);
// 取得目前的工作目錄
var currentDir = session.getCurrentDirectory();
// 以目前已開檔的空白組立檔案, 作為 model
var model = session.CurrentModel;
// 查驗有無 model, 或 model 類別是否為組立件, 若不符合條件則丟出錯誤訊息
if (model == void null || model.Type != pfcCreate("pfcModelType").MDL_ASSEMBLY)
throw new Error (0, "Current model is not an assembly.");
// 將此模型設為組立物件
var assembly = model;
 
/**---------------------- LEGO_BODY--------------------**/
// 設定零件的 descriptor 物件變數
var descr = pfcCreate("pfcModelDescriptor").CreateFromFileName("v:/home/lego/man/LEGO_BODY.prt");
// 若零件在 session 則直接取用
var componentModel = session.GetModelFromDescr(descr);
// 若零件不在 session 則從工作目錄中載入 session
var componentModel = session.RetrieveModel(descr);
// 若零件已經在 session 中則放入組立檔中
if (componentModel != void null)
{
    // 注意這個 asmcomp 即為設定約束條件的本體
    // asmcomp 為特徵物件, 直接將零件, 以 transf 座標轉換矩陣方位放入組立檔案中
    var asmcomp = assembly.AssembleComponent(componentModel, transf);
}
 
// 建立約束條件變數
var constrs = pfcCreate("pfcComponentConstraints");
// 設定組立檔中的三個定位面, 注意內定名稱與 Pro/E WF 中的 ASM_D_FRONT 不同, 而是 ASM_FRONT, 可在組立件-&gt;info-&gt;model 中查詢定位面名稱
// 組立檔案中的 Datum 名稱也可以利用 View-&gt;plane tag display 查詢名稱
// 建立組立參考面所組成的陣列
var asmDatums = new Array("ASM_FRONT", "ASM_TOP", "ASM_RIGHT");
// 設定零件檔中的三個定位面, 名稱與 Pro/E WF 中相同
var compDatums = new Array("FRONT", "TOP", "RIGHT");
// 建立 ids 變數, intseq 為 sequence of integers 為資料類別, 使用者可以經由整數索引擷取此資料類別的元件, 第一個索引為 0
       // intseq 等同 Python 的數列資料?
var ids = pfcCreate("intseq");
// 利用 assembly 物件模型, 建立路徑變數
var path = pfcCreate("MpfcAssembly").CreateComponentPath(assembly, ids);
// 採用互動式設定相關的變數, MpfcSelect 為 Module level class 中的一種
var MpfcSelect = pfcCreate("MpfcSelect");
// 利用迴圈分別約束組立與零件檔中的三個定位平面
for (var i = 0; i &lt; 3; i++)
{
// 設定組立參考面, 也就是 "ASM_FRONT", "ASM_TOP", "ASM_RIGHT" 等三個 datum planes
var asmItem = assembly.GetItemByName (pfcCreate("pfcModelItemType").ITEM_SURFACE, asmDatums[i]);
// 若無對應的組立參考面, 則啟用互動式平面選擇表單 flag
if (asmItem == void null)
{
    interactFlag = true;
    continue;
}
// 設定零件參考面, 也就是 "FRONT", "TOP", "RIGHT" 等三個 datum planes
var compItem = componentModel.GetItemByName (pfcCreate ("pfcModelItemType").ITEM_SURFACE, compDatums[i]);
// 若無對應的零件參考面, 則啟用互動式平面選擇表單 flag
if (compItem == void null)
{
    interactFlag = true;
    continue;
}
        // 因為 asmItem 為組立件中的定位特徵, 必須透過 path 才能取得
var asmSel = MpfcSelect.CreateModelItemSelection(asmItem, path);
        // 而 compItem 則為零件, 沒有 path 路徑, 因此第二變數為 null
var compSel = MpfcSelect.CreateModelItemSelection(compItem, void null);
        // 利用 ASM_CONSTRAINT_ALIGN 對齊組立約束建立約束變數
var constr = pfcCreate("pfcComponentConstraint").Create (pfcCreate ("pfcComponentConstraintType").ASM_CONSTRAINT_ALIGN);
        // 設定約束條件的組立參考與元件參考選擇
constr.AssemblyReference = asmSel;
constr.ComponentReference = compSel;
       // 第一個變數為強制變數, 第二個為忽略變數
       // 強制變數為 false, 表示不強制約束, 只有透過點與線對齊時需設為 true
       // 忽略變數為 false, 約束條件在更新模型時是否忽略, 設為 false 表示不忽略
       // 通常在組立 closed chain 機構時,  忽略變數必須設為 true, 才能完成約束
       // 因為三個面絕對約束, 因此輸入變數為 false, false
constr.Attributes = pfcCreate("pfcConstraintAttributes").Create (false, false);
// 將互動選擇相關資料, 附加在程式約束變數之後
constrs.Append(constr);
}
 
// 設定組立約束條件
asmcomp.SetConstraints (constrs, void null);
/**---------------------- LEGO_ARM_RT 右手上臂--------------------**/
var descr = pfcCreate ("pfcModelDescriptor").CreateFromFileName ("v:/home/lego/man/LEGO_ARM_RT.prt");
var componentModel = session.GetModelFromDescr(descr);
var componentModel = session.RetrieveModel(descr);
if (componentModel != void null)
{
        // 注意這個 asmcomp 即為設定約束條件的本體
        // asmcomp 為特徵物件,直接將零件, 以 transf 座標轉換放入組立檔案中
var asmcomp = assembly.AssembleComponent (componentModel, transf);
}
// 取得 assembly 項下的元件 id, 因為只有一個零件, 採用 index 0 取出其 featID
var components = assembly.ListFeaturesByType(true, pfcCreate ("pfcFeatureType").FEATTYPE_COMPONENT);
// 此一 featID 為組立件中的第一個零件編號, 也就是樂高人偶的 body
var featID = components.Item(0).Id;
 
ids.Append(featID);
// 在 assembly 模型中建立子零件所對應的路徑
var subPath = pfcCreate("MpfcAssembly").CreateComponentPath(assembly, ids);
subassembly = subPath.Leaf;
// 以下針對 body 的 A_13 軸與 DTM1 基準面及右臂的  A_4 軸線與 DTM1 進行對齊與面接約束
var asmDatums = new Array("A_13", "DTM1");
var compDatums = new Array("A_4", "DTM1");
// 組立的關係變數為對齊與面接
var relation = new Array (pfcCreate ("pfcComponentConstraintType").ASM_CONSTRAINT_ALIGN, pfcCreate ("pfcComponentConstraintType").ASM_CONSTRAINT_MATE);
// 組立元件則為軸與平面
var relationItem = new Array(pfcCreate("pfcModelItemType").ITEM_AXIS, pfcCreate("pfcModelItemType").ITEM_SURFACE);
// 建立約束條件變數, 軸採對齊而基準面則以面接進行約束
var constrs = pfcCreate ("pfcComponentConstraints");
for (var i = 0; i &lt; 2; i++)
{
                  // 設定組立參考面, asmItem 為 model item
    var asmItem = subassembly.GetItemByName (relationItem[i], asmDatums [i]);
                  // 若無對應的組立參考面, 則啟用互動式平面選擇表單 flag
    if (asmItem == void null)
    {
        interactFlag = true;
        continue;
    }
                  // 設定零件參考面, compItem 為 model item
    var compItem = componentModel.GetItemByName (relationItem[i], compDatums[i]);
    if (compItem == void null)
    {
        interactFlag = true;
        continue;
    }
                  // 採用互動式設定相關的變數
    var MpfcSelect = pfcCreate ("MpfcSelect");
    var asmSel = MpfcSelect.CreateModelItemSelection (asmItem, subPath);
    var compSel = MpfcSelect.CreateModelItemSelection (compItem, void null);
    var constr = pfcCreate("pfcComponentConstraint").Create (relation[i]);
    constr.AssemblyReference  = asmSel;
    constr.ComponentReference = compSel;
                  // 因為透過軸線對齊, 第一 force 變數需設為 true
    constr.Attributes = pfcCreate("pfcConstraintAttributes").Create (true, false);
                  // 將互動選擇相關資料, 附加在程式約束變數之後
    constrs.Append(constr);
}
// 設定組立約束條件, 以 asmcomp 特徵進行約束條件設定
// 請注意, 第二個變數必須為 void null 表示零件對零件進行約束, 若為 subPath, 則零件會與原始零件的平面進行約束
asmcomp.SetConstraints (constrs, void null);
/**---------------------- LEGO_ARM_LT 左手上臂--------------------**/
var descr = pfcCreate ("pfcModelDescriptor").CreateFromFileName ("v:/home/lego/man/LEGO_ARM_LT.prt");
var componentModel = session.GetModelFromDescr(descr);
var componentModel = session.RetrieveModel(descr);
if (componentModel != void null)
{
        // 注意這個 asmcomp 即為設定約束條件的本體
        // asmcomp 為特徵物件,直接將零件, 以 transf 座標轉換放入組立檔案中
var asmcomp = assembly.AssembleComponent(componentModel, transf);
}
// 取得 assembly 項下的元件 id, 因為只有一個零件, 採用 index 0 取出其 featID
var components = assembly.ListFeaturesByType(true, pfcCreate ("pfcFeatureType").FEATTYPE_COMPONENT);
var ids = pfcCreate ("intseq");
// 因為左臂也是與 body 進行約束條件組立,  因此取 body 的 featID
// 至此右臂 id 應該是 featID+1, 而左臂則是 featID+2
ids.Append(featID);
// 在 assembly 模型中建立子零件所對應的路徑
var subPath = pfcCreate("MpfcAssembly").CreateComponentPath(assembly, ids);
subassembly = subPath.Leaf;
var asmDatums = new Array("A_9", "DTM2");
var compDatums = new Array("A_4", "DTM1");
var relation = new Array (pfcCreate ("pfcComponentConstraintType").ASM_CONSTRAINT_ALIGN, pfcCreate ("pfcComponentConstraintType").ASM_CONSTRAINT_MATE);
var relationItem = new Array(pfcCreate("pfcModelItemType").ITEM_AXIS, pfcCreate("pfcModelItemType").ITEM_SURFACE);
// 建立約束條件變數
var constrs = pfcCreate ("pfcComponentConstraints");
for (var i = 0; i &lt; 2; i++)
{
                  // 設定組立參考面, asmItem 為 model item
    var asmItem = subassembly.GetItemByName (relationItem[i], asmDatums [i]);
                  // 若無對應的組立參考面, 則啟用互動式平面選擇表單 flag
    if (asmItem == void null)
    {
        interactFlag = true;
        continue;
    }
                  // 設定零件參考面, compItem 為 model item
    var compItem = componentModel.GetItemByName (relationItem[i], compDatums [i]);
    if (compItem == void null)
    {
        interactFlag = true;
        continue;
    }
                  // 採用互動式設定相關的變數
    var MpfcSelect = pfcCreate ("MpfcSelect");
    var asmSel = MpfcSelect.CreateModelItemSelection (asmItem, subPath);
    var compSel = MpfcSelect.CreateModelItemSelection (compItem, void null);
    var constr = pfcCreate("pfcComponentConstraint").Create (relation[i]);
    constr.AssemblyReference  = asmSel;
    constr.ComponentReference = compSel;
    constr.Attributes = pfcCreate("pfcConstraintAttributes").Create (true, false);
                  // 將互動選擇相關資料, 附加在程式約束變數之後
    constrs.Append(constr);
}
// 設定組立約束條件, 以 asmcomp 特徵進行約束條件設定
// 請注意, 第二個變數必須為 void null 表示零件對零件進行約束, 若為 subPath, 則零件會與原始零件的平面進行約束
asmcomp.SetConstraints (constrs, void null);
/**---------------------- LEGO_HAND 右手手腕--------------------**/
// 右手臂 LEGO_ARM_RT.prt 基準  A_2, DTM2
// 右手腕 LEGO_HAND.prt 基準 A_1, DTM3
var descr = pfcCreate ("pfcModelDescriptor").CreateFromFileName ("v:/home/lego/man/LEGO_HAND.prt");
var componentModel = session.GetModelFromDescr(descr);
var componentModel = session.RetrieveModel(descr);
if (componentModel != void null)
{
        // 注意這個 asmcomp 即為設定約束條件的本體
        // asmcomp 為特徵物件,直接將零件, 以 transf 座標轉換放入組立檔案中
var asmcomp = assembly.AssembleComponent (componentModel, transf);
}
// 取得 assembly 項下的元件 id, 因為只有一個零件, 採用 index 0 取出其 featID
var components = assembly.ListFeaturesByType(true, pfcCreate ("pfcFeatureType").FEATTYPE_COMPONENT);
var ids = pfcCreate ("intseq");
 
// 組立件中 LEGO_BODY.prt 編號為 featID
// LEGO_ARM_RT.prt 則是組立件第二個置入的零件,  編號為 featID+1
ids.Append(featID+1);
// 在 assembly 模型中, 根據子零件的編號, 建立子零件所對應的路徑
var subPath = pfcCreate("MpfcAssembly").CreateComponentPath(assembly, ids);
subassembly = subPath.Leaf;
// 以下針對 LEGO_ARM_RT 的 A_2 軸與 DTM2 基準面及 HAND 的  A_1 軸線與 DTM3 進行對齊與面接約束
var asmDatums = new Array("A_2", "DTM2");
var compDatums = new Array("A_1", "DTM3");
// 組立的關係變數為對齊與面接
var relation = new Array (pfcCreate ("pfcComponentConstraintType").ASM_CONSTRAINT_ALIGN, pfcCreate ("pfcComponentConstraintType").ASM_CONSTRAINT_MATE);
// 組立元件則為軸與平面
var relationItem = new Array(pfcCreate("pfcModelItemType").ITEM_AXIS, pfcCreate("pfcModelItemType").ITEM_SURFACE);
// 建立約束條件變數, 軸採對齊而基準面則以面接進行約束
var constrs = pfcCreate ("pfcComponentConstraints");
for (var i = 0; i &lt; 2; i++)
{
                  // 設定組立參考面, asmItem 為 model item
    var asmItem = subassembly.GetItemByName (relationItem[i], asmDatums [i]);
                  // 若無對應的組立參考面, 則啟用互動式平面選擇表單 flag
    if (asmItem == void null)
    {
        interactFlag = true;
        continue;
    }
                  // 設定零件參考面, compItem 為 model item
    var compItem = componentModel.GetItemByName (relationItem[i], compDatums [i]);
    if (compItem == void null)
    {
        interactFlag = true;
        continue;
    }
                  // 採用互動式設定相關的變數
    var MpfcSelect = pfcCreate("MpfcSelect");
    var asmSel = MpfcSelect.CreateModelItemSelection(asmItem, subPath);
    var compSel = MpfcSelect.CreateModelItemSelection (compItem, void null);
    var constr = pfcCreate("pfcComponentConstraint").Create (relation[i]);
    constr.AssemblyReference  = asmSel;
    constr.ComponentReference = compSel;
                  // 因為透過軸線對齊, 第一 force 變數需設為 true
    constr.Attributes = pfcCreate("pfcConstraintAttributes").Create (true, false);
                  // 將互動選擇相關資料, 附加在程式約束變數之後
    constrs.Append(constr);
}
// 設定組立約束條件, 以 asmcomp 特徵進行約束條件設定
// 請注意, 第二個變數必須為 void null 表示零件對零件進行約束, 若為 subPath, 則零件會與原始零件的平面進行約束
asmcomp.SetConstraints (constrs, void null);
// 利用函式呼叫組立左手 HAND
axis_plane_assembly(session, assembly, transf, featID, 2, 
                              "LEGO_HAND.prt", "A_2", "DTM2", "A_1", "DTM3");
// 利用函式呼叫組立人偶頭部 HEAD
// BODY id 為 featID+0, 以 A_2 及  DTM3 約束
// HEAD 則直接呼叫檔案名稱, 以 A_2, DTM2 約束
axis_plane_assembly(session, assembly, transf, featID, 0, 
                              "LEGO_HEAD.prt", "A_2", "DTM3", "A_2", "DTM2");
// Body 與 WAIST 採三個平面約束組立
// Body 組立面為 DTM4, DTM5, DTM6
// WAIST 組立面為 DTM1, DTM2, DTM3
three_plane_assembly(session, assembly, transf, featID, 0, "LEGO_WAIST.prt", "DTM4", "DTM5", "DTM6", "DTM1", "DTM2", "DTM3"); 
// 右腳
axis_plane_assembly(session, assembly, transf, featID, 6, 
                              "LEGO_LEG_RT.prt", "A_8", "DTM4", "A_10", "DTM1");
// 左腳
axis_plane_assembly(session, assembly, transf, featID, 6, 
                              "LEGO_LEG_LT.prt", "A_8", "DTM5", "A_10", "DTM1");
// 紅帽
axis_plane_assembly(session, assembly, transf, featID, 5, 
                              "LEGO_HAT.prt", "A_2", "TOP", "A_2", "FRONT");
// regenerate 並且 repaint 組立檔案
assembly.Regenerate (void null);
session.GetModelWindow (assembly).Repaint();    
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
'''
        return outstring</t>
<t tx="amd.20151122095546.1">@language python
 
import cherrypy
 
# 這是 MAN 類別的定義
'''
# 在 application 中導入子模組
import programs.cdag30.man as cdag30_man
# 加入 cdag30 模組下的 man.py 且以子模組 man 對應其 MAN() 類別
root.cdag30.man = cdag30_man.MAN()
 
# 完成設定後, 可以利用
/cdag30/man/assembly
# 呼叫 man.py 中 MAN 類別的 assembly 方法
'''
class MAN(object):
    # 各組利用 index 引導隨後的程式執行
    @cherrypy.expose
    def index(self, *args, **kwargs):
        outstring = '''
這是 2014CDA 協同專案下的 cdag30 模組下的 MAN 類別.&lt;br /&gt;&lt;br /&gt;
&lt;!-- 這裡採用相對連結, 而非網址的絕對連結 (這一段為 html 註解) --&gt;
&lt;a href="assembly"&gt;執行  MAN 類別中的 assembly 方法&lt;/a&gt;&lt;br /&gt;&lt;br /&gt;
請確定下列零件於 V:/home/lego/man 目錄中, 且開啟空白 Creo 組立檔案.&lt;br /&gt;
&lt;a href="/static/lego_man.7z"&gt;lego_man.7z&lt;/a&gt;(滑鼠右鍵存成 .7z 檔案)&lt;br /&gt;
'''
        return outstring
 
    @cherrypy.expose
    def assembly(self, *args, **kwargs):
        outstring = '''
&lt;!DOCTYPE html&gt; 
&lt;html&gt;
&lt;head&gt;
&lt;meta http-equiv="content-type" content="text/html;charset=utf-8"&gt;
&lt;script type="text/javascript" src="/static/weblink/examples/jscript/pfcUtils.js"&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;/script&gt;&lt;script language="JavaScript"&gt;
/*man2.py 完全利用函式呼叫進行組立*/
/*設計一個零件組立函式*/
// featID 為組立件第一個組立零件的編號
// inc 則為 part1 的組立順序編號, 第一個入組立檔編號為 featID+0
// part2 為外加的零件名稱
////////////////////////////////////////////////
// axis_plane_assembly 組立函式
////////////////////////////////////////////////
function axis_plane_assembly(session, assembly, transf, featID, inc, part2, axis1, plane1, axis2, plane2){
var descr = pfcCreate("pfcModelDescriptor").CreateFromFileName ("v:/home/lego/man/"+part2);
var componentModel = session.GetModelFromDescr(descr);
var componentModel = session.RetrieveModel(descr);
if (componentModel != void null)
{
    var asmcomp = assembly.AssembleComponent (componentModel, transf);
}
var ids = pfcCreate("intseq");
ids.Append(featID+inc);
var subPath = pfcCreate("MpfcAssembly").CreateComponentPath(assembly, ids);
subassembly = subPath.Leaf;
var asmDatums = new Array(axis1, plane1);
var compDatums = new Array(axis2, plane2);
var relation = new Array (pfcCreate("pfcComponentConstraintType").ASM_CONSTRAINT_ALIGN, pfcCreate("pfcComponentConstraintType").ASM_CONSTRAINT_MATE);
var relationItem = new Array(pfcCreate("pfcModelItemType").ITEM_AXIS, pfcCreate("pfcModelItemType").ITEM_SURFACE);
var constrs = pfcCreate("pfcComponentConstraints");
    for (var i = 0; i &lt; 2; i++)
    {
        var asmItem = subassembly.GetItemByName (relationItem[i], asmDatums [i]);
        if (asmItem == void null)
        {
            interactFlag = true;
            continue;
        }
        var compItem = componentModel.GetItemByName (relationItem[i], compDatums [i]);
        if (compItem == void null)
        {
            interactFlag = true;
            continue;
        }
        var MpfcSelect = pfcCreate ("MpfcSelect");
        var asmSel = MpfcSelect.CreateModelItemSelection (asmItem, subPath);
        var compSel = MpfcSelect.CreateModelItemSelection (compItem, void null);
        var constr = pfcCreate("pfcComponentConstraint").Create (relation[i]);
        constr.AssemblyReference  = asmSel;
        constr.ComponentReference = compSel;
        constr.Attributes = pfcCreate("pfcConstraintAttributes").Create (true, false);
        constrs.Append(constr);
    }
asmcomp.SetConstraints(constrs, void null);
}
// 以上為 axis_plane_assembly() 函式
///////////////////////////////////////////////////////////////////////////////////////////////////////////
// three_plane_assembly 採 align 組立, 若 featID 為 0 表示為空組立檔案
///////////////////////////////////////////////////////////////////////////////////////////////////////////
function three_plane_assembly(session, assembly, transf, featID, inc, part2, plane1, plane2, plane3, plane4, plane5, plane6){
var descr = pfcCreate("pfcModelDescriptor").CreateFromFileName ("v:/home/lego/man/"+part2);
var componentModel = session.GetModelFromDescr(descr);
var componentModel = session.RetrieveModel(descr);
if (componentModel != void null)
{
    var asmcomp = assembly.AssembleComponent (componentModel, transf);
}
var ids = pfcCreate("intseq");
// 若 featID 為 0 表示為空組立檔案
if (featID != 0){
    ids.Append(featID+inc);
    var subPath = pfcCreate("MpfcAssembly").CreateComponentPath(assembly, ids);
    subassembly = subPath.Leaf;
    }else{
    var subPath = pfcCreate("MpfcAssembly").CreateComponentPath(assembly, ids);
    subassembly = assembly;
    // 設法取得第一個組立零件 first_featID
    // 取得 assembly 項下的元件 id, 因為只有一個零件, 採用 index 0 取出其 featID
    var components = assembly.ListFeaturesByType(true, pfcCreate ("pfcFeatureType").FEATTYPE_COMPONENT);
    // 此一 featID 為組立件中的第一個零件編號, 也就是樂高人偶的 body
    var first_featID = components.Item(0).Id;
    }
var constrs = pfcCreate("pfcComponentConstraints");
var asmDatums = new Array(plane1, plane2, plane3);
var compDatums = new Array(plane4, plane5, plane6);
var MpfcSelect = pfcCreate("MpfcSelect");
for (var i = 0; i &lt; 3; i++)
{
    var asmItem = subassembly.GetItemByName(pfcCreate("pfcModelItemType").ITEM_SURFACE, asmDatums[i]);
     
    if (asmItem == void null)
    {
        interactFlag = true;
        continue;
    }
    var compItem = componentModel.GetItemByName(pfcCreate("pfcModelItemType").ITEM_SURFACE, compDatums[i]);
    if (compItem == void null)
    {
        interactFlag = true;
        continue;
    }
    var asmSel = MpfcSelect.CreateModelItemSelection(asmItem, subPath);
    var compSel = MpfcSelect.CreateModelItemSelection(compItem, void null);
    var constr = pfcCreate("pfcComponentConstraint").Create(pfcCreate("pfcComponentConstraintType").ASM_CONSTRAINT_ALIGN);
    constr.AssemblyReference = asmSel;
    constr.ComponentReference = compSel;
    constr.Attributes = pfcCreate("pfcConstraintAttributes").Create (false, false);
    constrs.Append(constr);
}
asmcomp.SetConstraints(constrs, void null);
// 若 featID = 0 則傳回 first_featID
if (featID == 0)
    return first_featID;
}
// 以上為 three_plane_assembly() 函式
///////////////////////////////////////////////////////////////////////////////////////////////////////////
// three_plane_assembly2 採 mate 組立, 若 featID 為 0 表示為空組立檔案
///////////////////////////////////////////////////////////////////////////////////////////////////////////
function three_plane_assembly2(session, assembly, transf, featID, inc, part2, plane1, plane2, plane3, plane4, plane5, plane6){
var descr = pfcCreate("pfcModelDescriptor").CreateFromFileName ("v:/home/lego/man/"+part2);
var componentModel = session.GetModelFromDescr(descr);
var componentModel = session.RetrieveModel(descr);
if (componentModel != void null)
{
    var asmcomp = assembly.AssembleComponent (componentModel, transf);
}
var ids = pfcCreate("intseq");
// 若 featID 為 0 表示為空組立檔案
if (featID != 0){
    ids.Append(featID+inc);
    var subPath = pfcCreate("MpfcAssembly").CreateComponentPath(assembly, ids);
    subassembly = subPath.Leaf;
    }else{
    var subPath = pfcCreate("MpfcAssembly").CreateComponentPath(assembly, ids);
    subassembly = assembly;
    // 設法取得第一個組立零件 first_featID
    // 取得 assembly 項下的元件 id, 因為只有一個零件, 採用 index 0 取出其 featID
    var components = assembly.ListFeaturesByType(true, pfcCreate ("pfcFeatureType").FEATTYPE_COMPONENT);
    // 此一 featID 為組立件中的第一個零件編號, 也就是樂高人偶的 body
    var first_featID = components.Item(0).Id;
    }
var constrs = pfcCreate("pfcComponentConstraints");
var asmDatums = new Array(plane1, plane2, plane3);
var compDatums = new Array(plane4, plane5, plane6);
var MpfcSelect = pfcCreate("MpfcSelect");
for (var i = 0; i &lt; 3; i++)
{
    var asmItem = subassembly.GetItemByName(pfcCreate("pfcModelItemType").ITEM_SURFACE, asmDatums[i]);
     
    if (asmItem == void null)
    {
        interactFlag = true;
        continue;
    }
    var compItem = componentModel.GetItemByName(pfcCreate("pfcModelItemType").ITEM_SURFACE, compDatums[i]);
    if (compItem == void null)
    {
        interactFlag = true;
        continue;
    }
    var asmSel = MpfcSelect.CreateModelItemSelection(asmItem, subPath);
    var compSel = MpfcSelect.CreateModelItemSelection(compItem, void null);
    var constr = pfcCreate("pfcComponentConstraint").Create(pfcCreate("pfcComponentConstraintType").ASM_CONSTRAINT_MATE);
    constr.AssemblyReference = asmSel;
    constr.ComponentReference = compSel;
    constr.Attributes = pfcCreate("pfcConstraintAttributes").Create (false, false);
    constrs.Append(constr);
}
asmcomp.SetConstraints(constrs, void null);
// 若 featID = 0 則傳回 first_featID
if (featID == 0)
    return first_featID;
}
// 以上為 three_plane_assembly2() 函式, 主要採三面 MATE 組立
//
// 假如 Creo 所在的操作系統不是 Windows 環境
if (!pfcIsWindows())
// 則啟動對應的 UniversalXPConnect 執行權限 (等同 Windows 下的 ActiveX)
netscape.security.PrivilegeManager.enablePrivilege("UniversalXPConnect");
// pfcGetProESession() 是位於 pfcUtils.js 中的函式, 確定此 JavaScript 是在嵌入式瀏覽器中執行
var session = pfcGetProESession();
// 設定 config option, 不要使用元件組立流程中內建的假設約束條件
session.SetConfigOption("comp_placement_assumptions","no");
// 建立擺放零件的位置矩陣, Pro/Web.Link 中的變數無法直接建立, 必須透過 pfcCreate() 建立
var identityMatrix = pfcCreate("pfcMatrix3D");
// 建立 identity 位置矩陣
for (var x = 0; x &lt; 4; x++)
for (var y = 0; y &lt; 4; y++)
{
    if (x == y)
        identityMatrix.Set(x, y, 1.0);
    else
        identityMatrix.Set(x, y, 0.0);
}
// 利用 identityMatrix 建立 transf 座標轉換矩陣
var transf = pfcCreate("pfcTransform3D").Create(identityMatrix);
// 取得目前的工作目錄
var currentDir = session.getCurrentDirectory();
// 以目前已開檔的空白組立檔案, 作為 model
var model = session.CurrentModel;
// 查驗有無 model, 或 model 類別是否為組立件, 若不符合條件則丟出錯誤訊息
if (model == void null || model.Type != pfcCreate("pfcModelType").MDL_ASSEMBLY)
throw new Error (0, "Current model is not an assembly.");
// 將此模型設為組立物件
var assembly = model;
 
/////////////////////////////////////////////////////////////////
// 開始執行組立, 全部採函式呼叫組立
/////////////////////////////////////////////////////////////////
 
// Body 與空組立檔案採三個平面約束組立
// 空組立面為 ASM_TOP, ASM_FRONT, ASM_RIGHT
// Body 組立面為 TOP, FRONT, RIGHT
// 若 featID=0 表示為空組立檔案, 而且函式會傳回第一個組立件的 featID
var featID = three_plane_assembly(session, assembly, transf, 0, 0, "LEGO_BODY.prt", "ASM_TOP", "ASM_FRONT", "ASM_RIGHT", "TOP", "FRONT", "RIGHT"); 
// 利用函式呼叫組立右手 ARM, 組立增量次序為 1
axis_plane_assembly(session, assembly, transf, featID, 0, 
                              "LEGO_ARM_RT.prt", "A_13", "DTM1", "A_4", "DTM1");
// 利用函式呼叫組立左手 ARM, 組立增量次序為 2
axis_plane_assembly(session, assembly, transf, featID, 0, 
                              "LEGO_ARM_LT.prt", "A_9", "DTM2", "A_4", "DTM1");
// 利用函式呼叫組立右手 HAND, 組立增量次序為 3
axis_plane_assembly(session, assembly, transf, featID, 1, 
                              "LEGO_HAND.prt", "A_2", "DTM2", "A_1", "DTM3");
// 利用函式呼叫組立左手 HAND, 組立增量次序為 4
axis_plane_assembly(session, assembly, transf, featID, 2, 
                              "LEGO_HAND.prt", "A_2", "DTM2", "A_1", "DTM3");
// 利用函式呼叫組立人偶頭部 HEAD, 組立增量次序為 5
// BODY id 為 featID+0, 以 A_2 及  DTM3 約束
// HEAD 則直接呼叫檔案名稱, 以 A_2, DTM2 約束
axis_plane_assembly(session, assembly, transf, featID, 0, 
                              "LEGO_HEAD.prt", "A_2", "DTM3", "A_2", "DTM2");
// Body 與 WAIST 採三個平面約束組立
// Body 組立面為 DTM4, DTM5, DTM6
// WAIST 組立面為 DTM1, DTM2, DTM3, 組立增量次序為 6, 與 body 採三面 mate 組立
three_plane_assembly2(session, assembly, transf, featID, 0, "LEGO_WAIST.prt", "DTM4", "DTM5", "DTM6", "DTM1", "DTM2", "DTM3"); 
// 右腳
axis_plane_assembly(session, assembly, transf, featID, 6, 
                              "LEGO_LEG_RT.prt", "A_8", "DTM4", "A_10", "DTM1");
// 左腳
axis_plane_assembly(session, assembly, transf, featID, 6, 
                              "LEGO_LEG_LT.prt", "A_8", "DTM5", "A_10", "DTM1");
// 紅帽
axis_plane_assembly(session, assembly, transf, featID, 5, 
                              "LEGO_HAT.prt", "A_2", "TOP", "A_2", "FRONT"); 
// regenerate 並且 repaint 組立檔案
assembly.Regenerate (void null);
session.GetModelWindow (assembly).Repaint();    
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
'''
        return outstring</t>
<t tx="amd.20151122095724.1">#STL Binary 轉為 ASCII
import struct
normals = []
points = []
triangles = []
triangle_number = 0
def load_binary_stl(fp):
    '''
    二位元 STL 檔案格式如下:
    檔案標頭共有 80 個字元(bytes), 內容通常省略, 但是內容不可使用 solid, 以免與文字檔案 STL 混淆
    UINT8[80] – Header
    UINT32 – Number of triangles (I:佔 4 bytes 的 unsigned integer)
      
    foreach triangle
    REAL32[3] – Normal vector (f:每一座標分量為一佔 4 bytes 的 float, 共佔 12 bytes)
    REAL32[3] – Vertex 1
    REAL32[3] – Vertex 2
    REAL32[3] – Vertex 3
    UINT16 – Attribute byte count (H:兩個 bytes 的 unsigned short, 表示 attribute byte count)
    end
      
    '''
    # 已經在外部開檔
    #fp=open(filename,'rb')
    header=fp.read(80)
    triangle_number = struct.unpack('I',fp.read(4))[0]
    #print(triangle_number)
    count=0
    while True:
        try:
            p=fp.read(12)
            if len(p)==12:
                n=[struct.unpack('f',p[0:4])[0],struct.unpack('f',p[4:8])[0],struct.unpack('f',p[8:12])[0]]
                normals.append(n)
                l = len(points)
                #print(n)
            p=fp.read(12)
            if len(p)==12:
                p1=[struct.unpack('f',p[0:4])[0],struct.unpack('f',p[4:8])[0],struct.unpack('f',p[8:12])[0]]
                points.append(p1)
                #print(p1)
            p=fp.read(12)
            if len(p)==12:
                p2=[struct.unpack('f',p[0:4])[0],struct.unpack('f',p[4:8])[0],struct.unpack('f',p[8:12])[0]]
                points.append(p2)
            p=fp.read(12)
            if len(p)==12:
                p3=[struct.unpack('f',p[0:4])[0],struct.unpack('f',p[4:8])[0],struct.unpack('f',p[8:12])[0]]
                points.append(p3)
                triangles.append((l, l+1, l+2))
            # 使用 count 來計算三角形平面個數
            # triangle_number 為 STL 檔案中的三角形個數
            count += 1
            #print(count)
            # 在前面 12*4 個 bytes 的 normal 與三個點資料後, 為
            # 一個 2 bytes 長的 unsigned short, 其值為零, 為 attribute
            fp.read(2)
            # 讀完所有三角平面後, 即跳出 while
            if count &gt; triangle_number:
                break
        except EOFError:
            break
    #fp.close()
def read_length(f):
    length = struct.unpack("@i", f.read(4))
    return length[0]
def read_header(f):
    f.seek(f.tell()+80)
def write_as_ascii(outfilename):
    f = open(outfilename, "w")
    f.write ("solid "+outfilename+"\n")
    for n  in range(len(triangles)):
        f.write ("facet normal {} {} {}\n".format(normals[n][0],normals[n][1],normals[n][2]))
        f.write ("outer loop\n")
        f.write ("vertex {} {} {}\n".format(points[triangles[n][0]][0],points[triangles[n][0]][1],points[triangles[n][0]][2]))
        f.write ("vertex {} {} {}\n".format(points[triangles[n][1]][0],points[triangles[n][1]][1],points[triangles[n][1]][2]))
        f.write ("vertex {} {} {}\n".format(points[triangles[n][2]][0],points[triangles[n][2]][1],points[triangles[n][2]][2]))
        f.write ("endloop\n")
        f.write ("endfacet\n")
    f.write ("endsolid "+outfilename+"\n")
    f.close()
def main():
    infilename = "ss1.stl"
    outfilename = "ss2.stl"
    try:
        f = open(infilename, "rb")
        #read_header(f)
        #l = read_length(f)
        try:
            load_binary_stl(f)
            l = len(normals)
        except Exception as e:
            print("Exception",e)
        print(len(normals), len(points), len(triangles), l)
        write_as_ascii(outfilename)
        print("done")
    except Exception as e:
        print(e)
if __name__ == '__main__':
    main()</t>
<t tx="amd.20151122095840.1">#coding: utf-8
import struct
      
class StLFacet:
    def __init__(self, normal, v1, v2, v3, att_bc=0):
        self.coords = [normal, v1, v2, v3]
        self.att_bc = att_bc
  
class StL:
    def __init__(self, header):
        self.header = header
        self.facets = []
    def add_facet(self, facet):
        self.facets.append(facet)
    def get_binary(self):
        # 原先 2.0 的版本
        #out = ['%-80.80s' % self.header]
        # 改為 Python 3.0 格式
        # 第一行標頭的格式
        header = ['%-80.80s' % self.header][0]
        # 利用 bytes() 將標頭字串轉為二位元資料
        out = [bytes(header,encoding="utf-8")]
        # 接著則計算三角形面的數量, 並以二位元長整數格式存檔
        out.append(struct.pack('L',len(self.facets)))
        # 接著則依照法線向量與三個點座標的格式, 分別以浮點數格式進行資料附加
        for f in self.facets:
            for coord in f.coords:
                out.append(struct.pack('3f', *coord))
            # att_bc 則內定為 0
            out.append(struct.pack('H', f.att_bc))
        return b"".join(out)
  
def test():
    stl=StL('Header ...')
    stl.add_facet(StLFacet((0.,0.,1.),(0.,0.,0.),(1.,0.,0.),(0.,1.,0.)))
    stl.add_facet(StLFacet((0.,0.,1.),(1.,0.,0.),(1.,1.,0.),(0.,1.,0.)))
    # 第二個平面
    stl.add_facet(StLFacet((0.,-1.,0.),(0.,0.,0.),(0.,0.,-1.),(1.,0.,-1.)))
    stl.add_facet(StLFacet((0.,-1.,0.),(0.,0.,0.),(1.,0.,-1.),(1.,0.,0.)))
    return stl.get_binary()
  
# 指定存為 binary 格式檔案
stlfile = open("test.stl", "wb")
stlcontent = test()
stlfile.write(stlcontent)</t>
<t tx="amd.20151122100250.1"># https://github.com/coursemdetw/2015cd/blob/87783b8a4321336493c533152b4ce1e354ece867/wsgi.py
@cherrypy.expose
def index(self, guess=None):
    # 將標準答案存入 answer session 對應區
    theanswer = random.randint(1, 100)
    thecount = 0
    # 將答案與計算次數變數存進 session 對應變數
    cherrypy.session['answer'] = theanswer
    cherrypy.session['count'] = thecount
    # 印出讓使用者輸入的超文件表單
    outstring = '''
&lt;!DOCTYPE html&gt; 
&lt;html&gt;
&lt;head&gt;
&lt;meta http-equiv="content-type" content="text/html;charset=utf-8"&gt;
&lt;!-- 載入 brython.js --&gt;
&lt;script type="text/javascript" src="/static/Brython3.1.0-20150301-090019/brython.js"&gt;&lt;/script&gt;
&lt;script src="/static/Cango2D.js" type="text/javascript"&gt;&lt;/script&gt;
&lt;script src="/static/gearUtils-04.js" type="text/javascript"&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;!-- 啟動 brython() --&gt;
&lt;body onload="brython()"&gt;
     
&lt;form method=POST action=doCheck&gt;
請輸入您所猜的整數:&lt;input type=text name=guess&gt;&lt;br /&gt;
&lt;input type=submit value=send&gt;
&lt;/form&gt;
&lt;hr&gt;
&lt;!-- 以下在網頁內嵌 Brython 程式 --&gt;
&lt;script type="text/python"&gt;
from browser import document, alert
 
def echo(ev):
    alert(document["zone"].value)
 
# 將文件中名稱為 mybutton 的物件, 透過 click 事件與 echo 函式 bind 在一起
document['mybutton'].bind('click',echo)
&lt;/script&gt;
&lt;input id="zone"&gt;&lt;button id="mybutton"&gt;click !&lt;/button&gt;
&lt;hr&gt;
&lt;!-- 以下為 canvas 畫圖程式 --&gt;
&lt;script type="text/python"&gt;
# 從 browser 導入 document
from browser import document
import math
 
# 畫布指定在名稱為 plotarea 的 canvas 上
canvas = document["plotarea"]
ctx = canvas.getContext("2d")
 
# 用紅色畫一條直線
ctx.beginPath()
ctx.lineWidth = 3
ctx.moveTo(0, 0)
ctx.lineTo(0, 500)
ctx.strokeStyle = "red"
ctx.stroke()
 
# 用藍色再畫一條直線
ctx.beginPath()
ctx.lineWidth = 3
ctx.moveTo(0, 0)
ctx.lineTo(500, 0)
ctx.strokeStyle = "blue"
ctx.stroke()
 
# 用綠色再畫一條直線
ctx.beginPath()
ctx.lineWidth = 3
ctx.moveTo(0, 0)
ctx.lineTo(500, 500)
ctx.strokeStyle = "green"
ctx.stroke()
 
# 用黑色畫一個圓
ctx.beginPath()
ctx.lineWidth = 3
ctx.strokeStyle = "black"
ctx.arc(250,250,50,0,2*math.pi)
ctx.stroke()
&lt;/script&gt;
&lt;canvas id="plotarea" width="800" height="600"&gt;&lt;/canvas&gt;
&lt;/body&gt;
&lt;/html&gt;
'''
 
    return outstring</t>
<t tx="amd.20151122100400.1"># http://2014c2-mdenfu.rhcloud.com/c2g30/flag
@cherrypy.expose
def flag(self, *args, **kwargs):
    '''
    原始程式來源: http://blog.roodo.com/esabear/archives/19215194.html
    改寫為 Brython 程式
    '''
    outstring = '''
&lt;!DOCTYPE html&gt; 
&lt;html&gt;
&lt;head&gt;
&lt;meta http-equiv="content-type" content="text/html;charset=utf-8"&gt;
&lt;script type="text/javascript" src="/static/Brython2.1.0-20140419-113919/brython.js"&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body onload="brython({debug:1, cache:'version'})"&gt;
&lt;canvas id="plotarea" width="300" height="200"&gt;&lt;/canvas&gt;
&lt;script type="text/python"&gt;
# 導入 doc
from browser import doc
import math
 
# 準備繪圖畫布
canvas = doc["plotarea"]
ctx = canvas.getContext("2d")
# 進行座標轉換, x 軸不變, y 軸反向且移動 canvas.height 單位光點
# ctx.setTransform(1, 0, 0, -1, 0, canvas.height)
# 以下採用 canvas 原始座標繪圖
flag_w = canvas.width
flag_h = canvas.height
circle_x = flag_w/4
circle_y = flag_h/4
# 先畫滿地紅
ctx.fillStyle='rgb(255, 0, 0)'
ctx.fillRect(0,0,flag_w,flag_h)
# 再畫青天
ctx.fillStyle='rgb(0, 0, 150)'
ctx.fillRect(0,0,flag_w/2,flag_h/2)
# 畫十二到光芒白日
ctx.beginPath()
star_radius = flag_w/8
angle = 0
for i in range(24):
    angle += 5*math.pi*2/12
    toX = circle_x + math.cos(angle)*star_radius
    toY = circle_y + math.sin(angle)*star_radius
    # 只有 i 為 0 時移動到 toX, toY, 其餘都進行 lineTo
    if (i):
        ctx.lineTo(toX, toY)
    else:
        ctx.moveTo(toX, toY)
# 將填色設為白色
ctx.fillStyle = '#fff'
ctx.fill()
# 白日:藍圈
ctx.beginPath()
# 查詢 canvas arc 如何定義
ctx.arc(circle_x, circle_y, flag_w*17/240, 0, math.pi*2, true)
ctx.closePath()
# 填色設為藍色
ctx.fillStyle = 'rgb(0, 0, 149)'
ctx.fill()
# 白日:白心
ctx.beginPath()
ctx.arc(circle_x, circle_y, flag_w/16, 0, math.pi*2, true)
ctx.closePath()
# 填色設為白色
ctx.fillStyle = '#fff'
ctx.fill()
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
'''
    return outstring</t>
<t tx="amd.20151122100546.1"># http://2014c2-mdenfu.rhcloud.com/c2g30/star
@cherrypy.expose
def star(self, *args, **kwargs):
    outstring = '''
&lt;!DOCTYPE html&gt; 
&lt;html&gt;
&lt;head&gt;
&lt;meta http-equiv="content-type" content="text/html;charset=utf-8"&gt;
&lt;script type="text/javascript" src="/static/Brython2.1.0-20140419-113919/brython.js"&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body onload="brython({debug:1, cache:'version'})"&gt;
&lt;canvas id="plotarea" width="800" height="800"&gt;&lt;/canvas&gt;
&lt;script type="text/python"&gt;
# 導入 doc
from browser import doc
import math
 
# 準備繪圖畫布
canvas = doc["plotarea"]
ctx = canvas.getContext("2d")
# 進行座標轉換, x 軸不變, y 軸反向且移動 800 光點
ctx.setTransform(1, 0, 0, -1, 0, 800)
 
# 定義畫線函式
def draw_line(x1, y1, x2, y2, linethick = 3, color = "black"):
    ctx.beginPath()
    ctx.lineWidth = linethick
    ctx.moveTo(x1, y1)
    ctx.lineTo(x2, y2)
    ctx.strokeStyle = color
    ctx.stroke()
 
# x, y 為中心,  r 為半徑, angle 旋轉角,  solid 空心或實心,  color 顏色
def star(x, y, r, angle=0, solid=False, color="#f00"):
    # 以 x, y 為圓心, 計算五個外點
    deg = math.pi/180
    # 圓心到水平線距離
    a = r*math.cos(72*deg)
    # a 頂點向右到內點距離
    b = (r*math.cos(72*deg)/math.cos(36*deg))*math.sin(36*deg)
    # 利用畢氏定理求內點半徑
    rin = math.sqrt(a**2 + b**2)
    # 查驗 a, b 與 rin
    #print(a, b, rin)
    if(solid):
        ctx.beginPath()
    for i in range(5):
        xout = (x + r*math.sin((360/5)*deg*i+angle*deg))
        yout = (y + r*math.cos((360/5)*deg*i+angle*deg))
        # 外點增量 + 1
        xout2 = x + r*math.sin((360/5)*deg*(i+1)+angle*deg)
        yout2 = y + r*math.cos((360/5)*deg*(i+1)+angle*deg)
        xin = x + rin*math.sin((360/5)*deg*i+36*deg+angle*deg)
        yin = y + rin*math.cos((360/5)*deg*i+36*deg+angle*deg)
        # 查驗外點與內點座標
        #print(xout, yout, xin, yin)
        if(solid):
            # 填色
            if(i==0):
                ctx.moveTo(xout, yout)
                ctx.lineTo(xin, yin)
                ctx.lineTo(xout2, yout2)
            else:
                ctx.lineTo(xin, yin)
                ctx.lineTo(xout2, yout2)
        else:
            # 空心
            draw_line(xout, yout, xin, yin, color)
            # 畫空心五芒星, 無關畫線次序, 若實心則與畫線次序有關
            draw_line(xout2, yout2, xin, yin, color)
    if(solid):
        ctx.fillStyle = color
        ctx.fill()
star(600, 600, 100, 30, True, "#00f")
star(100, 100, 30, 0, True, "#f00")
#star(300, 300, 50, 0, False, "#000")
for i in range(5):
    for j in range(5):
        star(200+65*i, 200+65*j, 30, 0, False, "#000")
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
'''
    return outstring</t>
<t tx="amd.20151122102956.1">http://threejs.org/</t>
<t tx="amd.20151122214658.1">http://blog.bobbyallen.me/2014/01/11/setup-your-own-private-github-server-using-gitlab-and-ubuntu-server-12-04-lts/

https://www.linux.com/learn/tutorials/824358-how-to-run-your-own-git-server</t>
<t tx="amd.20151124172242.1"># http://2014c2-mdenfu.rhcloud.com/c2g30/flag
# 直接送出 html 版本
@app.route("/drawflag")
def drawflag():
    '''
    原始程式來源: http://blog.roodo.com/esabear/archives/19215194.html
    改寫為 Brython 程式
    '''
    outstring = '''
&lt;!DOCTYPE html&gt; 
&lt;html&gt;
&lt;head&gt;
&lt;meta http-equiv="content-type" content="text/html;charset=utf-8"&gt;
&lt;script type="text/javascript" src="/static/Brython3.2.3-20151122-082712/brython.js"&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body onload="brython({debug:1, cache:'version'})"&gt;
&lt;canvas id="plotarea" width="300" height="200"&gt;&lt;/canvas&gt;
&lt;script type="text/python"&gt;
# 導入 doc
from browser import document as doc
import math

# 準備繪圖畫布
canvas = doc["plotarea"]
ctx = canvas.getContext("2d")
# 進行座標轉換, x 軸不變, y 軸反向且移動 canvas.height 單位光點
# ctx.setTransform(1, 0, 0, -1, 0, canvas.height)
# 以下採用 canvas 原始座標繪圖
flag_w = canvas.width
flag_h = canvas.height
circle_x = flag_w/4
circle_y = flag_h/4
# 先畫滿地紅
ctx.fillStyle='rgb(255, 0, 0)'
ctx.fillRect(0,0,flag_w,flag_h)
# 再畫青天
ctx.fillStyle='rgb(0, 0, 150)'
ctx.fillRect(0,0,flag_w/2,flag_h/2)
# 畫十二道光芒白日
ctx.beginPath()
star_radius = flag_w/8
angle = 0
for i in range(24):
    angle += 5*math.pi*2/12
    toX = circle_x + math.cos(angle)*star_radius
    toY = circle_y + math.sin(angle)*star_radius
    # 只有 i 為 0 時移動到 toX, toY, 其餘都進行 lineTo
    if (i):
        ctx.lineTo(toX, toY)
    else:
        ctx.moveTo(toX, toY)
ctx.closePath()
# 將填色設為白色
ctx.fillStyle = '#fff'
ctx.fill()
# 白日:藍圈
ctx.beginPath()
ctx.arc(circle_x, circle_y, flag_w*17/240, 0, math.pi*2, True)
ctx.closePath()
# 填色設為藍色
ctx.fillStyle = 'rgb(0, 0, 149)'
ctx.fill()
# 白日:白心
ctx.beginPath()
ctx.arc(circle_x, circle_y, flag_w/16, 0, math.pi*2, True)
ctx.closePath()
# 填色設為白色
ctx.fillStyle = '#fff'
ctx.fill()
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
'''
    return outstring</t>
<t tx="amd.20151124205123.1"># 直接送出 html 版本
@app.route("/drawstar")
def drawstar():
    outstring = '''
&lt;!DOCTYPE html&gt; 
&lt;html&gt;
&lt;head&gt;
&lt;meta http-equiv="content-type" content="text/html;charset=utf-8"&gt;
&lt;script type="text/javascript" src="/static/Brython3.2.3-20151122-082712/brython.js"&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body onload="brython({debug:1, cache:'version'})"&gt;
&lt;canvas id="plotarea" width="800" height="800"&gt;&lt;/canvas&gt;
&lt;script type="text/python"&gt;
# 導入 doc
from browser import document as doc
import math

# 準備繪圖畫布
canvas = doc["plotarea"]
ctx = canvas.getContext("2d")
# 進行座標轉換, x 軸不變, y 軸反向且移動 800 光點
ctx.setTransform(1, 0, 0, -1, 0, 800)

# 定義畫線函式
def draw_line(x1, y1, x2, y2, linethick = 3, color = "black"):
    ctx.beginPath()
    ctx.lineWidth = linethick
    ctx.moveTo(x1, y1)
    ctx.lineTo(x2, y2)
    ctx.strokeStyle = color
    ctx.stroke()

# x, y 為中心,  r 為半徑, angle 旋轉角,  solid 空心或實心,  color 顏色
def star(x, y, r, angle=0, solid=False, color="#f00"):
    # 以 x, y 為圓心, 計算五個外點
    deg = math.pi/180
    # 圓心到水平線距離
    a = r*math.cos(72*deg)
    # a 頂點向右到內點距離
    b = (r*math.cos(72*deg)/math.cos(36*deg))*math.sin(36*deg)
    # 利用畢氏定理求內點半徑
    rin = math.sqrt(a**2 + b**2)
    # 查驗 a, b 與 rin
    #print(a, b, rin)
    if(solid):
        ctx.beginPath()
    for i in range(5):
        xout = (x + r*math.sin((360/5)*deg*i+angle*deg))
        yout = (y + r*math.cos((360/5)*deg*i+angle*deg))
        # 外點增量 + 1
        xout2 = x + r*math.sin((360/5)*deg*(i+1)+angle*deg)
        yout2 = y + r*math.cos((360/5)*deg*(i+1)+angle*deg)
        xin = x + rin*math.sin((360/5)*deg*i+36*deg+angle*deg)
        yin = y + rin*math.cos((360/5)*deg*i+36*deg+angle*deg)
        # 查驗外點與內點座標
        #print(xout, yout, xin, yin)
        if(solid):
            # 填色
            if(i==0):
                ctx.moveTo(xout, yout)
                ctx.lineTo(xin, yin)
                ctx.lineTo(xout2, yout2)
            else:
                ctx.lineTo(xin, yin)
                ctx.lineTo(xout2, yout2)
        else:
            # 空心
            draw_line(xout, yout, xin, yin, color)
            # 畫空心五芒星, 無關畫線次序, 若實心則與畫線次序有關
            draw_line(xout2, yout2, xin, yin, color)
    if(solid):
        ctx.fillStyle = color
        ctx.fill()
star(600, 600, 100, 30, True, "#00f")
star(100, 100, 30, 0, True, "#f00")
#star(300, 300, 50, 0, False, "#000")
for i in range(5):
    for j in range(5):
        star(200+65*i, 200+65*j, 30, 0, False, "#000")
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
'''
    return outstring
</t>
<t tx="amd.20151124205805.1">/*==========================================================================*
  Filename: gearUtils-05.js
  By: Dr A.R.Collins

  JavaScript involute gear drawing utilities.
  Requires:
  'involuteBezCoeffs' can stand alone,
  'createGearTooth' and 'createIntGearTooth' generate draw commands for use
  in Cango graphics library but may be simply converted for use in SVG.

  Kindly give credit to Dr A.R.Collins &lt;http://www.arc.id.au/&gt;
  Report bugs to tony at arc.id.au

  Date   |Description                                                   |By
  --------------------------------------------------------------------------
  20Feb13 First public release                                           ARC
  21Feb13 Clarified variable names of start and end parameters           ARC
  06Mar13 Fixed Rf and filletAngle calculations                          ARC
  25Jun13 Code tidy for JSLint, use strict                               ARC
  16Mar15 Convert sweep direction of "A" commands for RHC coordinates    ARC
  
  source: http://www.arc.id.au/gearUtils-05.js
 *==========================================================================*/

  // exposed globals
  var involuteBezCoeffs, createGearTooth, createIntGearTooth;

(function()
{
  "use strict";
  /* ----------------------------------------------------------
   * involuteBezCoeffs
   *
   * JavaScript calculation of Bezier coefficients for
   * Higuchi et al. approximation to an involute.
   * ref: YNU Digital Eng Lab Memorandum 05-1
   *
   * Parameters:
   * module - sets the size of teeth (see gear design texts)
   * numTeeth - number of teeth on the gear
   * pressure angle - angle in degrees, usually 14.5 or 20
   * order - the order of the Bezier curve to be fitted [3, 4, 5, ..]
   * fstart - fraction of distance along tooth profile to start
   * fstop - fraction of distance along profile to stop
   *-----------------------------------------------------------*/
  involuteBezCoeffs = function(module, numTeeth, pressureAngle, order, fstart, fstop)
  {
    var PI = Math.PI,
        Rpitch = module*numTeeth/2,       // pitch circle radius
        phi = pressureAngle || 20,        // pressure angle
        Rb = Rpitch*Math.cos(phi*PI/180), // base circle radius
        Ra = Rpitch+module,               // addendum radius (outer radius)
        p = order || 3,                   // order of Bezier approximation
        ta = Math.sqrt(Ra*Ra-Rb*Rb)/Rb,   // involute angle at addendum
        stop = fstop || 1,
        start = 0.01,
        te, ts,
        bzCoeffs = [],
        i, bcoeff;

    function chebyExpnCoeffs(j, func)
    {
      var N = 50,      // a suitably large number  N&gt;&gt;p
          c = 0,
          k;

      for (k=1; k&lt;=N; k++)
      {
        c += func(Math.cos(PI*(k-0.5)/N)) * Math.cos(PI*j*(k-0.5)/N);
      }
      return 2*c/N;
    }

    function chebyPolyCoeffs(p, func)
    {
      var coeffs = [],
          fnCoeff = [],
          T = [[], []],
          i, j, k, pwr;

      // populate 1st 2 rows of T
      for (i=0; i&lt;p+1; i++)
      {
        T[0][i] = 0;
        T[1][i] = 0;
      }
      T[0][0] = 1;
      T[1][1] = 1;
      /* now generate the Chebyshev polynomial coefficient using
         formula T(k+1) = 2xT(k) - T(k-1) which yields
      T = [ [ 1,  0,  0,  0,  0,  0],    // T0(x) =  +1
            [ 0,  1,  0,  0,  0,  0],    // T1(x) =   0  +x
            [-1,  0,  2,  0,  0,  0],    // T2(x) =  -1  0  +2xx
            [ 0, -3,  0,  4,  0,  0],    // T3(x) =   0 -3x    0   +4xxx
            [ 1,  0, -8,  0,  8,  0],    // T4(x) =  +1  0  -8xx       0  +8xxxx
            [ 0,  5,  0,-20,  0, 16],    // T5(x) =   0  5x    0  -20xxx       0  +16xxxxx
            ...                     ];
      */
      for (k=1; k&lt;p+1; k++)
      {
        T[k+1] = [0];
        for (j=0; j&lt;T[k].length-1; j++)
        {
          T[k+1][j+1] = 2*T[k][j];
        }
        for (j=0; j&lt;T[k-1].length; j++)
        {
          T[k+1][j] -= T[k-1][j];
        }
      }
      // convert the chebyshev function series into a simple polynomial
      // and collect like terms, out T polynomial coefficients
      for (k=0; k&lt;=p; k++)
      {
        fnCoeff[k] = chebyExpnCoeffs(k, func);
        coeffs[k] = 0;
      }
      for (k=0; k&lt;=p; k++)
      {
        for (pwr=0; pwr&lt;=p; pwr++)    // loop thru powers of x
        {
          coeffs[pwr] += fnCoeff[k]*T[k][pwr];
        }
      }
      coeffs[0] -= chebyExpnCoeffs(0, func)/2;  // fix the 0th coeff

      return coeffs;
    }

    // Equation of involute using the Bezier parameter t as variable
    function involuteXbez(t)
    {
      // map t (0 &lt;= t &lt;= 1) onto x (where -1 &lt;= x &lt;= 1)
      var x = t*2-1;
      //map theta (where ts &lt;= theta &lt;= te) from x (-1 &lt;=x &lt;= 1)
      var theta = x*(te-ts)/2 + (ts + te)/2;
      return Rb*(Math.cos(theta)+theta*Math.sin(theta));
    }

    function involuteYbez(t)
    {
          // map t (0 &lt;= t &lt;= 1) onto x (where -1 &lt;= x &lt;= 1)
      var x = t*2-1,
          //map theta (where ts &lt;= theta &lt;= te) from x (-1 &lt;=x &lt;= 1)
          theta = x*(te-ts)/2 + (ts + te)/2;

      return Rb*(Math.sin(theta)-theta*Math.cos(theta));
    }

    function binom(n, k)
    {
      var coeff = 1,
          i;

      for (i = n-k+1; i &lt;= n; i++)
      {
        coeff *= i;
      }
      for (i = 1; i &lt;= k; i++)
      {
        coeff /= i;
      }

      return coeff;
    }

    function bezCoeff(i, func)
    {
      // generate the polynomial coeffs in one go
      var polyCoeffs = chebyPolyCoeffs(p, func),
          bc, j;

      for (bc=0, j=0; j&lt;=i; j++)
      {
        bc += binom(i,j)*polyCoeffs[j]/binom(p,j);
      }
      return bc;
    }

    if ((fstart !== undefined)&amp;&amp;(fstart&lt;stop))
    {
      start = fstart;
    }
    te = Math.sqrt(stop)*ta;          // involute angle, theta, at end of approx
    ts = Math.sqrt(start)*ta;         // involute angle, theta, at start of approx
    // calc Bezier coeffs
    for (i=0; i&lt;=p; i++)
    {
      bcoeff = {};
      bcoeff.x = bezCoeff(i, involuteXbez);
      bcoeff.y = bezCoeff(i, involuteYbez);
      bzCoeffs.push(bcoeff);
    }

    return bzCoeffs;
  };

  function rotate(pt, rads)  // rotate pt by rads radians about origin
  {
    var sinA = Math.sin(rads),
        cosA = Math.cos(rads);

    return {x: pt.x*cosA - pt.y*sinA,
            y: pt.x*sinA + pt.y*cosA};
  }

  function toCartesian(radius, angle)   // convert polar coords to cartesian
  {
    return {x: radius*Math.cos(angle),
            y: radius*Math.sin(angle)};
  }

  function genInvolutePolar(Rb, R)  // Rb = base circle radius
  {
    // returns the involute angle as function of radius R.
    return (Math.sqrt(R*R - Rb*Rb)/Rb) - Math.acos(Rb/R);
  }

  /*----------------------------------------------------------
    createGearTooth
    Create an array of drawing commands and their coordinates
    to draw a single spur gear tooth based on a circle
    involute using the metric gear standards.

    Requires Cango graphics library Rev 2.08 or later
   ----------------------------------------------------------*/
  createGearTooth = function(module, teeth, pressureAngle)
  {
    // ****** external gear specifications
    var m = module,                                     // Module = mm of pitch diameter per tooth
        Z = teeth,                                      // Number of teeth
        phi = pressureAngle || 20,                      // pressure angle (degrees)
        addendum = m,                                   // distance from pitch circle to tip circle
        dedendum = 1.25*m,                              // pitch circle to root, sets clearance
        clearance = dedendum - addendum,
        // Calculate radii
        Rpitch = Z*m/2,                                 // pitch circle radius
        Rb = Rpitch*Math.cos(phi*Math.PI/180),          // base circle radius
        Ra = Rpitch + addendum,                         // tip (addendum) circle radius
        Rroot = Rpitch - dedendum,                      // root circle radius
        fRad = 1.5*clearance,                           // fillet radius, max 1.5*clearance
        Rf,                                             // radius at top of fillet
        // ****** calculate angles (all in radians)
        pitchAngle = 2*Math.PI/Z,                       // angle subtended by whole tooth (rads)
        baseToPitchAngle = genInvolutePolar(Rb, Rpitch),
        pitchToFilletAngle = baseToPitchAngle,          // profile starts at base circle
        filletAngle = Math.atan(fRad/(fRad+Rroot)),     // radians
        fe, fs, fm,
        dedBz, addBz, inv, invR,
        fillet, filletR, filletNext,
        rootR, rootNext,
        pt, i, data;

    Rf = Math.sqrt((Rroot+fRad)*(Rroot+fRad)-(fRad*fRad)); // radius at top of fillet
    if (Rb &lt; Rf)
    {
      Rf = Rroot+clearance;
    }
    if (Rf &gt; Rb)                   // start profile at top of fillet (if its greater)
    {
      pitchToFilletAngle -= genInvolutePolar(Rb, Rf);
    }
    // ****** generate Higuchi involute approximation
    fe = 1;                    // fraction of profile length at end of approx
    fs = 0.01;                 // fraction of length offset from base to avoid singularity
    if (Rf &gt; Rb)
    {
      fs = (Rf*Rf-Rb*Rb)/(Ra*Ra-Rb*Rb);  // offset start to top of fillet
    }
    // approximate in 2 sections, split 25% along the involute
    fm = fs+(fe-fs)/4;         // fraction of length at junction (25% along profile)
    dedBz = involuteBezCoeffs(m, Z, phi, 3, fs, fm);
    addBz = involuteBezCoeffs(m, Z, phi, 3, fm, fe);
    // join the 2 sets of coeffs (skip duplicate mid point)
    inv = dedBz.concat(addBz.slice(1));
    //create the back profile of tooth (mirror image)
    invR = [];                // involute profile along back of tooth
    for (i=0; i&lt;inv.length; i++)
    {
      // rotate all points to put pitch point at y = 0
      pt = rotate(inv[i], -baseToPitchAngle-pitchAngle/4);
      inv[i] = pt;
      // generate the back of tooth profile nodes, mirror coords in X axis
      invR[i] = {x:pt.x, y:-pt.y};
    }
    // ****** calculate section junction points R=back of tooth, Next=front of next tooth)
    fillet = toCartesian(Rf, -pitchAngle/4-pitchToFilletAngle); // top of fillet
    filletR = {x:fillet.x, y:-fillet.y};   // flip to make same point on back of tooth
    rootR = toCartesian(Rroot, pitchAngle/4+pitchToFilletAngle+filletAngle);
    rootNext = toCartesian(Rroot, 3*pitchAngle/4-pitchToFilletAngle-filletAngle);
    filletNext = rotate(fillet, pitchAngle);  // top of fillet, front of next tooth
    // ****** create the drawing command data array for the tooth
    data = [];
    data.push("M", fillet.x, fillet.y);           // start at top of fillet
    if (Rf &lt; Rb)
    {
      data.push("L", inv[0].x, inv[0].y);         // line from fillet up to base circle
    }
    data.push("C", inv[1].x, inv[1].y, inv[2].x, inv[2].y, inv[3].x, inv[3].y,
                   inv[4].x, inv[4].y, inv[5].x, inv[5].y, inv[6].x, inv[6].y);
    data.push("A", Ra, Ra, 0, 0, 1, invR[6].x, invR[6].y); // arc across addendum circle, sweep 1 for RHC, 0 for SVG
    data.push("C", invR[5].x, invR[5].y, invR[4].x, invR[4].y, invR[3].x, invR[3].y,
                   invR[2].x, invR[2].y, invR[1].x, invR[1].y, invR[0].x, invR[0].y);
    if (Rf &lt; Rb)
    {
      data.push("L", filletR.x, filletR.y);       // line down to top of fillet
    }
    if (rootNext.y &gt; rootR.y)    // is there a section of root circle between fillets?
    {
      data.push("A", fRad, fRad, 0, 0, 0, rootR.x, rootR.y); // back fillet, sweep 0 for RHC, 1 for SVG
      data.push("A", Rroot, Rroot, 0, 0, 1, rootNext.x, rootNext.y); // root circle arc, sweep 1 for RHC, 0 for SVG
    }
    data.push("A", fRad, fRad, 0, 0, 0, filletNext.x, filletNext.y); // sweep 0 for RHC, 1 for SVG

    return data;  // return an array of Cango (SVG) format draw commands
  };

  /*----------------------------------------------------------
    createIntGearTooth
    Create an array of drawing commands and their coordinates
    to draw a single internal (ring)gear tooth based on a
    circle involute using the metric gear standards.

    Requires Cango graphics library Rev 2.08 or later
   ----------------------------------------------------------*/
  createIntGearTooth = function(module, teeth, pressureAngle)
  {
    // ****** gear specifications
    var m = module,                               // Module = mm of pitch diameter per tooth
        Z = teeth,                                // Number of teeth
        phi = pressureAngle || 20,                // pressure angle (degrees)
        addendum = 0.6*m,                         // pitch circle to tip circle (ref G.M.Maitra)
        dedendum = 1.25*m,                        // pitch circle to root radius, sets clearance
        // Calculate radii
        Rpitch = Z*m/2,                           // pitch radius
        Rb = Rpitch*Math.cos(phi*Math.PI/180),    // base radius
        Ra = Rpitch - addendum,                   // addendum radius
        Rroot = Rpitch + dedendum,                // root radius
        clearance = 0.25*m,                       // gear dedendum - pinion addendum
        Rf = Rroot - clearance,                   // radius of top of fillet (end of profile)
        fRad = 1.5*clearance,                     // fillet radius, 1 .. 1.5*clearance
        pitchAngle,                               // angle between teeth (rads)
        baseToPitchAngle,
        tipToPitchAngle,
        pitchToFilletAngle,
        filletAngle,
        fe, fs, fm,
        addBz, dedBz,
        inv, invR,
        pt, i, data,
        fillet, filletNext,
        tip, tipR,
        rootR, rootNext;

    // ****** calculate subtended angles
    pitchAngle = 2*Math.PI/Z;                       // angle between teeth (rads)
    baseToPitchAngle = genInvolutePolar(Rb, Rpitch);
    tipToPitchAngle = baseToPitchAngle;             // profile starts from base circle
    if (Ra &gt; Rb)
    {
      tipToPitchAngle -= genInvolutePolar(Rb, Ra);  // start profile from addendum
    }
    pitchToFilletAngle = genInvolutePolar(Rb, Rf) - baseToPitchAngle;
    filletAngle = 1.414*clearance/Rf;               // to make fillet tangential to root
    // ****** generate Higuchi involute approximation
    fe = 1;                   // fraction of involute length at end of approx (fillet circle)
    fs = 0.01;                 // fraction of length offset from base to avoid singularity
    if (Ra &gt; Rb)
    {
      fs = (Ra*Ra-Rb*Rb)/(Rf*Rf-Rb*Rb);    // start profile from addendum (tip circle)
    }
    // approximate in 2 sections, split 25% along the profile
    fm = fs+(fe-fs)/4;        //
    addBz = involuteBezCoeffs(m, Z, phi, 3, fs, fm);
    dedBz = involuteBezCoeffs(m, Z, phi, 3, fm, fe);
    // join the 2 sets of coeffs (skip duplicate mid point)
    invR = addBz.concat(dedBz.slice(1));
    //create the front profile of tooth (mirror image)
    inv = [];         // back involute profile
    for (i=0; i&lt;invR.length; i++)
    {
      // rotate involute to put center of tooth at y = 0
      pt = rotate(invR[i], pitchAngle/4-baseToPitchAngle);
      invR[i] = pt;
      // generate the back of tooth profile, flip Y coords
      inv[i] = {x:pt.x, y:-pt.y};
    }
    // ****** calculate coords of section junctions
    fillet = {x:inv[6].x, y:inv[6].y};    // top of fillet, front of tooth
    tip = toCartesian(Ra, -pitchAngle/4+tipToPitchAngle);  // tip, front of tooth
    tipR = {x:tip.x, y:-tip.y};  // addendum, back of tooth
    rootR = toCartesian(Rroot, pitchAngle/4+pitchToFilletAngle+filletAngle);
    rootNext = toCartesian(Rroot, 3*pitchAngle/4-pitchToFilletAngle-filletAngle);
    filletNext = rotate(fillet, pitchAngle);  // top of fillet, front of next tooth
    // ****** create the drawing command data array for the tooth
    data = [];
    data.push("M", inv[6].x, inv[6].y);  // start at top of front profile
    data.push("C", inv[5].x, inv[5].y, inv[4].x, inv[4].y, inv[3].x, inv[3].y,
                   inv[2].x, inv[2].y, inv[1].x, inv[1].y, inv[0].x, inv[0].y);
    if (Ra &lt; Rb)
    {
      data.push("L", tip.x, tip.y);  // line from end of involute to addendum (tip)
    }
    data.push("A", Ra, Ra, 0, 0, 1, tipR.x, tipR.y); // arc across tip circle, sweep 1 for RHC, 0 for SVG
    if (Ra &lt; Rb)
    {
      data.push("L", invR[0].x, invR[0].y);  // line from addendum to start of involute
    }
    data.push("C", invR[1].x, invR[1].y, invR[2].x, invR[2].y, invR[3].x, invR[3].y,
                   invR[4].x, invR[4].y, invR[5].x, invR[5].y, invR[6].x, invR[6].y);
    if (rootR.y &lt; rootNext.y)    // there is a section of root circle between fillets
    {
      data.push("A", fRad, fRad, 0, 0, 1, rootR.x, rootR.y); // fillet on back of tooth, sweep 1 for RHC, 0 for SVG
      data.push("A", Rroot, Rroot, 0, 0, 1, rootNext.x, rootNext.y); // root circle arc, sweep 1 for RHC, 0 for SVG
    }
    data.push("A", fRad, fRad, 0, 0, 1, filletNext.x, filletNext.y); // fillet on next, sweep 1 for RHC, 0 for SVG 

    return data;  // return an array of Cango (SVG) format draw commands
  };

}());</t>
<t tx="amd.20151124210158.1"># 直接送出 html 版本
@app.route("/drawcango")
def drawcango():
    outstring = '''
&lt;!DOCTYPE html&gt; 
&lt;html&gt;
&lt;head&gt;
&lt;meta http-equiv="content-type" content="text/html;charset=utf-8"&gt;
&lt;script type="text/javascript" src="/static/Cango-7v13.js"&gt;&lt;/script&gt;
&lt;script type="text/javascript" src="/static/Cango2D-6v13.js"&gt;&lt;/script&gt;
&lt;script type="text/javascript" src="/static/Brython3.2.3-20151122-082712/brython.js"&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body onload="brython({debug:1, cache:'version'})"&gt;
&lt;canvas id="plotarea" width="800" height="800"&gt;&lt;/canvas&gt;
&lt;script type="text/python"&gt;
from javascript import JSConstructor
from browser import window
import math

cango = JSConstructor(window.Cango)
cgo = cango("plotarea")
cgo.setGridboxRHC()
cgo.setWorldCoords(-1, -25, 2, 50) 
cgo.drawText("使用 Cango 繪圖程式庫!", 0, 0, {"fontSize":60, "fontWeight": 1200, "lorg":5 })

# Cango2D example
cango2d = JSConstructor(window.Cango2D)
tweener = JSConstructor(window.Tweener)
g = cango2d("plotarea")
g.setWorldCoords(-10, -10, 20)
hello = g.drawText("加油!加油!", 0, 0, {
"fillColor":"blue",
"fontSize":16,
"lorg":5 })
sclTwn = tweener([1, 2, 1], 1000, 5000, 'loopAll')
rotTwn = tweener([0, 360, -360], 1000, 5000, 'loopAll')
hello.transform.scale(sclTwn)
hello.transform.rotate(rotTwn)
g.animate(hello)
g.playAnimation()
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
'''
    return outstring
</t>
<t tx="amd.20151124215720.1"># 直接送出 html 版本
@app.route("/drag")
def drag():
    outstring = '''
&lt;!DOCTYPE html&gt; 
&lt;html&gt;
&lt;head&gt;
&lt;meta http-equiv="content-type" content="text/html;charset=utf-8"&gt;
&lt;script type="text/javascript" src="/static/Cango2D-6v13.js"&gt;&lt;/script&gt;
&lt;script type="text/javascript" src="/static/Brython3.2.3-20151122-082712/brython.js"&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body onload="brython({debug:1, cache:'version'})"&gt;
&lt;canvas id="plotarea" width="800" height="800"&gt;&lt;/canvas&gt;
&lt;script type="text/python"&gt;
from browser import window
from javascript import JSConstructor
  
cango = JSConstructor(window.Cango2D)
shapedefs = window.shapeDefs
obj2d = JSConstructor(window.Obj2D)
cgo = cango("plotarea")
x1, y1 = 40, 20
cx1, cy1 = 90, 120
x2, y2 = 120, 100
cx2, cy2 = 130, 20
cx3, cy3 = 150, 120
x3, y3 = 180, 60

def dragC1(mousePos):
    global cx1, cy1
    cx1 = mousePos.x
    cy1 = mousePos.y
    drawCurve()
 
def dragC2(mousePos):
    global cx2, cy2
    cx2 = mousePos.x
    cy2 = mousePos.y
    drawCurve()
 
def dragC3(mousePos):
    global cx3, cy3
    cx3 = mousePos.x
    cy3 = mousePos.y
    drawCurve()
 
def drawCurve():
    # curve change shape so it must be re-draw each time
    # draw a quadratic bezier from x1,y2 to x2,y2
    qbez = obj2d(['M', x1, y1, 'Q', cx1, cy1, x2, y2], "PATH",  {
          "strokeColor":'blue'})
    cbez = obj2d(['M', x2, y2, 'C', cx2, cy2, cx3, cy3, x3, y3], "PATH",  {
          "strokeColor":'green'})
    # show lines to control point
    L1 = obj2d(['M', x1, y1, 'L', cx1, cy1, x2, y2], "PATH", {
      "strokeColor":"rgba(0, 0, 0, 0.2)",
      "dashed":[4]})  # semi-transparent gray
    L2 = obj2d(['M', x2, y2, 'L', cx2, cy2], "PATH", {
      "strokeColor":"rgba(0, 0, 0, 0.2)",
      "dashed":[4]})
    L3 = obj2d(['M', x3, y3, 'L', cx3, cy3], "PATH", {
      "strokeColor":"rgba(0, 0, 0, 0.2)",
      "dashed":[4]})
    # draw draggable control points
    c1.transform.reset()
    c1.transform.translate(cx1, cy1)
    c2.transform.reset()
    c2.transform.translate(cx2, cy2)
    c3.transform.reset()
    c3.transform.translate(cx3, cy3)
    grp = cgo.createGroup2D(qbez, cbez, L1, L2, L3, c1, c2, c3)
    cgo.renderFrame(grp)
 
cgo.clearCanvas("lightyellow")
cgo.setWorldCoords(0, 0, 200)
 
# draggable control points
c1 = obj2d(shapedefs.circle(4), "SHAPE", {"fillColor":'red'})
c1.enableDrag(None, dragC1, None)
c2 = c1.dup()
c2.enableDrag(None, dragC2, None)
c3 = c1.dup()
c3.enableDrag(None, dragC3, None)
drawCurve();
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
'''
    return outstring</t>
<t tx="amd.20151125094850.1">/*=================================================================
  Filename: Cango-7v13.js
  Rev: 7
  By: A.R.Collins
  Description: A graphics library for the canvas element.
  License: Released into the public domain
  latest version at
  &lt;http://www/arc.id.au/CanvasGraphics.html&gt;
  Report bugs to tony at arc.id.au

  Date   |Description                                          |By
  -----------------------------------------------------------------
  14Oct12 Rev 1.00 First release based on Cango0v43             ARC
  29Nov12 Released as Cango2v00                                 ARC
  06May14 Released as Cango4v00                                 ARC
  14Jul14 Released as Cango-5v00                                ARC
  09Feb15 Released as Cango-6v00                                ARC
  14Feb15 bugfix: bad conversion from world coords for
          linearGradientFill and radialGradientFill             ARC
  15Feb15 Add LinearGradient and RadialGraient global objects
          Drop lineraGradientFill &amp; radialGradientFill methods  ARC
  16Feb15 Drop setDropShadow method just use Cobj properties    ARC
  20Feb15 Use re-written functional style cgo2DtoDrawCmd
          Remove ugly 'Array.isArray' - use isArray(obj)        ARC
  21Feb15 Insert flags for inverted Y axis version              ARC
  22Feb15 Use re-written functional style svgToCgo2D            ARC
  01Mar15 Moved SVG sweep flip to toCangoVersion                ARC
  07Mar15 Added setViewportSVG to support inverted coordinates  ARC
  08Mar15 Add svgToCgoSVG to convert to array with Bezier but
          leaving Y coords and sweep values as untouched.       ARC
  09Mar15 Change DrawCmd parms to be [[x,y],[x1,y1], ... ] so
          reduce and forEach can be used to clean up code       ARC
  11Mar15 Added heightPW and widthPW                            ARC
  12Mar15 Dropped toViewportCoords method                       ARC
  14Mar15 Drop setViewport, use setGridboxRHC and setGridboxSVG ARC
  18Mar15 Added cgoRHCtoSVG as a global untility function       ARC
  20Mar15 bugfix: Gradients for path/shapes not converted from
          world coords to pixels before use.
          Cobj.setProperty ignored iso set false request after
          a set true                                            ARC
  20Mar15 Released as Cango 7v00                                ARC
  23Mar15 Change to late Image load                             ARC
  09Aug15 Created Path,Shape,Img &amp; Text types                   ARC
          Don't wait till render time to load images            ARC
  21Sep15 bugfix: IMG and TEXT translate Y coord sign flipped   ARC
  28Sep15 bugfix: toImgObj putting Image in drawCmds not imgBuf ARC
  =================================================================*/

var Cobj, LinearGradient, RadialGradient, DrawCmd, svgToCgoRHC, svgToCgoSVG, cgoRHCtoSVG, shapeDefs;

var Cango = (function()
{
  "use strict";

  var uniqueVal = 0,  // used to generate unique value for different Cango instances
      svgParser,
      cgo2DtoDrawCmd;

  function addEvent(element, eventType, handler)
  {
    if (element.attachEvent)
    {
     return element.attachEvent('on'+eventType, handler);
    }
    return element.addEventListener(eventType, handler, true);
  }

  function clone(orgItem)
  {
    var newItem = (Array.isArray(orgItem)) ? [] : {},
        i;
    for (i in orgItem)
    {
      if (orgItem[i] &amp;&amp; typeof orgItem[i] === "object")
      {
        newItem[i] = clone(orgItem[i]);
      }
      else
      {
        newItem[i] = orgItem[i];
      }
    }
    return newItem;
  }

  function isArray(obj)
  {
    return Object.prototype.toString.call(obj) === '[object Array]';
  }

  function isNumber(o)
  {
    return !isNaN(o) &amp;&amp; o !== null &amp;&amp; o !== "" &amp;&amp; o !== false;
  }

  function flatten(obj)
  {
    if (!isArray(obj))
    {
      return([obj]);
    }
    return obj.reduce(function(prev, curr) {
      var more = [].concat(curr).some(isArray);
      return prev.concat(more ? flatten(curr) : curr);
    },[]);
  }

  /* =============================================================================
   * Convert Cgo2D data array ['M',x,y, 'L',x1,y1, ... 'Q',cx,cy,x2,y2, 'A',r,r ...]
   * to array of canvas DrawCmd {drawFn:'moveTo', [x,y]}
   * ----------------------------------------------------------------------------*/
  svgParser = (function ()
  {
    var segmentToBezier = function(cx, cy, th0, th1, rx, ry, sin_th, cos_th) {
          var a00 = cos_th * rx,
              a01 = -sin_th * ry,
              a10 = sin_th * rx,
              a11 = cos_th * ry,
              th_half = 0.5 * (th1 - th0),
              t = (8/3) * Math.sin(th_half * 0.5) * Math.sin(th_half * 0.5) / Math.sin(th_half),
              x1 = cx + Math.cos(th0) - t * Math.sin(th0),
              y1 = cy + Math.sin(th0) + t * Math.cos(th0),
              x3 = cx + Math.cos(th1),
              y3 = cy + Math.sin(th1),
              x2 = x3 + t * Math.sin(th1),
              y2 = y3 - t * Math.cos(th1);

          return [ a00 * x1 + a01 * y1, a10 * x1 + a11 * y1,
                   a00 * x2 + a01 * y2, a10 * x2 + a11 * y2,
                   a00 * x3 + a01 * y3, a10 * x3 + a11 * y3 ];
        },
        arcToBezier = function(ox, oy, radx, rady, rotateX, large, sweep, x, y)
        {
          var th = rotateX * (Math.PI/180),
              sin_th = Math.sin(th),
              cos_th = Math.cos(th),
              rx = Math.abs(radx),
              ry = Math.abs(rady),
              px = cos_th * (ox - x) * 0.5 + sin_th * (oy - y) * 0.5,
              py = cos_th * (oy - y) * 0.5 - sin_th * (ox - x) * 0.5,
              pl = (px*px) / (rx*rx) + (py*py) / (ry*ry),
              a00, a01, a10, a11,
              x0, y0, x1, y1,
              d,
              sfactor_sq,
              sfactor,
              xc, yc,
              th0, th1,
              th_arc,
              segments,
              seg, tidySeg,
              result = [],
              i, th2, th3;

          function roundZeros(coord)
          {
            return ((Math.abs(coord) &lt; 0.00001)? 0: coord);
          }

          if (pl &gt; 1)
          {
            pl = Math.sqrt(pl);
            rx *= pl;
            ry *= pl;
          }
          a00 = cos_th / rx;
          a01 = sin_th / rx;
          a10 = -sin_th / ry;
          a11 = cos_th / ry;
          x0 = a00 * ox + a01 * oy;
          y0 = a10 * ox + a11 * oy;
          x1 = a00 * x + a01 * y;
          y1 = a10 * x + a11 * y;
          d = (x1-x0) * (x1-x0) + (y1-y0) * (y1-y0);
          sfactor_sq = 1 / d - 0.25;
          if (sfactor_sq &lt; 0)
          {
            sfactor_sq = 0;
          }
          sfactor = Math.sqrt(sfactor_sq);
          if (sweep === large)
          {
            sfactor = -sfactor;
          }
          xc = 0.5 * (x0 + x1) - sfactor * (y1-y0);
          yc = 0.5 * (y0 + y1) + sfactor * (x1-x0);
          th0 = Math.atan2(y0-yc, x0-xc);
          th1 = Math.atan2(y1-yc, x1-xc);
          th_arc = th1-th0;
          if (th_arc &lt; 0 &amp;&amp; sweep === 1)
          {
            th_arc += 2*Math.PI;
          }
          else if (th_arc &gt; 0 &amp;&amp; sweep === 0)
          {
            th_arc -= 2 * Math.PI;
          }
          segments = Math.ceil(Math.abs(th_arc / (Math.PI * 0.5 + 0.001)));
          for (i=0; i&lt;segments; i++)
          {
            th2 = th0 + i * th_arc / segments;
            th3 = th0 + (i+1) * th_arc / segments;
            seg = segmentToBezier(xc, yc, th2, th3, rx, ry, sin_th, cos_th);
            tidySeg = seg.map(roundZeros);
            result.push(tidySeg);
          }

          return result;
        },
        /*===============================================
         *
         * svgProtocol object defining each command
         * with methods to convert to Cgo2D for both
         * cartesian and SVG coordinate systems
         *
         *==============================================*/
        svgProtocol = {
          "M": {
            canvasMethod: "moveTo",
            parmCount: 2,
            extCmd: "L",
            toAbs: function(acc, curr) {
              var cmd = curr[0].toUpperCase(),  // uppercase command means absolute coords
                  x = curr[1],
                  y = curr[2],
                  currAbs;
              // Check if 'curr' was a relative (lowercase) command
              if (cmd !== curr[0]) {
                x += acc.px;
                y += acc.py;
              }
              currAbs = [cmd, x, y];
              acc.px = x;
              acc.py = y;
              return currAbs;
            },
            toCangoVersion: function(acc, curr) {
              var x = curr[1],
                  y = curr[2];

              acc.px = x;  // update the pen position for next command
              acc.py = y;
              acc.push(curr); // push the curr, "M" is a Cango internal command
            },
            addXYoffset: function(curr, xOfs, yOfs){
              var x = curr[1],
                  y = curr[2];

              x += xOfs;
              y += yOfs;
              return ["M", x, y];   // invert y coords to make Cgo2D format
            },
            invertCoords: function(curr){
              var x = curr[1],
                  y = curr[2];

              return ["M", x, -y];   // invert y coords to make Cgo2D format
            }
          },
          "L": {
            canvasMethod: "lineTo",
            parmCount: 2,
            extCmd: "L",
            toAbs: function(acc, curr) {
              var cmd = curr[0].toUpperCase(),  // uppercase command means absolute coords
                  x = curr[1],
                  y = curr[2],
                  currAbs;
              // Check if 'curr' was a relative (lowercase) command
              if (cmd !== curr[0]) {
                x += acc.px;
                y += acc.py;
              }
              currAbs = [cmd, x, y];
              acc.px = x;
              acc.py = y;
              return currAbs;
            },
            toCangoVersion: function(acc, curr) {
              var x = curr[1],
                  y = curr[2];

              acc.px = x;  // update the pen position for next command
              acc.py = y;
              acc.push(curr); // push the curr, "L" is a Cango internal command
            },
            addXYoffset: function(curr, xOfs, yOfs){
              var x = curr[1],
                  y = curr[2];

              x += xOfs;
              y += yOfs;
              return ["L", x, y];   // invert y coords to make Cgo2D format
            },
            invertCoords: function(curr){
              var x = curr[1],
                  y = curr[2];

              return ["L", x, -y];   // invert y coords to make Cgo2D format
            }
          },
          "H": {
            parmCount: 1,
            extCmd: "H",
            toAbs: function(acc, curr) {
              var cmd = curr[0].toUpperCase(),   // uppercase command means absolute coords
                  x = curr[1],
                  currAbs;
              // Check if 'curr' was a relative (lowercase) command
              if (cmd !== curr[0]) {
                x += acc.px;
              }
              currAbs = [cmd, x];
              acc.px = x;        // save the new pen position
              return currAbs;
            },
            toCangoVersion: function(acc, curr) {
              var x = curr[1],
                  y = acc.py,
                  cangoVer = ["L", x, y];

              acc.px = x;        // save the new pen position
              acc.push(cangoVer);
            },
            addXYoffset: function(curr, xOfs, yOfs){
              var x = curr[1];

              x += xOfs;
              return ["H", x];
            },
            invertCoords: function(curr){
              var x = curr[1];

              return ["H", x];
            }
          },
          "V": {
            parmCount: 1,
            extCmd: "V",
            toAbs: function(acc, curr) {
              var cmd = curr[0].toUpperCase(),   // uppercase command means absolute coords
                  y = curr[1],
                  currAbs;
              // Check if 'curr' was a relative (lowercase) command
              if (cmd !== curr[0]) {
                y += acc.py;
              }
              currAbs = [cmd, y];
              acc.py = y;        // save the new pen position
              return currAbs;
            },
            toCangoVersion: function(acc, curr) {
              var x = acc.px,
                  y = curr[1],
                  cangoVer = ["L", x, y];

              acc.py = y;        // save the new pen position
              acc.push(cangoVer);
            },
            addXYoffset: function(curr, xOfs, yOfs){
              var y = curr[1];

              y += yOfs;
              return ["V", y];    // invert y coords to make Cgo2D format
            },
            invertCoords: function(curr){
              var y = curr[1];

              return ["V", -y];    // invert y coords to make Cgo2D format
            }
          },
          "C": {       // Cubic Bezier curve
            canvasMethod: "bezierCurveTo",
            parmCount: 6,
            extCmd: "C",
            toAbs: function(acc, curr) {
              var cmd = curr[0].toUpperCase(),  // uppercase command means absolute coords
                  c1x = curr[1],
                  c1y = curr[2],
                  c2x = curr[3],
                  c2y = curr[4],
                  x = curr[5],
                  y = curr[6],
                  currAbs;
              // Check if 'curr' was a relative (lowercase) command
              if (cmd !== curr[0]) {
                c1x += acc.px;
                c1y += acc.py;
                c2x += acc.px;
                c2y += acc.py;
                x += acc.px;
                y += acc.py;
              }
              currAbs = [cmd, c1x, c1y, c2x, c2y, x, y];
              acc.px = x;
              acc.py = y;
              return currAbs;
            },
            toCangoVersion: function(acc, curr) {
              var x = curr[5],
                  y = curr[6];

              acc.px = x;  // update the pen position for next command
              acc.py = y;
              acc.push(curr); // push the curr, "C" is a Cango internal command
            },
            addXYoffset: function(curr, xOfs, yOfs){
              var c1x = curr[1],
                  c1y = curr[2],
                  c2x = curr[3],
                  c2y = curr[4],
                  x = curr[5],
                  y = curr[6];

                c1x += xOfs;
                c1y += yOfs;
                c2x += xOfs;
                c2y += yOfs;
                x += xOfs;
                y += yOfs;
              return ["C", c1x, c1y, c2x, c2y, x, y]; // invert y coords
            },
            invertCoords: function(curr){
              var c1x = curr[1],
                  c1y = curr[2],
                  c2x = curr[3],
                  c2y = curr[4],
                  x = curr[5],
                  y = curr[6];

              return ["C", c1x, -c1y, c2x, -c2y, x, -y]; // invert y coords
            }
          },
          "S": {         // Smooth cubic Bezier curve
            parmCount: 4,
            extCmd: "S",
            toAbs: function(acc, curr) {
              var cmd = curr[0].toUpperCase(),  // uppercase means absolute coords
                  c2x = curr[1],
                  c2y = curr[2],
                  x = curr[3],
                  y = curr[4],
                  currAbs;

              // Check if 'curr' was a relative (lowercase) command
              if (cmd !== curr[0]) {
                c2x += acc.px;
                c2y += acc.py;
                x += acc.px;
                y += acc.py;
              }
              currAbs = [cmd, c2x, c2y, x, y];
              acc.px = x;
              acc.py = y;
              return currAbs;
            },
            toCangoVersion: function(acc, curr, idx) {
              var c1x = 0,    // relative coords of first (mirrored) control point
                  c1y = 0,
                  c2x = curr[1],
                  c2y = curr[2],
                  x = curr[3],
                  y = curr[4],
                  prevSeg = acc[idx-1],
                  cangoVer;

              // if prev segment was a cubic Bezier, mirror its last control point as cp1
              if (prevSeg[0] === "C")              {
                c1x = acc.px - prevSeg[prevSeg.length-4];   // relative coords of cp1
                c1y = acc.py - prevSeg[prevSeg.length-3];
              }
              // make cp1 absolute (all the curr coords are already absolute)
              c1x += acc.px;
              c1y += acc.py;
              cangoVer = ["C", c1x, c1y, c2x, c2y, x, y];  // Cubic Bezier
              acc.px = x;  // update the pen position for next command
              acc.py = y;
              acc.push(cangoVer);
            },
            addXYoffset: function(curr, xOfs, yOfs){
              var c2x = curr[1],
                  c2y = curr[2],
                  x = curr[3],
                  y = curr[4];

              c2x += xOfs;
              c2y += yOfs;
              x += xOfs;
              y += yOfs;
              return ["S", c2x, c2y, x, y];    // invert y coords to make Cgo2D format
            },
            invertCoords: function(curr){
              var c2x = curr[1],
                  c2y = curr[2],
                  x = curr[3],
                  y = curr[4];

              return ["S", c2x, -c2y, x, -y];    // invert y coords to make Cgo2D format
            }
          },
          "Q": {         // Quadratic Bezier curve
            canvasMethod: "quadraticCurveTo",
            parmCount: 4,
            extCmd: "Q",
            toAbs: function(acc, curr) {
              var cmd = curr[0].toUpperCase(),  // uppercase command means absolute coords
                  c1x = curr[1],
                  c1y = curr[2],
                  x = curr[3],
                  y = curr[4],
                  currAbs;
              // Check if 'curr' was a relative (lowercase) command
              if (cmd !== curr[0]) {
                c1x += acc.px;
                c1y += acc.py;
                x += acc.px;
                y += acc.py;
              }
              currAbs = [cmd, c1x, c1y, x, y];
              acc.px = x;
              acc.py = y;
              return currAbs;
            },
            toCangoVersion: function(acc, curr) {
              var x = curr[3],
                  y = curr[4];

              acc.px = x;  // update the pen position for next command
              acc.py = y;
              acc.push(curr); // push the curr, "Q" is a Cango internal command
            },
            addXYoffset: function(curr, xOfs, yOfs){
              var c1x = curr[1],
                  c1y = curr[2],
                  x = curr[3],
                  y = curr[4];

              c1x += xOfs;
              c1y += yOfs;
              x += xOfs;
              y += yOfs;
              return ["Q", c1x, c1y, x, y];    // invert y coords to make Cgo2D format
            },
            invertCoords: function(curr){
              var c1x = curr[1],
                  c1y = curr[2],
                  x = curr[3],
                  y = curr[4];

              return ["Q", c1x, -c1y, x, -y];    // invert y coords to make Cgo2D format
            }
          },
          "T": {         // Smooth Quadratic Bezier curve
            parmCount: 2,
            extCmd: "T",
            toAbs: function(acc, curr) {
              var cmd = curr[0].toUpperCase(),  // uppercase means absolute coords
                  x = curr[1],
                  y = curr[2],
                  currAbs;

              // Check if 'curr' was a relative (lowercase) command
              if (cmd !== curr[0]) {
                x += acc.px;
                y += acc.py;
              }
              currAbs = [cmd, x, y];
              acc.px = x;
              acc.py = y;
              return currAbs;
            },
            toCangoVersion: function(acc, curr, idx) {
              var c1x = 0,    // relative coords of first (mirrored) control point
                  c1y = 0,
                  x = curr[1],
                  y = curr[2],
                  prevSeg = acc[idx-1],
                  cangoVer;

              // if prev segment was quadratic Bezier, mirror its last control point as cp1
              if (prevSeg[0] === "Q")            {
                c1x = acc.px - prevSeg[prevSeg.length-4];   // relative coords of first cp1
                c1y = acc.py - prevSeg[prevSeg.length-3];
              }
              // make cp1 absolute
              c1x += acc.px;
              c1y += acc.py;
              cangoVer = ["Q", c1x, c1y, x, y];   // Quadratic Bezier
              acc.px = x;  // update the pen position for next command
              acc.py = y;
              acc.push(cangoVer);
            },
            addXYoffset: function(curr, xOfs, yOfs){
              var x = curr[1],
                  y = curr[2];

              x += xOfs;
              y += yOfs;
              return ["T", x, y];    // invert y coords to make Cgo2D format
            },
            invertCoords: function(curr){
              var x = curr[1],
                  y = curr[2];

              return ["T", x, -y];    // invert y coords to make Cgo2D format
            }
          },
          "A" : {      // Circular arc
            parmCount: 7,
            extCmd: "A",
            toAbs: function(acc, curr) {
              var cmd = curr[0].toUpperCase(),
                  rx = curr[1],
                  ry = curr[2],
                  xrot = curr[3],     // opposite to SVG in Cartesian coords
                  lrg = curr[4],
                  swp = curr[5],      // opposite to SVG in Cartesian coords
                  x = curr[6],
                  y = curr[7],
                  currAbs;
              // Check if current is a relative (lowercase) command
              if (cmd !== curr[0]) {
                x += acc.px;
                y += acc.py;
              }
              currAbs = [cmd, rx, ry, xrot, lrg, swp, x, y];
              acc.px = x;
              acc.py = y;
              return currAbs;
            },
            toCangoVersion: function(acc, curr) {
              var rx = curr[1],
                  ry = curr[2],
                  xrot = curr[3],     // opposite to SVG in Cartesian coords
                  lrg = curr[4],
                  swp = curr[5],      // opposite to SVG in Cartesian coords
                  x = curr[6],
                  y = curr[7],
                  sectors;

              // convert to (maybe multiple) cubic Bezier curves
              sectors = arcToBezier(acc.px, acc.py, rx, ry, xrot, lrg, swp, x, y);
              // sectors is an array of arrays of Cubic Bezier coords,
              // make a 'C' command from each sector and push it out
              sectors.forEach(function(coordAry){
                acc.push(["C"].concat(coordAry));
              });

              acc.px = x;  // update the pen position for next command
              acc.py = y;
            },
            addXYoffset: function(curr, xOfs, yOfs){
              var rx = curr[1],
                  ry = curr[2],
                  xrot = curr[3],
                  lrg = curr[4],
                  swp = curr[5],
                  x = curr[6],
                  y = curr[7];

              x += xOfs;
              y += yOfs;
              return ["A", rx, ry, xrot, lrg, swp, x, y];  // invert y coords
            },
            invertCoords: function(curr){
              var rx = curr[1],
                  ry = curr[2],
                  xrot = curr[3],
                  lrg = curr[4],
                  swp = curr[5],
                  x = curr[6],
                  y = curr[7];

              return ["A", rx, ry, -xrot, lrg, 1-swp, x, -y];  // invert coords
            }
          },
          "Z": {
            canvasMethod: "closePath",
            parmCount: 0,
            toAbs: function(acc, curr) {
              var cmd = curr[0].toUpperCase(),
                  currAbs = [cmd];
              // leave pen position where it is in case of multi-segment path
              return currAbs;
            },
            toCangoVersion: function(acc, curr) {
              // leave pen position where it is in case of multi-segment path
              acc.push(curr); // push the curr, "Z", its a Cango internal command
            },
            addXYoffset: function(curr, xOfs, yOfs){
              return ["Z"];
            },
            invertCoords: function(curr){
              return ["Z"];
            }
          }
        };
    // ========= end of vars =========

    /*==================================================
     * svgCmdCheck (a function for use with Array.reduce)
     * -------------------------------------------------
     * Checks each element, if a string it must be
     * one of the keys in the SVG proptocol. If no bad
     * cmds found then the array is returned without
     * alteration, if not an empty array is returned.
     *=================================================*/
    function svgCmdCheck(acc, current, idx)
    {
      // make a concession to SVG standard and allow all number array
      if (idx === 0)
      {
        if (typeof current !== 'string')
        {
          acc.push("M");
          // now we will fall through to normal checking
        }
      }
      // if we see a command string, check it is in SVG protocol
      if (typeof current === "string") {  // check each string element
        if (!svgProtocol.hasOwnProperty(current.toUpperCase()))
        {
          console.log("unknown command string '"+current+"'");
          acc.badCmdFound = true;
          acc.length = 0;   // any bad command will force e,pty array to be retruned
        }
      }
      if (!acc.badCmdFound)
      {
        acc.push(current);
      }
      // always return when using reduce...
      return acc;
    }

    /*======================================================
     * unExtend  (a function for use with Array.reduce)
     * -----------------------------------------------------
     * Undo the extension of commands given the svg protocol.
     * Each entry in the protocol has an extCmd property which
     * is usually the same as the command key but for "M"
     * which may be extended by a series of "L" commands.
     * Extending a command means that multiple sets of paramaeters
     * may follow a command letter without the need to repeat
     * the command letter in front of each set eg.
     * The 'reduce' accumulator is used to hold the current
     * command as a property (not an array elemet) and make it
     * available to the next element.
     *
     * var a = ['M', 1, 2, 'L', 3, 4, 5, 6, 7, 8, 'A', 5, 6, 7, 8, 3, 0, 2]
     * var b = a.reduce(unExtend, [])
     *
     * &gt;&gt; ['M', 1, 2, 'L', 3, 4, 'L', 5, 6, 'L', 7, 8, 'A', 5, 6, 7, 8, 3, 0, 2]
     *
     * This assumes no invalid commands are in the string -
     * so array should be sanitized before running unExtend
     *======================================================*/
    function unExtend(acc, current, idx, ary)
    {
      var newCmd;

      if (idx === 0)
      {
        acc.nextCmdPos = 0;  // set expected position of next command string as first element
      }
      // Check if current is a command in the protocol (protocol only indexed by upperCase)
      if (typeof current === 'string')
      {
        if (idx &lt; acc.nextCmdPos)
        {
          // we need another number but found a string
          console.log("bad number of parameters for '"+current+"' at index "+idx);
          acc.badParameter = true;  // raise flag to bailout processing this
          acc.push(0);  // try to get out without crashing (acc data will be ditched any way)
          return acc;
        }
        // its a command the protocol knows, remember it across iterations of elements
        acc.currCmd = current.toUpperCase();  // save as a property of the acc Array object (not an Array element)
        acc.uc = (current.toUpperCase() === current);  // upperCase? true or false
        // calculate where the next command should be
        acc.nextCmdPos = idx + svgProtocol[acc.currCmd].parmCount + 1;
        acc.push(current);
      }
      else if (idx &lt; acc.nextCmdPos)   // processing parameters
      {
        // keep shoving parameters
        acc.push(current);
      }
      else
      {
        // we have got a full set of paramaters but hit another number
        // instead of a command string, it must be a command extention
        // push a the extension command (same as current except for M which extend to L)
        // into the accumulator
        acc.currCmd = svgProtocol[acc.currCmd].extCmd;  // NB: don't change the acc.uc boolean
        newCmd = (acc.uc)? acc.currCmd: acc.currCmd.toLowerCase();
        acc.push(newCmd, current);
        // calculate where the next command should be
        acc.nextCmdPos = idx + svgProtocol[acc.currCmd].parmCount;
      }

      if (idx === ary.length-1)   // done processing check if all was ok
      {
        if (acc.badParameter)
        {
          acc.length = 0;
        }
      }
      // always return when using reduce...
      return acc;
    }

    /*==================================================
     * svgCmdSplitter (a function for use with Array.reduce)
     * -------------------------------------------------
     * Split an array on a string type element, e.g.
     *
     * var a = ['a', 1, 2, 'b', 3, 4, 'c', 5, 6, 7, 8]
     * var b = a.reduce(svgCmdSplitter, [])
     *
     * &gt;&gt; [['a', 1, 2],['b', 3, 4], ['c', 5, 6, 7, 8]]
     *
     *=================================================*/
    function svgCmdSplitter(acc, curr)
    {
      // if we see a command string, start a new array element
      if (typeof curr === "string") {
          acc.push([]);
      }
      // add this element to the back of the acc's last array
      acc[acc.length-1].push(curr);
      // always return when using reduce...
      return acc;
    }

    /*===========================================================
     * toAbsoluteCoords  (a function for use with Array.reduce)
     * ----------------------------------------------------------
     * Reduce is needed even though the same size elements are
     * returned because the accumulator is used to hold the pen
     * x,y coords and make them available to the next element.
     * Assumes 'current' argument is an array of form ["M", 2, 7]
     * if command letter is lower case the protocol.toAbs
     * function will add the current pen x and y values to
     * the coordinates and update the pen x, y. The
     * absolute coord version of the cmd and its coords will
     * be returned and then pushed into acc.
     *
     * eg. ['M', 1, 2, 'l', 3, 4, 'a', 5, 6, 7, 8, 3, 0, 2, 'z']
     * &gt;&gt;  ['M', 1, 2, 'L', 4, 6, 'A', 5, 6, 7, 8, 3, 4, 8, 'Z']
     *===========================================================*/
    function toAbsoluteCoords(acc, current, idx)
    {
      var currCmd, currAbs;

      if (acc.px === undefined)
      {
        acc.px = 0;
        acc.py = 0;
      }
      // get protocol object for this command, indexed by uppercase only
      currCmd = svgProtocol[current[0].toUpperCase()];
      // call protocol toAbs function for this command
      // it returns absolute coordinate version based on current
      // pen position stored in acc.px, acc.py
      currAbs = currCmd.toAbs(acc, current, idx);
      acc.push(currAbs);
      // always return when using reduce...
      return acc;
    }

    /*==================================================================================
     * toCangoCmdSet  (a function for use with Array.reduce)
     * ---------------------------------------------------------------------------------
     * Assumes 'current' argument is an array of form ["M", 2, 7]
     * All commands letters are uppercase and all coordinates
     * are absolute (referenced to world coordinate origin).
     * This function will convert "H", "V", "S", "T", and "A"
     * commands to Cango internal command set "M", "L", "Q", "C", "Z"
     * All coordinates will be returned in separate array
     *
     * eg. [['M', 1, 2], ['L', 3, 4], ['H', 3], ['A', 5, 6, 7, 8, 3, 0, 2], ['Z']]
     * &gt;&gt;  [['M', 1, 2], [['L', 3, 4], ['L', 3, 4], ['C', cp, cp, cp, cp, x, y], ['Z']]
     *==================================================================================*/
    function toCangoCmdSet(acc, current, idx)
    {
      var currCmd = current[0],
          currSvgObj = svgProtocol[currCmd];

      // call protocol toCangoVersion function for this command
      // it converts all SVG to just "M", "L", "Q", "C", "Z" command and coords
      // and pushes them into the acc
      currSvgObj.toCangoVersion(acc, current, idx);
      // always return when using reduce...
      return acc;
    }

    /*==============================================
     * toDrawCmds  (a function for use with Array.reduce)
     * ----------------------------------------------
     * Convert a Cgo2D data array to an array
     * of Cango DrawCmd objects e.g.
     *
     * [['M', 0.1, 0.2], ['L', 1, 2, 'C', 3, 4, 5, 6, 2, 9], ['Z']]
     *
     * will become
     * [{ drawFn: "moveTo",
     *    parms: [0.1, 0.2],
     *    ...
     *  },
     *  { drawFn: "lineTo",
     *    parms: [1, 2],
     *    ...
     *  },
     *  ...
     *  ]
     *
     *===============================================*/
    function toDrawCmds(current)
    {
      // first element is a command...
      var cmd = current[0],   // grab command string
          parameters = current.slice(1); // make an array of the rest

      // the array elements have been checked as all valid
      // make a new element starting with an empty array
      return new DrawCmd(svgProtocol[cmd].canvasMethod, parameters);
    }

    /*==================================================
     * strToCgo2D (a function for use with Array.reduce)
     * -------------------------------------------------
     * Assumes 'current' argument is a string of form
     * "M  2 7" or "v 7  " or "z" which always has a
     * command string as the first character
     * and the rest is numbers separated by white space
     * This function will reduce (combine) to a single
     * array in Cgo2D format ["M", 2, 7, "v", 7, "z"]
     *=================================================*/
    function strToCgo2D(acc, current)
    {
      var cmd = current[0],
          parmsStr, numberStrs;

      // push the single char command as an element
      acc.push(cmd);
      // strip off the front cmd
      parmsStr = current.slice(1);
      // convert to an array of strings, each one number
      numberStrs = parmsStr.match(/\S+/g);   // returns null if no matches (not empty array)
      if (numberStrs)      // z has no numbers to follow
      {
        // parse each to a float and push it into acc
        numberStrs.forEach(function(s){
          var num = parseFloat(s);
          if (!isNaN(num))
          {
            acc.push(num);
          }
        });
      }
      // always return when using reduce...
      return acc;
    }

    /*===========================================================
     * flipCoords  (a function for use with Array.map)
     * ----------------------------------------------------------
     * Assumes 'current' argument is an array of form ["M", 2, 7]
     * All coordinates will be be in absolute format
     * The protocol will have an 'invertCoords' method for each
     * possible command key this will return the current array
     * with the sign of the Y coords flipped and sense of arcs reversed
     * reversed
     *
     * current = ['A', 2, 2,  30, 0, 1, 3,  4]
     *       &gt;&gt;  ['A', 2, 2, -30, 0, 0, 3, -4]
     *===========================================================*/
    function flipCoords(current)
    {
      var currCmd = current[0],
          currSvgObj = svgProtocol[currCmd];

      // call protocol.invertCoords function for this command
      // it flips the sign of the y coords, for 'A' commands it flips
      // sweep and xRotation values and returns the modified array
      return currSvgObj.invertCoords(current);
    }

    /*===========================================================
     * translateOrigin  (a function for use with Array.map)
     * ----------------------------------------------------------
     * Assumes it is called with 'this' object having
     * properties {xOfs: value, yOfs: value}
     * Assumes 'current' argument is an array of form ["M", 2, 7]
     * All coordinates will be be in absolute format
     * The protocol will have an 'addXYoffset method for each
     * possible command key this will return the current array
     * with the X and Y offsets added to the coordinate elements.
     *
     * eg. if 'this = {xOfs: 100, yOfs: 10}
     * current = ['M', 1, 2]
     * &gt;&gt;  ['M', 101, 12]
     *===========================================================*/
    function translateOrigin(current)
    {
      var currCmd = current[0],
          currSvgObj = svgProtocol[currCmd],
          xofs = this.xOfs || 0,
          yofs = this.yOfs || 0;

      return currSvgObj.addXYoffset(current, xofs, yofs);
    }

    /*===========================================================
     * flatten2Dary  (a function for use with Array.reduce)
     * ----------------------------------------------------------
     * Assumes curr is an array, push each element into the acc
     * to form a 1D array.

     * eg. [['M', 1, 2], ['V',2],['Z']]
     * &gt;&gt;  ['M', 1, 2, 'V', 2, 'Z']
     *===========================================================*/
    function flatten2Dary(acc, curr){
      return acc.concat(curr);
    }

    // auto run this code to create this object holding the two translator fns
    // and return it as the svgParser
    return {
      svg2cartesian: function(svgStr, xShft, yShft) {
        var dx = xShft || 0,
            dy = yShft || 0,
            noCommas,
            cmdStrs;

        if ((typeof svgStr !== 'string')||(svgStr.length === 0))
        {
          return [];
        }
        // this SVG processor can handle comma separated or whitespace separated or mixed
        // replace any commas with spaces
        noCommas = svgStr.replace(new RegExp(',', 'g'), ' ');
        // now we have a string of commands and numbers separated by whitespace
        // split it at command chars
        cmdStrs = noCommas.split(/(?=[a-df-z])/i);  // avoid e in exponents

        return cmdStrs.reduce(strToCgo2D, [])
                      .reduce(svgCmdCheck, [])
                      .reduce(unExtend, [])
                      .reduce(svgCmdSplitter, [])
                      .reduce(toAbsoluteCoords, [])
                      .map(translateOrigin, {xOfs: dx, yOfs: dy})
                      .map(flipCoords)
                      .reduce(flatten2Dary, []);
      },
      svg2cgosvg: function(svgStr, xShft, yShft) {
        var dx = xShft || 0,
            dy = yShft || 0,
            noCommas,
            cmdStrs;

        if ((typeof svgStr !== 'string')||(svgStr.length === 0))
        {
          return [];
        }
        // this SVG processor can handle comma separated or whitespace separated or mixed
        // replace any commas with spaces
        noCommas = svgStr.replace(new RegExp(',', 'g'), ' ');
        // now we have a string of commands and numbers separated by whitespace
        // split it at command chars
        cmdStrs = noCommas.split(/(?=[a-df-z])/i);  // avoid e in exponents

        return cmdStrs.reduce(strToCgo2D, [])
                      .reduce(svgCmdCheck, [])
                      .reduce(unExtend, [])
                      .reduce(svgCmdSplitter, [])
                      .reduce(toAbsoluteCoords, [])
                      .map(translateOrigin, {xOfs: dx, yOfs: dy})
                      .reduce(flatten2Dary, []);
      },
      cartesian2svg: function(cgoAry){
        return cgoAry.reduce(unExtend, [])
                     .reduce(svgCmdSplitter, [])
                     .reduce(toAbsoluteCoords, [])
                     .map(flipCoords)
                     .reduce(flatten2Dary, []).toString();
      },
      cgo2drawcmds: function(cgo2Dary) {
        if (!isArray(cgo2Dary) || (cgo2Dary.length === 0))
        {
          return [];
        }
        return cgo2Dary.reduce(svgCmdCheck, [])
                       .reduce(unExtend, [])
                       .reduce(svgCmdSplitter, [])
                       .reduce(toAbsoluteCoords, [])
                       .reduce(toCangoCmdSet, [])
                       .map(toDrawCmds);

      }
    };

  }());

  svgToCgoRHC = svgParser.svg2cartesian;

  svgToCgoSVG = svgParser.svg2cgosvg;

  cgoRHCtoSVG = svgParser.cartesian2svg;

  cgo2DtoDrawCmd = svgParser.cgo2drawcmds;

  if (shapeDefs === undefined)
  {
    shapeDefs = {'circle': function(diameter){
                            var d = diameter || 1;
                            return ["m", -0.5*d,0,
                            "c", 0,-0.27614*d, 0.22386*d,-0.5*d, 0.5*d,-0.5*d,
                            "c", 0.27614*d,0, 0.5*d,0.22386*d, 0.5*d,0.5*d,
                            "c", 0,0.27614*d, -0.22386*d,0.5*d, -0.5*d,0.5*d,
                            "c", -0.27614*d,0, -0.5*d,-0.22386*d, -0.5*d,-0.5*d];},

                'ellipse': function(width, height){
                            var w = width || 1,
                                h = w;
                            if ((typeof height === 'number')&amp;&amp;(height&gt;0))
                            {
                              h = height;
                            }
                            return ["m", -0.5*w,0,
                            "c", 0,-0.27614*h, 0.22386*w,-0.5*h, 0.5*w,-0.5*h,
                            "c", 0.27614*w,0, 0.5*w,0.22386*h, 0.5*w,0.5*h,
                            "c", 0,0.27614*h, -0.22386*w,0.5*h, -0.5*w,0.5*h,
                            "c", -0.27614*w,0, -0.5*w,-0.22386*h, -0.5*w,-0.5*h];},

                'square': function(width){
                            var w = width || 1;
                            return ['m', 0.5*w, -0.5*w, 'l', 0, w, -w, 0, 0, -w, 'z'];},

                'rectangle': function(w, h, rad){
                            var m = 0.55228475,                 // magic number for drawing circle with 4 Bezier curve
                                r;
                            if ((rad === undefined)||(rad&lt;=0))
                            {
                              return ["m",-w/2,-h/2, "l",w,0, 0,h, -w,0, 'z'];
                            }
                            r = Math.min(w/2, h/2, rad);
                            return ["m", -w/2+r,-h/2, "l",w-2*r,0,  "c",m*r,0, r,(1-m)*r, r,r,
                                                      "l",0,h-2*r,  "c",0,m*r,(m-1)*r,r,-r,r,
                                                      "l",-w+2*r,0, "c",-m*r,0,-r,(m-1)*r,-r,-r,
                                                      "l",0,-h+2*r, "c",0,-m*r,(1-m)*r,-r,r,-r];},

                'triangle': function(side){
                            var s = side || 1;
                            return ['m', 0.5*s, -0.289*s, 'l', -0.5*s, 0.866*s, -0.5*s, -0.866*s, 'z'];},

                'cross': function(width){
                            var w = width || 1;
                            return ['m', -0.5*w, 0, 'l', w, 0, 'm', -0.5*w, -0.5*w, 'l', 0, w];},

                'ex': function(diagonal){
                            var d = diagonal || 1;
                            return ['m', -0.3535*d,-0.3535*d, 'l',0.707*d,0.707*d,
                                    'm',-0.707*d,0, 'l',0.707*d,-0.707*d];}
                };
  }

  LinearGradient = function(p1x, p1y, p2x, p2y)
  {
    this.grad = [p1x, p1y, p2x, p2y];
    this.colorStops = [];
    this.addColorStop = function(){this.colorStops.push(arguments);};
  };

  RadialGradient = function(p1x, p1y, r1, p2x, p2y, r2)
  {
    this.grad = [p1x, p1y, r1, p2x, p2y, r2];
    this.colorStops = [];
    this.addColorStop = function(){this.colorStops.push(arguments);};
  };

  DrawCmd = function(cmdStr, coords)   // canvas syntax draw commands
  {
    // coords = world coordinates in [cp1x,cp1y, cp2x,cp2y, ... x,y]
    var i;

    this.drawFn = cmdStr;       // String version of the canvas command to call
    this.parms = [];
    for (i=0; i&lt;coords.length; i+=2)
    {
      this.parms.push(coords.slice(i, i+2));
    }
    this.parmsPx = [];          // parms transformed into pixel coords
  };

  function Path(commands)
  {
    this.type = "PATH";
    this.drawCmds = cgo2DtoDrawCmd(commands);
    // send the Cgo2D (SVG) commands off to the canvas DrawCmd processor
    this.dwgOrg = {x:0, y:0};       // drawing origin (0,0) may get translated
    this.dragNdrop = null;
    // properties set by setProperty if undefined render uses Cango default
    this.iso = false;               // true = maintain aspect ratio
    this.border = false;            // true = stroke outline with strokeColor &amp; lineWidth
    this.strokeCol = null;          // renderer will stroke a path and shape outline in this color
    this.lineWidth = 1;             // in case fat outline is wanted for Path or Shape outline
    this.lineCap = null;            // round butt or mitre
    // drop shadow properties
    this.shadowOffsetX = 0;
    this.shadowOffsetY = 0;
    this.shadowBlur = 0;
    this.shadowColor = "#000000";
    // dashed line properties
    this.dashed = null;
    this.dashOffset = 0;
  }

  Path.prototype.translate = function(x, y)
  {
    this.drawCmds.forEach(function(cmd){
      cmd.parms = cmd.parms.map(function(p){
        return [p[0] + x, p[1] + y];  // assumes p is a 2 element array [x, y]
      });
    });
  };

  Path.prototype.rotate = function(degs)
  {
    var A = Math.PI*degs/180.0,   // radians
        sinA = Math.sin(A),
        cosA = Math.cos(A);

    this.drawCmds.forEach(function(cmd){
      cmd.parms = cmd.parms.map(function(p){
        return [p[0]*cosA - p[1]*sinA, p[0]*sinA + p[1]*cosA];  // assumes p is a 2 element array [x, y]
      });
    });
  };

  Path.prototype.scale = function(xScl, yScl, lineWdScl)
  {
    var xScale = xScl || 1,
        yScale = yScl || xScale,   // default to isotropic scaling
        lwScale = lineWdScl || 1;  // default to current value

    this.drawCmds.forEach(function(cmd){
      cmd.parms = cmd.parms.map(function(p){
        return [p[0]*xScale, p[1]*yScale];  // assumes p is a 2 element array [x, y]
      });
    });
    if (lwScale&gt;0)    // only affects PATH and SHAPE types
    {
      this.lineWidth *= lwScale;
    }
  };

  Path.prototype.appendPath = function(obj, delMove)
  {
    var dcs = clone(obj.drawCmds);  // make new element not references

    if (delMove)  // delete the inital 'moveTo' command
    {
      this.drawCmds = this.drawCmds.concat(dcs.slice(1));
    }
    else
    {
      this.drawCmds = this.drawCmds.concat(dcs);
    }
  };

  Path.prototype.revWinding = function()
  {
    // reverse the direction of drawing around a path, stops holes in shapes being filled
    var cmds,
        zCmd = null,
        revCmds = [],
        k, len,
        dParms, dCmd;

    function revPairs(ary)
    {
      // return a single array of x,y coords made by taking array of [x,y] arrays and reversing the order
      // eg. [[1,2], [3,4], [5,6]] returns [5,6,3,4,1,2]
      return ary.reduceRight(function(acc, curr){
        acc.push(curr[0], curr[1]);
        return acc;
      }, []);
    }

    if (this.drawCmds[this.drawCmds.length-1].drawFn === "closePath")
    {
      cmds = this.drawCmds.slice(0, -1);  // leave off 'closePath'
      zCmd = this.drawCmds.slice(-1);
    }
    else
    {
      cmds = this.drawCmds.slice(0);  // copy the whole array
    }
    // now step back along the path
    k = cmds.length-1;    // k points at the last segment DrawCmd
    len = cmds[k].parms.length;  // length of last DrawCmd's parms array
    dCmd = new DrawCmd("moveTo", cmds[k].parms[len-1]);   // make a 'M' command from final coord pair
    revCmds.push(dCmd);         // make this the first command of the output
    cmds[k].parms = cmds[k].parms.slice(0,-1);  // weve used the last point so slice it off
    while (k&gt;0)
    {
      dParms = revPairs(cmds[k].parms);   // dParms is a flat array
      len = cmds[k-1].parms.length;       // find the last DrawCmd of the next segment back
      dParms = dParms.concat(cmds[k-1].parms[len-1]); // add the last point of next cmd
      dCmd = new DrawCmd(cmds[k].drawFn, dParms);     // construct the DrawCmd for this segment
      revCmds.push(dCmd);                             // shove it out
      cmds[k-1].parms = cmds[k-1].parms.slice(0,-1);  // weve used the last point so slice it off
      k--;
    }
    // add the 'z' if it was a closed path
    if (zCmd)
    {
      revCmds.push(zCmd);
    }

    this.drawCmds = revCmds;
  };

  function Shape(commands)
  {
    // build all the Path properties and assign them to this Object's properties
    Path.call(this, commands);

    this.type = "SHAPE";
    this.iso = true;               // true = maintain aspect ratio
  }

  Shape.prototype = new Path();    // make the Path methods the methods of this Shape object

  function Img(url)
  {
    this.type = "IMG";
    this.drawCmds = url;            // just store the Image
    this.imgBuf = new Image();             // pointer to the Image object when image is loaded
    this.bBoxCmds = [];             // DrawCmd array for the text or img bounding box
    this.dwgOrg = {x:0, y:0};       // drawing origin (0,0) may get translated
    this.width = 0;                 // IMG types use to store requested width (natural width used if none passed)
    this.height = 0;                //     "
    this.imgX = 0;                  // TEXT &amp; IMG use these for obj.translate, obj.rotate, obj.scale
    this.imgY = 0;                  //     "
    this.imgLorgX = 0;              //     "
    this.imgLorgY = 0;              //     "
    this.imgXscale = 1;             //     "
    this.imgYscale = 1;             //     "
    this.imgDegs = 0;               //     "
    this.lorg = 1;                  // used by IMG type for temp storage of lorg while loading image
    this.dragNdrop = null;
    // properties set by setProperty if undefined render uses Cango default
    this.border = false;            // true = stroke outline with strokeColor &amp; lineWidth
    this.strokeCol = null;          // renderer will stroke a path and shape outline in this color
    this.lineWidth = 1;             // in case fat outline is wanted for Path or Shape outline
    this.lineCap = null;            // round butt or mitre
    // drop shadow properties
    this.shadowOffsetX = 0;
    this.shadowOffsetY = 0;
    this.shadowBlur = 0;
    this.shadowColor = "#000000";

    this.imgBuf.src = url;          // start loading the image immediately
  }

  Img.prototype.translate = function(x, y)
  {
    // no points to shift just remember the offset to use when rendering
    this.imgX += x;   // IMG and TEXT types convert to pixels during render
    this.imgY += y;
  };

  Img.prototype.rotate = function(degs)
  {
    // no points to shift just remember the value to use when rendering
    this.imgDegs += degs;
  };

  Img.prototype.scale = function(xScl, yScl)
  {
    var xScale = xScl || 1,
        yScale = yScl || xScale;  // default to current value

    // no points to shift just remeber values to use when rendering
    this.imgXscale *= xScale;
    this.imgYscale *= yScale;
    this.imgX *= xScale;
    this.imgY *= yScale;
  };

  Img.prototype.formatImg = function()
  {
    var wid, hgt, wid2, hgt2,
        dx = 0,
        dy = 0,
        ulx, uly, llx, lly, lrx, lry, urx, ury,
        lorgWC;

    if (!this.imgBuf.width)
    {
      console.log("in image onload handler yet image NOT loaded!");
    }

    if (this.width &amp;&amp; this.height)
    {
      wid = this.width;
      hgt = this.height;
    }
    else if (this.width &amp;&amp; !this.height)  // width only passed height is auto
    {
      wid = this.width;
      hgt = this.height || wid*this.imgBuf.height/this.imgBuf.width;  // default keep aspect ratio
    }
    else if (this.height &amp;&amp; !this.width)  // height only passed width is auto
    {
      hgt = this.height;
      wid = this.width || hgt*this.imgBuf.width/this.imgBuf.height;    // default to keep aspect ratio
    }
    else    // no width or height default to natural size;
    {
      wid = this.imgBuf.width;    // default to natural width if none passed
      hgt = this.imgBuf.height;   // default to natural height if none passed
    }
    wid2 = wid/2;
    hgt2 = hgt/2;
    lorgWC = [0, [0, 0],    [wid2, 0],   [wid, 0],
                 [0, hgt2], [wid2, hgt2], [wid, hgt2],
                 [0, hgt],  [wid2, hgt],  [wid, hgt]];
    if (lorgWC[this.lorg] !== undefined)
    {
      dx = -lorgWC[this.lorg][0];
      dy = -lorgWC[this.lorg][1];
    }
    this.imgLorgX = dx;     // world coords offset to drawing origin
    this.imgLorgY = dy;
    this.width = wid;   // in case it was not set and natural used
    this.height = hgt;
    // construct the DrawCmds for the text bounding box
    ulx = this.imgX+dx;
    uly = this.imgY+dy;
    llx = this.imgX+dx;
    lly = this.imgY+dy+hgt;
    lrx = this.imgX+dx+wid;
    lry = this.imgY+dy+hgt;
    urx = this.imgX+dx+wid;
    ury = this.imgY+dy;
    this.bBoxCmds[0] = new DrawCmd("moveTo", [ulx, -uly]);
    this.bBoxCmds[1] = new DrawCmd("lineTo", [llx, -lly]);
    this.bBoxCmds[2] = new DrawCmd("lineTo", [lrx, -lry]);
    this.bBoxCmds[3] = new DrawCmd("lineTo", [urx, -ury]);
    this.bBoxCmds[4] = new DrawCmd("closePath", []);
  };

  function Text(txtString)
  {
    this.type = "TEXT";
    this.drawCmds = txtString;      // just store the text String
    this.bBoxCmds = [];             // DrawCmd array for the text or img bounding box
    this.dwgOrg = {x:0, y:0};       // drawing origin (0,0) may get translated
    this.imgX = 0;                  // TEXT &amp; IMG use these for obj.translate, obj.rotate, obj.scale
    this.imgY = 0;                  //     "
    this.imgLorgX = 0;              //     "
    this.imgLorgY = 0;              //     "
    this.imgXscale = 1;             //     "
    this.imgYscale = 1;             //     "
    this.imgDegs = 0;               //     "
    this.lorg = 1;                  // used by IMG &amp; TEXT type
    this.dragNdrop = null;
    // properties set by setProperty if undefined render uses Cango default
    this.border = false;            // true = stroke outline with strokeColor &amp; lineWidth
    this.fillCol = null;            // only used if type = SHAPE and TEXT color
    this.fontSize = null;           // fontSize in pixels (TEXT only)
    this.fontWeight = null;         // fontWeight 100..900 (TEXT only)
    this.fontFamily = null;         // (TEXT only)
    // drop shadow properties
    this.shadowOffsetX = 0;
    this.shadowOffsetY = 0;
    this.shadowBlur = 0;
    this.shadowColor = "#000000";
  }

  Text.prototype.translate = function(x, y)
  {
    // no points to shift just remember the offset to use when rendering
    this.imgX += x;   // IMG and TEXT types convert to pixels during render
    this.imgY += y;
  };

  Text.prototype.rotate = function(degs)
  {
    // no points to shift just remember the value to use when rendering
    this.imgDegs += degs;
  };

  Text.prototype.scale = function(xScl, yScl)
  {
    var xScale = xScl || 1,
        yScale = yScl || xScale;  // default to current value

    // no points to shift just remeber values to use when rendering
    this.imgXscale *= xScale;
    this.imgYscale *= yScale;
    this.imgX *= xScale;
    this.imgY *= yScale;
  };

  Text.prototype.formatText = function(gc)     // pass the current Cango context
  {
    var size = this.fontSize || gc.fontSize,     // fontSize in pxls
        fntFm = this.fontFamily || gc.fontFamily,
        lorg = this.lorg || 1,
        wid, hgt,   // Note: char cell is ~1.4*fontSize pixels high
        wid2, hgt2,
        lorgWC,
        dx = 0,
        dy = 0,
        ulx, uly, llx, lly, lrx, lry, urx, ury;

    // set the drawing context to measure the size
    gc.ctx.save();
    gc.ctx.font = size+"px "+fntFm;
    wid = gc.ctx.measureText(this.drawCmds).width;   // wid is in pixels
    gc.ctx.restore();
    hgt = size;           // char cell height (bottom of decender to top of capitals)
    wid /= gc.xscl;  // convert to world coords
    hgt /= gc.xscl;  // TEXT dimensions are 'iso' so use xscl
    wid2 = wid/2;
    hgt2 = hgt/2;
    // assume the text is to be drawn with 'alphabetic' baseline (best cross browser support)
    lorgWC = [0, [0, hgt],  [wid2, hgt],  [wid, hgt],
                 [0, hgt2], [wid2, hgt2], [wid, hgt2],
                 [0, 0],    [wid2, 0],    [wid, 0]];
    if (lorgWC[lorg] !== undefined)
    {
      dx = -lorgWC[lorg][0];  // offset to drawing origin (converted to world coords)
      dy = -lorgWC[lorg][1];
    }
    this.imgLorgX = dx;      // world coord offset to drawing origin
    this.imgLorgY = dy+0.25*hgt;   // correct for alphabetic baseline, its offset about 0.25*char height
    this.width = wid;        // in world coords
    this.height = hgt;
    // construct the DrawCmds for the text bounding box
    ulx = this.imgX+dx;
    uly = this.imgY-dy;
    llx = this.imgX+dx;
    lly = this.imgY-dy-hgt;
    lrx = this.imgX+dx+wid;
    lry = this.imgY-dy-hgt;
    urx = this.imgX+dx+wid;
    ury = this.imgY-dy;
    this.bBoxCmds[0] = new DrawCmd("moveTo", [ulx, -uly]);
    this.bBoxCmds[1] = new DrawCmd("lineTo", [llx, -lly]);
    this.bBoxCmds[2] = new DrawCmd("lineTo", [lrx, -lry]);
    this.bBoxCmds[3] = new DrawCmd("lineTo", [urx, -ury]);
    this.bBoxCmds[4] = new DrawCmd("closePath", []);
  };

  Cobj = function(data, objtype, options)
  {
    var classObj = Path,    // default to a Path type Cobj
        objClass,
        opt, prop;

    switch (objtype)
    {
      case "PATH":
        classObj = Path;
        break;
      case "SHAPE":
        classObj = Shape;
        break;
      case "IMG":
        classObj = Img;
        break;
      case "TEXT":
        classObj = Text;
        break;
    }

    // build all the properties of the Object and make them properties of this Cobj
    classObj.call(this, data);
    // make an instance of the Object type so we can inherit its methods
    objClass = new classObj();
    for (prop in objClass)
    {
      if (typeof objClass[prop] === "function")    // copy references to the methods only
      {
        this[prop] = objClass[prop];
      }
    }

    // now handle all the user requested options
    opt = (typeof options === 'object')? options: {};   // avoid undeclared object errors
    // check for all supported options
    for (prop in opt)
    {
      // check that this is opt's own property, not inherited from prototype
      if (opt.hasOwnProperty(prop))
      {
        this.setProperty(prop, opt[prop]);
      }
    }
  };

  Cobj.prototype.setProperty = function(propertyName, value)
  {
    if ((typeof propertyName !== "string")||(value === undefined))  // null is OK, forces default
    {
      return;
    }

    switch (propertyName.toLowerCase())
    {
      case "fillcolor":
        this.fillCol = value;
        break;
      case "strokecolor":
        this.strokeCol = value;
        break;
      case "linewidth":
      case "strokewidth":                 // for backward compatability
        this.lineWidth = Math.abs(value);
        break;
      case "linecap":
        if (typeof value !== "string")
        {
          return;
        }
        if ((value === "butt")||(value === "round")||(value === "square"))
        {
          this.lineCap = value;
        }
        break;
      case "iso":
      case "isotropic":
        if ((value == true)||(value === 'iso')||(value === 'isotropic'))
        {
          this.iso = true;
        }
        else
        {
          this.iso = false;
        }
        break;
      case "dashed":
        if (isArray(value) &amp;&amp; value[0])
        {
          this.dashed = value;
        }
        else     // setDashed() will clear dashed settings
        {
          this.dashed = null;
        }
        break;
      case "dashoffset":
        this.dashOffset = value || 0;
        break;
      case "border":
        if (value == true)
        {
          this.border = true;
        }
        if (value == false)
        {
          this.border = false;
        }
        break;
      case "fontsize":
        this.fontSize = Math.abs(value);
        break;
      case "fontweight":
        if ((typeof value === "string")||((typeof value === "number")&amp;&amp;(value&gt;=100)&amp;&amp;(value&lt;=900)))
        {
          this.fontWeight = value;
        }
        break;
      case "fontfamily":
        if (typeof value === "string")
        {
          this.fontFamily = value;
        }
        break;
      case "imgwidth":
        this.width = Math.abs(value);
        break;
      case "imgheight":
        this.height = Math.abs(value);
        break;
      case "lorg":
        if ([1, 2, 3, 4, 5, 6, 7, 8, 9].indexOf(value) &gt; -1)
        {
          this.lorg = value;
        }
        break;
      case "shadowoffsetx":
        this.shadowOffsetX = value || 0;
        break;
      case "shadowoffsety":
        this.shadowOffsetY = value || 0;
        break;
      case "shadowblur":
        this.shadowBlur = value || 0;
        break;
      case "shadowcolor":
        this.shadowColor = value;
        break;
      default:
        return;
    }
  };

  Cobj.prototype.dup = function()
  {
    var newObj = new Cobj();

    newObj.type = this.type;
    newObj.drawCmds = clone(this.drawCmds);
    newObj.imgBuf = this.imgBuf;
    newObj.bBoxCmds = clone(this.bBoxCmds);
    newObj.dwgOrg = clone(this.dwgOrg);
    newObj.iso = this.iso;
    newObj.border = this.border;
    newObj.strokeCol = this.strokeCol;
    newObj.fillCol = this.fillCol;
    newObj.lineWidth = this.lineWidth;
    newObj.lineCap = this.lineCap;
    newObj.width = this.width;
    newObj.height = this.height;
    newObj.imgX = this.imgX;
    newObj.imgY = this.imgY;
    newObj.imgLorgX = this.imgLorgX;
    newObj.imgLorgY = this.imgLorgY;
    newObj.imgXscale = this.imgXscale;
    newObj.imgYscale = this.imgYscale;
    newObj.imgDegs = this.imgDegs;
    newObj.lorg = this.lorg;
    newObj.dragNdrop = null;
    newObj.fontSize = this.fontSize;
    newObj.fontWeight = this.fontWeight;
    newObj.fontFamily = this.fontFamily;
    newObj.shadowOffsetX = this.shadowOffsetX;
    newObj.shadowOffsetY = this.shadowOffsetY;
    newObj.shadowBlur = this.shadowBlur;
    newObj.shadowColor = this.shadowColor;
    newObj.dashed = this.dashed;
    newObj.dashOffset = this.dashOffset;

    return newObj;
  };

//===============================================================================

  function Layer(canvasID, canvasElement)
  {
    this.id = canvasID;
    this.cElem = canvasElement;
    this.dragObjects = [];
  }

  Cango = function(canvasId)
  {
    var savThis = this,
        bkgId, bkgL;

    function resizeLayers()
    {
      var j, ovl,
          t = savThis.bkgCanvas.offsetTop + savThis.bkgCanvas.clientTop,
          l = savThis.bkgCanvas.offsetLeft + savThis.bkgCanvas.clientLeft,
          w = savThis.bkgCanvas.offsetWidth,
          h = savThis.bkgCanvas.offsetHeight;

      // fix all Cango contexts to know about new size
      savThis.rawWidth = w;
      savThis.rawHeight = h;
      savThis.aRatio = w/h;
      // there may be multiple Cango contexts on a layer, try to only fix canvas properties once
      if (savThis.bkgCanvas !== savThis.cnvs)
      {
        return;
      }
      savThis.cnvs.setAttribute('width', w);    // reset canvas pixels width
      savThis.cnvs.setAttribute('height', h);   // don't use style for this
      // make any offscreen buffer match the new size
      if (savThis.buffered)
      {
        savThis.cnvs.buf.setAttribute('width', w);    // set number of graphics pixels
        savThis.cnvs.buf.setAttribute('height', h);   // to match screen canvas
      }
      // step through the stack of canvases (if any)
      for (j=1; j&lt;savThis.bkgCanvas.layers.length; j++)  // bkg is layer[0]
      {
        ovl = savThis.bkgCanvas.layers[j].cElem;
        if (ovl)
        {
          ovl.style.top = t+'px';
          ovl.style.left = l+'px';
          ovl.style.width = w+'px';
          ovl.style.height = h+'px';
          ovl.setAttribute('width', w);    // reset canvas pixels width
          ovl.setAttribute('height', h);   // don't use style for this
          if (ovl.buf)
          {
            ovl.buf.setAttribute('width', w);    // set number of graphics pixels
            ovl.buf.setAttribute('height', h);   // to match screen canvas
          }
        }
      }
    }

    // test for off screen canvas drawing
    this.cId = canvasId;
    this.cnvs = document.getElementById(canvasId);
    if (this.cnvs === null)
    {
      alert("can't find canvas "+canvasId);
      return;
    }
    this.bkgCanvas = this.cnvs;  // assume this is a background canvas, bkgCanvas points to itself
    // check if this is a context for an overlay
    if (canvasId.indexOf("_ovl_") !== -1)
    {
      // this is an overlay. get a reference to the backGround canvas
      bkgId = canvasId.slice(0,canvasId.indexOf("_ovl_"));
      this.bkgCanvas = document.getElementById(bkgId);
    }
    this.rawWidth = this.cnvs.offsetWidth;
    this.rawHeight = this.cnvs.offsetHeight;
    this.aRatio = this.rawWidth/this.rawHeight;
    this.widthPW = 100;                           // width of canvas in ViewPort Coords
    this.heightPW = this.widthPW/this.aRatio;    // height of canvas in ViewPort Coords
    if (!this.bkgCanvas.hasOwnProperty('layers'))
    {
      // create an array to hold all the overlay canvases for this canvas
      this.bkgCanvas.layers = [];
      // make a Layer object for the bkgCanvas
      bkgL = new Layer(this.cId, this.cnvs);
      this.bkgCanvas.layers[0] = bkgL;
    }
    if ((typeof Timeline !== "undefined") &amp;&amp; !this.bkgCanvas.hasOwnProperty('timeline'))
    {
      // create a a single timeline for all animations on all layers
      this.bkgCanvas.timeline = new Timeline();
    }
    if (!this.cnvs.hasOwnProperty('resized'))
    {
      // make canvas native aspect ratio equal style box aspect ratio.
      // Note: rawWidth and rawHeight are floats, assignment to ints will truncate
      this.cnvs.setAttribute('width', this.rawWidth);    // reset canvas pixels width
      this.cnvs.setAttribute('height', this.rawHeight);  // don't use style for this
      this.cnvs.resized = true;
    }
    // this.buffered is set if the CangoAnimation module is loaded
    // this.buffered = true; // draw animation to off-screen buffer then bitblt complete frames
    // create off screen drawing buffer
    if (this.buffered)
    {
      this.cnvs.buf = document.createElement('canvas');      // create buffer in memory
      this.cnvs.buf.setAttribute('width', this.rawWidth);    // set number of graphics pixels
      this.cnvs.buf.setAttribute('height', this.rawHeight);  // to match screen canvas
      this.bufCtx = this.cnvs.buf.getContext('2d');          // animation drawing done off screen
    }
    this.ctx = this.cnvs.getContext('2d');  // draw direct to screen canvas
    this.yDown = false;   // flag used by seyViewport &amp; setSVGViewport to signal use of SVG coords to setWorldCoords
    this.vpW = this.rawWidth;               // vp width in pixels (default to full canvas size)
    this.vpH = this.rawHeight;              // vp height in pixels
    this.vpOrgX = 0;                        // vp lower left from canvas left in pixels
    this.vpOrgY = this.rawHeight;           // vp lower left from canvas top
    this.xscl = 1;                          // world x axis scale factor, default to pixels, +ve right
    this.yscl = -1;                         // world y axis scale factor
    this.xoffset = 0;                       // world x origin offset from viewport left in pixels
    this.yoffset = 0;                       // world y origin offset from viewport bottom in pixels
    this.savWC = {"xscl":this.xscl,
                  "yscl":this.yscl,
                  "xoffset":this.xoffset,
                  "yoffset":this.yoffset};  // save world coords for zoom/pan
    this.ctx.textAlign = "left";            // all offsets are handled in code so dragNdrop works
    this.ctx.textBaseline = "alphabetic";
    this.penCol = "rgba(0, 0, 0, 1.0)";     // black
    this.penWid = 1;                        // pixels
    this.lineCap = "butt";
    this.paintCol = "rgba(128,128,128,1.0)";// gray
    this.fontSize = 12;                     // pixels
    this.fontWeight = 400;                  // 100..900, 400 = normal,700 = bold
    this.fontFamily = "Consolas, Monaco, 'Andale Mono', monospace";

    this.getUnique = function()
    {
      uniqueVal += 1;     // a private 'global'
      return uniqueVal;
    };

    this.initModules();    // this method may be re-defined by modules

    addEvent(window, 'resize', resizeLayers);
  };

  Cango.prototype.initModules = function(){};

  Cango.prototype.getHostLayer = function()
  {
    var i, lyr = this.bkgCanvas.layers[0];  // if no overlay canvases then Cango is on the background canvas

    for (i=1; i &lt; this.bkgCanvas.layers.length; i++)
    {
      if (this.bkgCanvas.layers[i].id === this.cId)
      {
        lyr = this.bkgCanvas.layers[i];
        break;
      }
    }
    return lyr;    // Layer object
  };

  Cango.prototype.toPixelCoords = function(x, y)
  {
    // transform x,y in world coords to canvas pixel coords (top left is 0,0 y axis +ve down)
    var xPx = this.vpOrgX+this.xoffset+x*this.xscl,
        yPx = this.vpOrgY+this.yoffset+y*this.yscl;

    return {x: xPx, y: yPx};
  };

  Cango.prototype.toWorldCoords = function(xPx, yPx)
  {
    // transform xPx,yPx in raw canvas pixels to world coords (lower left is 0,0 +ve up)
    var xW = (xPx - this.vpOrgX - this.xoffset)/this.xscl,
        yW = (yPx - this.vpOrgY - this.yoffset)/this.yscl;

    return {x: xW, y: yW};
  };

  Cango.prototype.getCursorPosWC = function(evt)
  {
    // pass in any mouse event, returns the position of the cursor in raw pixel coords
    var e = evt||window.event,
        rect = this.cnvs.getBoundingClientRect(),
        xW = (e.clientX - rect.left - this.vpOrgX - this.xoffset)/this.xscl,
        yW = (e.clientY - rect.top - this.vpOrgY - this.yoffset)/this.yscl;

    return {x: xW, y: yW};
  };

  Cango.prototype.clearCanvas = function(fillColor)
  {
    var savThis = this,
        layerObj;

    function genLinGrad(lgrad)
    {
      var p1 = savThis.toPixelCoords(lgrad.grad[0], lgrad.grad[1]),
          p2 = savThis.toPixelCoords(lgrad.grad[2], lgrad.grad[3]),
          grad = savThis.ctx.createLinearGradient(p1.x, p1.y, p2.x, p2.y);

      lgrad.colorStops.forEach(function(colStop){grad.addColorStop(colStop[0], colStop[1]);});

      return grad;
    }

    function genRadGrad(rgrad)
    {
      var p1 = savThis.toPixelCoords(rgrad.grad[0], rgrad.grad[1]),
          r1 = rgrad.grad[2]*savThis.xscl,
          p2 = savThis.toPixelCoords(rgrad.grad[3], rgrad.grad[4]),
          r2 = rgrad.grad[5]*savThis.xscl,
          grad = savThis.ctx.createRadialGradient(p1.x, p1.y, r1, p2.x, p2.y, r2);

      rgrad.colorStops.forEach(function(colStop){grad.addColorStop(colStop[0], colStop[1]);});

      return grad;
    }

    if (fillColor)
    {
      this.ctx.save();
      if (fillColor instanceof LinearGradient)
      {
        this.ctx.fillStyle = genLinGrad(fillColor);
      }
      else if (fillColor instanceof RadialGradient)
      {
        this.ctx.fillStyle = genRadGrad(fillColor);
      }
      else
      {
        this.ctx.fillStyle = fillColor;
      }
      this.ctx.fillRect(0, 0, this.rawWidth, this.rawHeight);
      this.ctx.restore();
    }
    else
    {
      this.ctx.clearRect(0, 0, this.rawWidth, this.rawHeight);
    }
    // all drawing erased, but graphics contexts remain intact
    // clear the dragObjects array, draggables put back when rendered
    layerObj = this.getHostLayer();
    layerObj.dragObjects.length = 0;
    // in case the CangoHTMLtext extension is used
    if (this.cnvs.alphaOvl &amp;&amp; this.cnvs.alphaOvl.parentNode)
    {
      this.cnvs.alphaOvl.parentNode.removeChild(this.cnvs.alphaOvl);
    }
  };

  Cango.prototype.setGridboxRHC = function(lowerLeftX, lowerLeftY, w, h)
  {
    // lowerLeftX, lowerLeft, w, h are in % of canvas width units (origin = canvas lower left)
    if (h &amp;&amp; w &amp;&amp; (h &gt; 0) &amp;&amp; (w &gt; 0))
    {
      this.vpW = w*this.rawWidth/100;
      this.vpH = h*this.rawWidth/100;
      this.vpOrgX = lowerLeftX*this.rawWidth/100;
	    this.vpOrgY = this.rawHeight-lowerLeftY*this.rawWidth/100;
    }
    else
    {
      this.vpW = this.rawWidth;
      this.vpH = this.rawHeight;
      this.vpOrgX = 0;
      this.vpOrgY = this.rawHeight;
    }
    this.yDown = false;    // flag for setWorldCoords used only for Cartesian coords (Y +ve UP the screen)
    this.setWorldCoords(); // if new gridbox created, world coords are garbage, so reset to defaults
  };

  Cango.prototype.setGridboxSVG = function(upperLeftX, upperLeftY, w, h)
  {
    // upperLeftX, upperLeftY are in % of canvas width units (origin = canvas lower left)
    if (h &amp;&amp; w &amp;&amp; (h &gt; 0) &amp;&amp; (w &gt; 0))
    {
      this.vpW = w*this.rawWidth/100;
      this.vpH = h*this.rawWidth/100;
      this.vpOrgX = upperLeftX*this.rawWidth/100;
	    this.vpOrgY = (this.heightPW - upperLeftY)*this.rawWidth/100;
   }
    else
    {
      this.vpW = this.rawWidth;
      this.vpH = this.rawHeight;
      this.vpOrgX = 0;
      this.vpOrgY = 0;
    }
    this.yDown = true;     // flag for setWorldCoords true only for inverted Cartesian coords (Y +ve DOWN)
    this.setWorldCoords(); // if new gridbox, world coords are garbage, so reset to defaults
  };

  Cango.prototype.fillGridbox = function(fillColor)
  {
    var savThis = this,
        newCol = fillColor || this.paintCol,
        yCoord = (this.yscl&gt;0)? this.vpOrgY: this.vpOrgY-this.vpH;

    function genLinGrad(lgrad)
    {
      var p1 = savThis.toPixelCoords(lgrad.grad[0], lgrad.grad[1]),
          p2 = savThis.toPixelCoords(lgrad.grad[2], lgrad.grad[3]),
          grad = savThis.ctx.createLinearGradient(p1.x, p1.y, p2.x, p2.y);

      lgrad.colorStops.forEach(function(colStop){grad.addColorStop(colStop[0], colStop[1]);});

      return grad;
    }

    function genRadGrad(rgrad)
    {
      var p1 = savThis.toPixelCoords(rgrad.grad[0], rgrad.grad[1]),
          r1 = rgrad.grad[2]*savThis.xscl,
          p2 = savThis.toPixelCoords(rgrad.grad[3], rgrad.grad[4]),
          r2 = rgrad.grad[5]*savThis.xscl,
          grad = savThis.ctx.createRadialGradient(p1.x, p1.y, r1, p2.x, p2.y, r2);

      rgrad.colorStops.forEach(function(colStop){grad.addColorStop(colStop[0], colStop[1]);});

      return grad;
    }

    this.ctx.save();
    if (newCol instanceof LinearGradient)
    {
      this.ctx.fillStyle = genLinGrad(newCol);
    }
    else if (newCol instanceof RadialGradient)
    {
      this.ctx.fillStyle = genRadGrad(newCol);
    }
    else
    {
      this.ctx.fillStyle = newCol;
    }
    this.ctx.fillRect(this.vpOrgX, yCoord, this.vpW, this.vpH); // fill: top, left, wid, hgt
    this.ctx.restore();
  };

  Cango.prototype.setWorldCoords = function(vpOriginX, vpOriginY, spanX, spanY)
  {
    // viewport origin (lower left for Cartesian, upper left for SVG)
    var vpOrgXWC = vpOriginX || 0,  // viewport origin x world coord
        vpOrgYWC = vpOriginY || 0;  // viewport origin y world coord

    if (spanX &amp;&amp; (spanX &gt; 0))
    {
      this.xscl = this.vpW/spanX;
    }
    else
    {
      this.xscl = 1;                   // use pixel units
    }
    if (spanY &amp;&amp; (spanY &gt; 0))
    {
      this.yscl = this.yDown? this.vpH/spanY: -this.vpH/spanY;
    }
    else
    {
      this.yscl = this.yDown? this.xscl: -this.xscl;          // square pixels
    }
    // sign of this.yscl signals other methods that Cartesion (yscl&lt;0) or SVG (yscl&gt;0) coords are being used
    this.xoffset = -vpOrgXWC*this.xscl;
    this.yoffset = -vpOrgYWC*this.yscl;
    // save these values to support resetting zoom and pan
    this.savWC = {"xscl":this.xscl, "yscl":this.yscl, "xoffset":this.xoffset, "yoffset":this.yoffset};
  };

  Cango.prototype.setPropertyDefault = function(propertyName, value)
  {
    if ((typeof propertyName !== "string")||(value === undefined)||(value === null))
    {
      return;
    }

    switch (propertyName.toLowerCase())
    {
      case "fillcolor":
        if ((typeof value === "string")||(typeof value === "object"))  // gradient will be an object
        {
          this.paintCol = value;
        }
        break;
      case "strokecolor":
        if ((typeof value === "string")||(typeof value === "object"))  // gradient will be an object
        {
          this.penCol = value;
        }
        break;
      case "linewidth":
      case "strokewidth":
        this.penWid = value;
        break;
      case "linecap":
        if ((typeof value === "string")&amp;&amp;((value === "butt")||(value === "round")||(value === "square")))
        {
          this.lineCap = value;
        }
        break;
      case "fontfamily":
        if (typeof value === "string")
        {
          this.fontFamily = value;
        }
        break;
      case "fontsize":
        this.fontSize = value;
        break;
      case "fontweight":
        if ((typeof value === "string")||((value &gt;= 100)&amp;&amp;(value &lt;= 900)))
        {
          this.fontWeight = value;
        }
        break;
      case "steptime":
        if ((value &gt;= 15)&amp;&amp;(value &lt;= 500))
        {
          this.stepTime = value;
        }
        break;
      default:
        return;
    }
  };

  Cango.prototype.dropShadow = function(obj, scl)
  {
    var xOfs = obj.shadowOffsetX || 0,
        yOfs = obj.shadowOffsetY || 0,
        radius = obj.shadowBlur || 0,
        color = obj.shadowColor || "#000000",
        xScale = scl || 1,
        yScale = scl || 1;

    if (this.ctx.shadowOffsetX !== undefined)     // check if supported
    {
      if ((obj.type === "SHAPE")||((obj.type === "PATH")&amp;&amp; !obj.iso))   // must scale for world coords (matrix scaling not used)
      {
        xScale *= this.xscl;
        yScale *= this.yscl;
      }
      else                         // no need to scale here (matrix scaling used)
      {
        xScale *= this.xscl;
        yScale *= -this.xscl;
      }

      this.ctx.shadowOffsetX = xOfs*xScale;
      this.ctx.shadowOffsetY = yOfs*yScale;
      this.ctx.shadowBlur = radius*xScale;
      this.ctx.shadowColor = color;
    }
  };

  Cango.prototype.render = function(pathObj, x, y, scl, degs)
  {
    var savThis = this;

    function processCobj(cobj)
    {
      function imgLoaded(){
        cobj.formatImg();
        savThis.paintImg(cobj, x, y, scl, degs);
      }

      if (cobj.type === "IMG")
      {
        if (cobj.imgBuf.complete)    // see if already loaded
        {
          imgLoaded();
        }
        else
        {
          addEvent(cobj.imgBuf, 'load', imgLoaded);
        }
      }
      else if (cobj.type === "TEXT")
      {
        cobj.formatText(savThis);
        savThis.paintText(cobj, x, y, scl, degs);
      }
      else    // PATH, SHAPE
      {
        savThis.paintPath(cobj, x, y, scl, degs);
      }
    }

    // ================= start here  =================

    if (isArray(pathObj))
    {
      flatten(pathObj).forEach(processCobj);  // handle nested arrays of Cobj
    }
    else if (pathObj)
    {
      processCobj(pathObj);
    }
  };

  Cango.prototype.paintImg = function(pathObj, x, y, scl, degrees)
  {
    // should only be called after image has been loaded into drawCmds
    var savThis = this,
        A, sinA, cosA,
        img = pathObj.imgBuf,            // this is the place the image is stored in object
        xPos = x || 0,
        yPos = y || 0,
        xScale = scl || 1,
        scale = xScale*pathObj.imgXscale,  // imgXscale is from Cobj.scale (permanent)
        degs = degrees || 0,
        currLr, aidx;

    function rotXY(p)
    {
      return [p[0]*cosA - p[1]*sinA, p[0]*sinA + p[1]*cosA];
    }

    this.ctx.save();   // save the clean ctx
    // set up dropShadow if any
    this.dropShadow(pathObj, xScale);
    // move the whole coordinate system to the xPos,yPos
    this.ctx.translate(this.vpOrgX+this.xoffset+xPos*this.xscl, this.vpOrgY+this.yoffset+yPos*this.yscl);
    degs += pathObj.imgDegs;
    if (degs)
    {
      A = (this.yscl&gt;0)? -degs*Math.PI/180.0: degs*Math.PI/180.0;   // radians
      sinA = Math.sin(A);
      cosA = Math.cos(A);
      this.ctx.rotate(-A);   // rotate
    }
    // now insert the image origin with lorg offsets and scaled in width
    this.ctx.drawImage(img, this.xscl*scale*(pathObj.imgX+pathObj.imgLorgX),
                            this.xscl*scale*(pathObj.imgY+pathObj.imgLorgY),
                            this.xscl*scale*pathObj.width, this.xscl*scale*pathObj.height);

    this.ctx.restore();    // undo the transforms (and drop shadow settings)
    // now transform the bounding box drawCmd.parms to pixels (it is used to draw a border if any, and dragNdrop)
    pathObj.bBoxCmds.forEach(function(drwcmd){  // step through the draw segments
      var pt, drwOrg;
      if (drwcmd.parms.length)       // skip final closePath, no cPts ie parms length==0
      {
        if (degs)
        {
          pt = rotXY(drwcmd.parms[0]);  // rotate each coords - don't alter the original
        }
        else
        {
          pt = [drwcmd.parms[0][0], drwcmd.parms[0][1]];     // take a copy
        }
        // convert a bounding box corner to pixels, use x axis units (Y +ve UP) apply any scale factor too
        pt[0] *= scale*savThis.xscl;
        pt[1] *= -scale*savThis.xscl;
        drwOrg = savThis.toPixelCoords(xPos, yPos);   // convert the drawing origin to pixels
        drwcmd.parmsPx[0] = pt[0] + drwOrg.x;
        drwcmd.parmsPx[1] = pt[1] + drwOrg.y;
      }
    });
    if (pathObj.border)
    {
      this.ctx.save();   // save the clean ctx
      this.ctx.beginPath();
      pathObj.bBoxCmds.forEach(function(drwCmd){
        savThis.ctx[drwCmd.drawFn].apply(savThis.ctx, drwCmd.parmsPx);  // call the canvas method for each path segment
      });
      // if properties are undefined use Cango default
      this.ctx.strokeStyle = pathObj.strokeCol || this.penCol;
      this.ctx.lineWidth = pathObj.lineWidth || this.penWid;
      this.ctx.lineCap = pathObj.lineCap || this.lineCap;
      this.ctx.stroke();
      this.ctx.restore();    // undo the transforms (and drop shadow settings)
    }
    // save world coords of the drawing origin for drag n drop
    pathObj.dwgOrg.x = xPos;
    pathObj.dwgOrg.y = yPos;

    if (pathObj.dragNdrop !== null)
    {
      // update dragNdrop layer to match this canvas
      currLr = this.getHostLayer();
      if (currLr !== pathObj.dragNdrop.layer)
      {
        if (pathObj.dragNdrop.layer)  // if not the first time rendered
        {
          // remove the object reference from the old layer
          aidx = pathObj.dragNdrop.layer.dragObjects.indexOf(this);
          if (aidx !== -1)
          {
            pathObj.dragNdrop.layer.dragObjects.splice(aidx, 1);
          }
        }
      }
      pathObj.dragNdrop.cgo = this;
      pathObj.dragNdrop.layer = currLr;
      // now push it into Cango.dragObjects array, its checked by canvas mousedown event handler
      if (pathObj.dragNdrop.layer.dragObjects.indexOf(pathObj) === -1)
      {
        pathObj.dragNdrop.layer.dragObjects.push(pathObj);
      }
    }
  };

  Cango.prototype.paintPath = function(pathObj, x, y, scl, degrees)
  {
    // used for type: PATH, SHAPE
    var savThis = this,
        A, sinA, cosA,
        xPos = x || 0,
        yPos = y || 0,
        scale = scl || 1,
        degs = degrees || 0,
        j,
        xPx = this.vpOrgX+this.xoffset+xPos*this.xscl,
        yPx = this.vpOrgY+this.yoffset+yPos*this.yscl,
        xsl = this.xscl,
        ysl = this.yscl,
        col, gradFill,
        currLr, aidx;

    function genLinGrad(lgrad, iso)   // iso is a copy of the object being filled's iso
    {
      var p1x = lgrad.grad[0],
          p1y = lgrad.grad[1],
          p2x = lgrad.grad[2],
          p2y = lgrad.grad[3],
          xScale = savThis.xscl,
          yScale = savThis.yscl,
          grad;

          if (iso)
          {
            yScale = (savThis.yscl&gt;0)? savThis.xscl: -savThis.xscl;
          }
          grad = savThis.ctx.createLinearGradient(xScale*p1x, yScale*p1y, xScale*p2x, yScale*p2y);

      lgrad.colorStops.forEach(function(colStop){grad.addColorStop(colStop[0], colStop[1]);});

      return grad;
    }

    function genRadGrad(rgrad, iso)
    {
      var p1x = rgrad.grad[0],
          p1y = rgrad.grad[1],
          r1 = rgrad.grad[2],
          p2x = rgrad.grad[3],
          p2y = rgrad.grad[4],
          r2 = rgrad.grad[5],
          xScale = savThis.xscl,
          yScale = savThis.yscl,
          grad;

          if (iso)
          {
            yScale = (savThis.yscl&gt;0)? savThis.xscl: -savThis.xscl;
          }
          grad = savThis.ctx.createRadialGradient(xScale*p1x, yScale*p1y, xScale*r1, xScale*p2x, yScale*p2y, xScale*r2);

      rgrad.colorStops.forEach(function(colStop){grad.addColorStop(colStop[0], colStop[1]);});

      return grad;
    }

    function rotXY(p)
    {
      return [p[0]*cosA - p[1]*sinA, p[0]*sinA + p[1]*cosA];
    }

    if (pathObj.iso)
    {
      ysl = (this.yscl&gt;0)? this.xscl: -this.xscl;
    }
    // don't use canvas matrix rotation or the gradient patterns will be rotated
    if (degs)
    {
      A = (this.yscl&gt;0)? -degs*Math.PI/180.0: degs*Math.PI/180.0;   // radians
      sinA = Math.sin(A);
      cosA = Math.cos(A);
    }
    this.ctx.save();   // save current context
    // set up dropShadow if any
    this.dropShadow(pathObj, scale);
    // use canvas translation and scaling so gradient fill follow the object drawing origin and size
    this.ctx.translate(xPx, yPx);
    this.ctx.scale(scale, scale);
    // build the path by converting the world coord parms of each DrawCmd to parmPx
    // these can then be uses in drag and drop pointInpath testing
    this.ctx.beginPath();

    pathObj.drawCmds.forEach(function(drwCmd){
        drwCmd.parmsPx = [];   // start with new array
        drwCmd.parms.forEach(function(coord){
        var pt;
        if (degs)
        {
          pt = rotXY(coord);  // rotate each coord
        }
        else
        {
          pt = [coord[0], coord[1]];     // take a copy
        }
        // convert the coord pair to pixels, (if iso,  ysl is -this.xscl for Cartesian or this.xscl for SVG)
        pt[0] *= xsl;
        pt[1] *= ysl;
        drwCmd.parmsPx.push(pt[0], pt[1]);
      });
      savThis.ctx[drwCmd.drawFn].apply(savThis.ctx, drwCmd.parmsPx); // add the path segment
    });

    if (pathObj.type === "SHAPE")      // if a SHAPE, fill with color
    {
      col = pathObj.fillCol || this.paintCol;
      if (col instanceof LinearGradient)
      {
        gradFill = genLinGrad(col, pathObj.iso);
        this.ctx.fillStyle = gradFill;
      }
      else if (col instanceof RadialGradient)
      {
        gradFill = genRadGrad(col, pathObj.iso);
        this.ctx.fillStyle = gradFill;
      }
      else
      {
        this.ctx.fillStyle = col;
      }
      this.ctx.fill();
      // clear drop shadow its done (and we might want to stroke border, with no extra shadow)
      this.ctx.shadowOffsetX = 0;
      this.ctx.shadowOffsetY = 0;
      this.ctx.shadowBlur = 0;
    }
    if ((pathObj.type === "PATH")|| pathObj.border)
    {
      // handle dashed lines
      if (pathObj.dashed)
      {
        this.ctx.setLineDash(pathObj.dashed);
        this.ctx.lineDashOffset = pathObj.dashOffset;
      }
      // if properties are undefined use Cango default
      this.ctx.strokeStyle = pathObj.strokeCol || this.penCol;
      this.ctx.lineWidth = pathObj.lineWidth || this.penWid;
      this.ctx.lineCap = pathObj.lineCap || this.lineCap;
      this.ctx.stroke();
    }
    // undo the translation and scaling
    this.ctx.restore();
    // correct the pixel outline for any scaling and shift of drawing origin
    pathObj.drawCmds.forEach(function(drwCmd){
      for (j=0; j &lt; drwCmd.parms.length; j++)      // there are half the number of parms than parmsPx
      {
        drwCmd.parmsPx[2*j] = drwCmd.parmsPx[2*j]*scale + xPx;
        drwCmd.parmsPx[2*j+1] = drwCmd.parmsPx[2*j+1]*scale + yPx;
      }
    });
    // save world coords of the drawing origin for drag n drop
    pathObj.dwgOrg.x = xPos;
    pathObj.dwgOrg.y = yPos;
    if (pathObj.dragNdrop !== null)
    {
      // update dragNdrop layer to match this canavs
      currLr = this.getHostLayer();
      if (currLr !== pathObj.dragNdrop.layer)
      {
        if (pathObj.dragNdrop.layer)  // if not the first time rendered
        {
          // remove the object reference from the old layer
          aidx = pathObj.dragNdrop.layer.dragObjects.indexOf(this);
          if (aidx !== -1)
          {
            pathObj.dragNdrop.layer.dragObjects.splice(aidx, 1);
          }
        }
      }
      pathObj.dragNdrop.cgo = this;
      pathObj.dragNdrop.layer = currLr;
      // now push it into Cango.dragObjects array, its checked by canvas mousedown event handler
      if (pathObj.dragNdrop.layer.dragObjects.indexOf(pathObj) === -1)
      {
        pathObj.dragNdrop.layer.dragObjects.push(pathObj);
      }
    }
  };

  Cango.prototype.paintText = function(pathObj, x, y, scl, degrees)
  {
    var savThis = this,
        A = 0,
        sinA, cosA,
        xPos = x || 0,
        yPos = y || 0,
        xScale = scl || 1,
        scale = xScale*pathObj.imgXscale,  // imgXscale is from Cobj.scale() (permanent)
        degs = degrees || 0,
        fntWt, fntSz, fntFm,
        currLr, aidx;

    function rotXY(p)
    {
      return [p[0]*cosA - p[1]*sinA, p[0]*sinA + p[1]*cosA];
    }

    // translate, rotate, scale must be handled at render time
    this.ctx.save();   // save current context
    // set up dropShadow if any
    this.dropShadow(pathObj, scale);
    // only the x, y passed to render are in non-iso coords (ie use yscl)
    this.ctx.translate(this.vpOrgX+this.xoffset+xPos*this.xscl, this.vpOrgY+this.yoffset+yPos*this.yscl);
    this.ctx.scale(scale, scale);
    degs += pathObj.imgDegs;
    if (degs)
    {
      A = (this.yscl&gt;0)? -degs*Math.PI/180.0: degs*Math.PI/180.0;   // radians
      sinA = Math.sin(A);
      cosA = Math.cos(A);
      this.ctx.rotate(-A);   // rotate
    }
    // if Cobj fontWeight or fontSize undefined use Cango default
    fntWt = pathObj.fontWeight || this.fontWeight;
    fntSz = pathObj.fontSize || this.fontSize;
    fntFm = pathObj.fontFamily || this.fontFamily;
    this.ctx.font = fntWt+" "+fntSz+"px "+fntFm;
    // set the fillStyle to obj.fillCol for text
    this.ctx.fillStyle = pathObj.fillCol || this.paintCol;
    // now actually fill the text (text referenced from baseline (image from top) so use -xscl)
    this.ctx.fillText(pathObj.drawCmds,
                      this.xscl*(pathObj.imgX+pathObj.imgLorgX),
                      -this.xscl*(pathObj.imgY+pathObj.imgLorgY));
    if (pathObj.border)
    {
      // fill done, if dropShadow dont apply to the border (it will be on top of fill)
      this.ctx.shadowOffsetX = 0;
      this.ctx.shadowOffsetY = 0;
      this.ctx.shadowBlur = 0;
      // if properties are undefined use Cango default
      this.ctx.strokeStyle = pathObj.strokeCol || this.penCol;
      this.ctx.lineWidth = pathObj.lineWidth || this.penWid;
      this.ctx.lineCap = pathObj.lineCap || this.lineCap;
      // now actually fill the text
      this.ctx.strokeText(pathObj.drawCmds,
                          this.xscl*(pathObj.imgX+pathObj.imgLorgX),
                          -this.xscl*(pathObj.imgY+pathObj.imgLorgY));
    }
    // undo the rotation, translation and scaling
    this.ctx.restore();
    // now transform the bounding box
    pathObj.bBoxCmds.forEach(function(drwcmd){  // step through the draw segments
      var pt, drwOrg;
      if (drwcmd.parms.length)     // skip final closePath, no cPts ie parms length==0
      {
        if (degs)
        {
          pt = rotXY(drwcmd.parms[0]);  // rotate each coords - don't alter the original
        }
        else
        {
          pt = [drwcmd.parms[0][0], drwcmd.parms[0][1]];     // take a copy
        }
        // convert a bounding box corner to pixels, use x axis units (Y +ve UP) apply any scale factor too
        pt[0] *= scale*savThis.xscl;
        pt[1] *= -scale*savThis.xscl;
        drwOrg = savThis.toPixelCoords(xPos, yPos);   // convert the drawing origin to pixels
        drwcmd.parmsPx[0] = pt[0] + drwOrg.x;
        drwcmd.parmsPx[1] = pt[1] + drwOrg.y;
      }
    });
    // save world coords of the drawing origin (often useful in drag n drop)
    pathObj.dwgOrg.x = xPos;
    pathObj.dwgOrg.y = yPos;
    if (pathObj.dragNdrop !== null)
    {
      // update dragNdrop layer to match this canavs
      currLr = this.getHostLayer();
      if (currLr !== pathObj.dragNdrop.layer)
      {
        if (pathObj.dragNdrop.layer)  // if not the first time rendered
        {
          // remove the object reference from the old layer
          aidx = pathObj.dragNdrop.layer.dragObjects.indexOf(this);
          if (aidx !== -1)
          {
            pathObj.dragNdrop.layer.dragObjects.splice(aidx, 1);
          }
        }
      }
      pathObj.dragNdrop.cgo = this;
      pathObj.dragNdrop.layer = currLr;
      // now push it into Cango.dragObjects array, its checked by canvas mousedown event handler
      if (pathObj.dragNdrop.layer.dragObjects.indexOf(pathObj) === -1)
      {
        pathObj.dragNdrop.layer.dragObjects.push(pathObj);
      }
    }
  };

  Cango.prototype.drawPath = function(path, x, y, options)
  {
    var pathObj = new Cobj(path, "PATH", options);
    this.render(pathObj, x, y);

    return pathObj;
  };

  Cango.prototype.drawShape = function(path, x, y, options)
  {
    var shapeObj = new Cobj(path, "SHAPE", options);
    this.render(shapeObj, x, y);

    return shapeObj;
  };

  Cango.prototype.drawText = function(str, x, y, options)
  {
    var txtObj = new Cobj(str, "TEXT", options);
    this.render(txtObj, x, y);

    return txtObj;
  };

  Cango.prototype.drawImg = function(imgURL, x, y, options)
  {
    var imgObj = new Cobj(imgURL, "IMG", options);
    this.render(imgObj, x, y);

    return imgObj;
  };

  Cango.prototype.clipPath = function(pathObj)
  {
    var savThis = this,
        xsl, ysl;

    if ((pathObj.type === "IMG")||(pathObj.type === "TEXT"))
    {
      return;
    }
    xsl = this.xscl;
    ysl = this.yscl;
    if (pathObj.iso)
    {
      ysl = (this.yscl&gt;0)? this.xscl: -this.xscl;
    }
    this.ctx.save();             // undo using resetClip method
    this.ctx.beginPath();
    pathObj.drawCmds.forEach(function(drwCmd){
        var px, py,
            pxlCoords = [];             // make a new array for each drawCmd
        drwCmd.parms.forEach(function(coord){
        // convert the coord pair to pixels, (if iso,  ysl is -this.xscl for Cartesian or this.xscl for SVG)
        px = savThis.vpOrgX+savThis.xoffset+xsl*coord[0];
        py = savThis.vpOrgY+savThis.yoffset+ysl*coord[1];
        pxlCoords.push(px, py);
      });
      savThis.ctx[drwCmd.drawFn].apply(savThis.ctx, pxlCoords); // add the path segment
    });
    this.ctx.clip();
  };

  Cango.prototype.resetClip = function()
  {
    this.ctx.restore();
  };

  Cango.prototype.createLayer = function()
  {
    var ovlHTML, newCvs,
        w = this.rawWidth,
        h = this.rawHeight,
        unique, ovlId,
        nLyrs = this.bkgCanvas.layers.length,  // bkg is layer 0 so at least 1
        newL,
        topCvs;

    // do not create layers on overlays - only an background canvases
    if (this.cId.indexOf("_ovl_") !== -1)
    {
      // this is an overlay canvas - can't have overlays itself
      console.log("canvas layers can't create layers");
      return "";
    }

    unique = this.getUnique();
    ovlId = this.cId+"_ovl_"+unique;
    ovlHTML = "&lt;canvas id='"+ovlId+"' style='position:absolute' width='"+w+"' height='"+h+"'&gt;&lt;/canvas&gt;";
    topCvs = this.bkgCanvas.layers[nLyrs-1].cElem;  // eqv to this.cnvs.layers since only bkgCanavs can get here
    topCvs.insertAdjacentHTML('afterend', ovlHTML);
    newCvs = document.getElementById(ovlId);
    newCvs.style.backgroundColor = "transparent";
    newCvs.style.left = (this.bkgCanvas.offsetLeft+this.bkgCanvas.clientLeft)+'px';
    newCvs.style.top = (this.bkgCanvas.offsetTop+this.bkgCanvas.clientTop)+'px';
    // make it the same size as the background canvas
    newCvs.style.width = this.bkgCanvas.offsetWidth+'px';
    newCvs.style.height = this.bkgCanvas.offsetHeight+'px';
//    newCvs.style.pointerEvents = 'none';    // allow mouse events to pass down to bkgCanvas
    newL = new Layer(ovlId, newCvs);
    // save the ID in an array to facilitate removal
    this.bkgCanvas.layers.push(newL);

    return ovlId;    // return the new canvas id for call to new Cango(id)
  };

  Cango.prototype.deleteLayer = function(ovlyId)
  {
    var ovlNode, i;

    for (i=1; i&lt;this.bkgCanvas.layers.length; i++)
    {
      if (this.bkgCanvas.layers[i].id === ovlyId)
      {
        ovlNode = this.bkgCanvas.layers[i].cElem;
        if (ovlNode)
        {
          // in case the CangoHTMLtext extension is used
          if (ovlNode.alphaOvl &amp;&amp; ovlNode.alphaOvl.parentNode)
          {
            ovlNode.alphaOvl.parentNode.removeChild(ovlNode.alphaOvl);
          }
          ovlNode.parentNode.removeChild(ovlNode);
        }
        // now delete layers array element
        this.bkgCanvas.layers.splice(i,1);       // delete the id
      }
    }
  };

  Cango.prototype.deleteAllLayers = function()
  {
    var i, ovlNode;

    for (i = this.bkgCanvas.layers.length-1; i&gt;0; i--)   // don't delete layers[0] its the bkg canvas
    {
      ovlNode = this.bkgCanvas.layers[i].cElem;
      if (ovlNode)
      {
        // in case the CangoHTMLtext extension is used
        if (ovlNode.alphaOvl &amp;&amp; ovlNode.alphaOvl.parentNode)
        {
          ovlNode.alphaOvl.parentNode.removeChild(ovlNode.alphaOvl);
        }
        ovlNode.parentNode.removeChild(ovlNode);
      }
      // now delete layers array element
      this.bkgCanvas.layers.splice(i,1);
    }
  };

  // copy the basic graphics context values (for an overlay)
  Cango.prototype.dupCtx = function(src_graphCtx)
  {
    // copy all the graphics context parameters into the overlay ctx.
    this.vpW = src_graphCtx.vpW;          // vp width in pixels
    this.vpH = src_graphCtx.vpH;          // vp height in pixels
    this.vpOrgX = src_graphCtx.vpOrgX;    // vp origin X &amp; Y in pixels (lower left for Cartesian
    this.vpOrgY = src_graphCtx.vpOrgY;    //                            upper left for SVG)
    this.xscl = src_graphCtx.xscl;        // world x axis scale factor
    this.yscl = src_graphCtx.yscl;        // world y axis scale factor
    this.xoffset = src_graphCtx.xoffset;  // world x origin offset from viewport left in pixels
    this.yoffset = src_graphCtx.yoffset;  // world y origin offset from viewport bottom in pixels
    this.savWC = clone(src_graphCtx.savWC);
    this.penCol = src_graphCtx.penCol.slice(0);   // copy value not reference
    this.penWid = src_graphCtx.penWid;    // pixels
    this.lineCap = src_graphCtx.lineCap.slice(0);
    this.paintCol = src_graphCtx.paintCol.slice(0);
    this.fontFamily = src_graphCtx.fontFamily.slice(0);
    this.fontSize = src_graphCtx.fontSize;
    this.fontWeight = src_graphCtx.fontWeight;
  };

  Cango.prototype.toImgObj = function(obj)
  {
    // find the bounding box
    var top, rgt, bot, lft,
        dx, dy, w, h,
        xsc = this.xscl,
        ysc = this.yscl,
        buf, gc,
        imgObj = new Cobj("", "IMG"),
        i, j;

    if ((obj.type !== 'PATH')&amp;&amp;(obj.type !== 'SHAPE'))
    {
      return null;
    }
    if (obj.iso)
    {
      ysc = (this.yscl&gt;0)? this.xscl: -this.xscl;
    }
    // find pixel dimensions of the obj bounding box
    lft = rgt = obj.drawCmds[0].parms[0][0];
    bot = top = obj.drawCmds[0].parms[0][1];
    for (i=1; i &lt; obj.drawCmds.length; i++)
    {
      for (j=0; j &lt; obj.drawCmds[i].parms.length; j++)
      {
        // step through each draw command and find max and min end point or control point
        if (obj.drawCmds[i].parms[j][0] &gt; rgt)
        {
          rgt = obj.drawCmds[i].parms[j][0];
        }
        if  (obj.drawCmds[i].parms[j][0] &lt; lft)
        {
          lft = obj.drawCmds[i].parms[j][0];
        }
        if (obj.drawCmds[i].parms[j][1] &gt; top)
        {
          top = obj.drawCmds[i].parms[j][1];
        }
        if  (obj.drawCmds[i].parms[j][1] &lt; bot)
        {
          bot = obj.drawCmds[i].parms[j][1];
        }
      }
    }

    dx = lft*xsc-2;         // add a couple of pixels for aliasing
    dy = (this.yscl&gt;0)? bot*ysc-2: bot*ysc+2;
    w = (rgt - lft)*xsc+4;
    h = (this.yscl&gt;0)? (top - bot)*ysc+4: (bot - top)*ysc+4;
    buf = document.createElement('canvas');    // create buffer in memory
    buf.setAttribute('width', w);
    buf.setAttribute('height', h);
    gc = new Cango(this.cId);
    gc.dupCtx(this);
    // now patch up the Cango context for paintPath
    gc.cnvs = buf;
    gc.cId = "_sprite_";
    gc.ctx = gc.cnvs.getContext('2d');    // draw direct to screen canvas
    gc.rawWidth = w;              // width and height are like Image object
    gc.rawHeight = h;
    gc.vpW = gc.rawWidth;         // vp width in pixels (default to full canvas size)
    gc.vpH = gc.rawHeight;        // vp height in pixels
    gc.vpOrgX = 0;                // vp lower left from canvas left in pixels
    gc.vpOrgY = (this.yscl&gt;0)? 0: gc.rawHeight;      // vp lower left from canvas top
    gc.xoffset = -dx;             // drawn at current pixel resolution
    gc.yoffset = -dy;
    // render the obj
    this.paintPath.call(gc, obj);  // paint obj dwgOrg at 0,0
    // img is rendered at pixel resolution (*xscl). The reference width is in world coords
    // corrected by the scale factor 'imgXscale', so fix this for current world coords
    imgObj.imgXscale = 1/this.xscl;
    // start to load the image (if not loaded at render, render will start 'onload' event)
    imgObj.imgBuf.src = gc.cnvs.toDataURL();

    return imgObj;
  };

  return Cango;
}());
</t>
<t tx="amd.20151125094858.1">/*==========================================================================
  Filename: Cango2D-6v13.js
  Rev: 6
  By: A.R.Collins
  Description: A 2D graphics library for the canvas element designed for
               simple animated applications.
  License: Released into the public domain, latest version at
           &lt;http://www.arc.id.au/CanvasGraphics.html&gt;
           Please give credit to A.R.Collins &lt;http://www.arc.id.au&gt;
  Report bugs to tony at arc.id.au

  Date   |Description                                                   |By
  --------------------------------------------------------------------------
  12Sep13 Version 1.00 release, from Rev 0v86                            ARC
  23May14 Update to include improvements made to Cango-4v09
          Released as Version 2v00                                       ARC
  29May14 Added ellipse to shapeDefs
          Use setProperty in constructor not duplicated code             ARC
  30May14 Drop fontWeight arugument from compileText
          Changed font to Inconsolata (Inconsolata-dz)                   ARC
  07Jun14 Changed font to Consolas, Monaco, "Andale Mono", monospace
          Removed redundant Obj2D hardtransform code                     ARC
  09Jun14 Restored immediate hardTransform not redundant after all       ARC
  14Jun14 bugfix: grp.enableDrag only 2 generations deep, make recursive ARC
  15Jun14 renamed Drag2D parent to target for clarity                    ARC
  18Jun14 Revamp the Drag2D add target and grabCsrPos
          bugfix: check type of cgo not pathObj in clipPath              ARC
  22Jun14 Remove useless iso references                                  ARC
  18Jul14 Upgrade appendPath to use clone not reference to drawCmds      ARC
  21Jul14 Remove global buffers use canvas properties instead.
          Add support for Obj2D borders.
          Add dropShadow support.                                        ARC
  22Jul14 bugfix: scl, rot, rev animateTransform ignoring static values  ARC
  23Jul14 Re-write animation methods use Timeline object to synchronise
          animations across all layers.
          Inhibit layers creating layers on themselves.                  ARC
  24Jul14 bugfix: layer position not correcting for bkgCanvas borders    ARC
  27Jul14 Upgrade layer handling using Layer object
          Upgrade dragNdrop so obj or groups on any layer are draggable  ARC
  28Jul14 Use Drag2D not DnD, that is for the simpler Cango version      ARC
  04Aug14 bugfix: TEXT border not drawn, text filled with strokeColor    ARC
  09Aug14 bugfix: vpW &amp; vpH not duplicated by dupCtx.
          Modify text render to use 'bottom' baseline, it has consistant
          behaviour across all browsers.                                 ARC
  21Nov14 Change font size units from points to pixels
          Added fontFamily as Obj2D property                             ARC
  18Dec14 Use relative SVG coords in shapeDefs so concat works           ARC
  11Jan15 Added shapeDefs.rectangle with optional rounded corners        ARC
  10Feb15 Drop the compile commands, chnage draw command arguments
          Add dashed line support                                        ARC
  11Feb15 bugfix: Group2D.scale was used the same x and y scaling
          Released as Version 4v00                                       ARC
  16Feb15 Add LinearGradient and RadialGraient global objects
          Drop lineraGradientFill &amp; radialGradientFill methods
          Drop setDropShadow method just use Cobj properties             ARC
  23Mar15 bugfix: Bad radius scaling of radial gradients for path/shapes
          Change DrawCmd parms to be [[x,y],[x1,y1], ... ] so reduce,
          map and forEach can be used to clean up code
          Change to delayed Image load (slower but more robust)          ARC
  24Mar15 Released as Version 5                                          ARC
  21Jun15 Add transform.skew                                             ARC
  22Jun15 Add Obj2D.transform.distort and Distorter constructor          ARC
  23Jun15 Added parmsOrg property to DrawCmd object for use by distort   ARC
  24Jun15 Make Distorter's internal add transform.bend                   ARC
  25Jun15 Removed offscreen buffering, modern browsers handle this
          Cleaned up transform matrix code for brevity
          Apply bend to Group2Ds by recusion                             ARC
  26Jun15 Refactor the way the transforms are applied to the tree        ARC
  27Jun15 Claned up recursive functions with forEach                     ARC
  02Jul15 Drop animateTransform in favour of transform using Tweeners
          Released as Version 6                                          ARC
  12Jul15 Accumulate transforms as Distrorter objects not matrices
          bugfix: skew angles were not +ve CCW                           ARC
  13Jul15 For simplicity don't use matrices in PATH  &amp; SHAPE transforms  ARC
  17Jul15 bugfix: grpTfm for TEXT and IMG not updated in applyXfms
          use local variables for group transform references             ARC
  11Aug15 Created Path,Shape,Img &amp; Text types
          Don't wait till render time to load images                     ARC
  ==========================================================================*/

  // exposed globals
var Obj2D, LinearGradient, RadialGradient, Group2D, Tweener,
    svgToCgo2D, // SVG path data string conversion utility function
    shapeDefs;  // predefined geometric shapes in Cgo2D format

var Cango2D = (function()
{
  "use strict";

  var uniqueVal = 0,    // used to generate unique value for different Cango2D instances
      svgParser,
      cgo2DtoDrawCmd;

  function addEvent(element, eventType, handler)
  {
    if (element.attachEvent)
    {
     return element.attachEvent('on'+eventType, handler);
    }
    return element.addEventListener(eventType, handler);
  }

  function clone(orgItem)
  {
    var newItem = (isArray(orgItem)) ? [] : {},
        i;
    for (i in orgItem)
    {
      if (orgItem[i] &amp;&amp; typeof orgItem[i] === "object")
      {
        newItem[i] = clone(orgItem[i]);
      }
      else
      {
        newItem[i] = orgItem[i];
      }
    }
    return newItem;
  }

  if (!Date.now)
  {
    Date.now = function now()
    {
      return new Date().getTime();
    };
  }

  var isArray = function(obj)
  {
    return Object.prototype.toString.call(obj) === '[object Array]';
  };

  if (!Array.prototype.contains)
  {
    Array.prototype.contains = function (v)
    {
      return this.indexOf(v) &gt; -1;
    };
  }

  /* =============================================================================
   * Convert Cgo2D data array ['M',x,y, 'L',x1,y1, ... 'Q',cx,cy,x2,y2, 'A',r,r ...]
   * to array of canvas DrawCmd {drawFn:'moveTo', [x,y]}
   * ----------------------------------------------------------------------------*/
  svgParser = (function ()
  {
    var segmentToBezier = function(cx, cy, th0, th1, rx, ry, sin_th, cos_th) {
          var a00 = cos_th * rx,
              a01 = -sin_th * ry,
              a10 = sin_th * rx,
              a11 = cos_th * ry,
              th_half = 0.5 * (th1 - th0),
              t = (8/3) * Math.sin(th_half * 0.5) * Math.sin(th_half * 0.5) / Math.sin(th_half),
              x1 = cx + Math.cos(th0) - t * Math.sin(th0),
              y1 = cy + Math.sin(th0) + t * Math.cos(th0),
              x3 = cx + Math.cos(th1),
              y3 = cy + Math.sin(th1),
              x2 = x3 + t * Math.sin(th1),
              y2 = y3 - t * Math.cos(th1);

          return [ a00 * x1 + a01 * y1, a10 * x1 + a11 * y1,
                   a00 * x2 + a01 * y2, a10 * x2 + a11 * y2,
                   a00 * x3 + a01 * y3, a10 * x3 + a11 * y3 ];
        },
        arcToBezier = function(ox, oy, radx, rady, rotateX, large, sweep, x, y)
        {
          var th = rotateX * (Math.PI/180),
              sin_th = Math.sin(th),
              cos_th = Math.cos(th),
              rx = Math.abs(radx),
              ry = Math.abs(rady),
              px = cos_th * (ox - x) * 0.5 + sin_th * (oy - y) * 0.5,
              py = cos_th * (oy - y) * 0.5 - sin_th * (ox - x) * 0.5,
              pl = (px*px) / (rx*rx) + (py*py) / (ry*ry),
              a00, a01, a10, a11,
              x0, y0, x1, y1,
              d,
              sfactor_sq,
              sfactor,
              xc, yc,
              th0, th1,
              th_arc,
              segments,
              seg, tidySeg,
              result = [],
              i, th2, th3;

          function roundZeros(coord)
          {
            return ((Math.abs(coord) &lt; 0.00001)? 0: coord);
          }

          if (pl &gt; 1)
          {
            pl = Math.sqrt(pl);
            rx *= pl;
            ry *= pl;
          }
          a00 = cos_th / rx;
          a01 = sin_th / rx;
          a10 = -sin_th / ry;
          a11 = cos_th / ry;
          x0 = a00 * ox + a01 * oy;
          y0 = a10 * ox + a11 * oy;
          x1 = a00 * x + a01 * y;
          y1 = a10 * x + a11 * y;
          d = (x1-x0) * (x1-x0) + (y1-y0) * (y1-y0);
          sfactor_sq = 1 / d - 0.25;
          if (sfactor_sq &lt; 0)
          {
            sfactor_sq = 0;
          }
          sfactor = Math.sqrt(sfactor_sq);
          if (sweep === large)
          {
            sfactor = -sfactor;
          }
          xc = 0.5 * (x0 + x1) - sfactor * (y1-y0);
          yc = 0.5 * (y0 + y1) + sfactor * (x1-x0);
          th0 = Math.atan2(y0-yc, x0-xc);
          th1 = Math.atan2(y1-yc, x1-xc);
          th_arc = th1-th0;
          if (th_arc &lt; 0 &amp;&amp; sweep === 1)
          {
            th_arc += 2*Math.PI;
          }
          else if (th_arc &gt; 0 &amp;&amp; sweep === 0)
          {
            th_arc -= 2 * Math.PI;
          }
          segments = Math.ceil(Math.abs(th_arc / (Math.PI * 0.5 + 0.001)));
          for (i=0; i&lt;segments; i++)
          {
            th2 = th0 + i * th_arc / segments;
            th3 = th0 + (i+1) * th_arc / segments;
            seg = segmentToBezier(xc, yc, th2, th3, rx, ry, sin_th, cos_th);
            tidySeg = seg.map(roundZeros);
            result.push(tidySeg);
          }

          return result;
        },
        /*===============================================
         *
         * svgProtocol object defining each command
         * with methods to convert to Cgo2D for both
         * cartesian and SVG coordinate systems
         *
         *==============================================*/
        svgProtocol = {
          "M": {
            canvasMethod: "moveTo",
            parmCount: 2,
            extCmd: "L",
            toAbs: function(acc, curr) {
              var cmd = curr[0].toUpperCase(),  // uppercase command means absolute coords
                  x = curr[1],
                  y = curr[2],
                  currAbs;
              // Check if 'curr' was a relative (lowercase) command
              if (cmd !== curr[0]) {
                x += acc.px;
                y += acc.py;
              }
              currAbs = [cmd, x, y];
              acc.px = x;
              acc.py = y;
              return currAbs;
            },
            toCangoVersion: function(acc, curr) {
              var x = curr[1],
                  y = curr[2];

              acc.px = x;  // update the pen position for next command
              acc.py = y;
              acc.push(curr); // push the curr, "M" is a Cango internal command
            },
            addXYoffset: function(curr, xOfs, yOfs){
              var x = curr[1],
                  y = curr[2];

              x += xOfs;
              y += yOfs;
              return ["M", x, y];   // invert y coords to make Cgo2D format
            },
            invertCoords: function(curr){
              var x = curr[1],
                  y = curr[2];

              return ["M", x, -y];   // invert y coords to make Cgo2D format
            }
          },
          "L": {
            canvasMethod: "lineTo",
            parmCount: 2,
            extCmd: "L",
            toAbs: function(acc, curr) {
              var cmd = curr[0].toUpperCase(),  // uppercase command means absolute coords
                  x = curr[1],
                  y = curr[2],
                  currAbs;
              // Check if 'curr' was a relative (lowercase) command
              if (cmd !== curr[0]) {
                x += acc.px;
                y += acc.py;
              }
              currAbs = [cmd, x, y];
              acc.px = x;
              acc.py = y;
              return currAbs;
            },
            toCangoVersion: function(acc, curr) {
              var x = curr[1],
                  y = curr[2];

              acc.px = x;  // update the pen position for next command
              acc.py = y;
              acc.push(curr); // push the curr, "L" is a Cango internal command
            },
            addXYoffset: function(curr, xOfs, yOfs){
              var x = curr[1],
                  y = curr[2];

              x += xOfs;
              y += yOfs;
              return ["L", x, y];   // invert y coords to make Cgo2D format
            },
            invertCoords: function(curr){
              var x = curr[1],
                  y = curr[2];

              return ["L", x, -y];   // invert y coords to make Cgo2D format
            }
          },
          "H": {
            parmCount: 1,
            extCmd: "H",
            toAbs: function(acc, curr) {
              var cmd = curr[0].toUpperCase(),   // uppercase command means absolute coords
                  x = curr[1],
                  currAbs;
              // Check if 'curr' was a relative (lowercase) command
              if (cmd !== curr[0]) {
                x += acc.px;
              }
              currAbs = [cmd, x];
              acc.px = x;        // save the new pen position
              return currAbs;
            },
            toCangoVersion: function(acc, curr) {
              var x = curr[1],
                  y = acc.py,
                  cangoVer = ["L", x, y];

              acc.px = x;        // save the new pen position
              acc.push(cangoVer);
            },
            addXYoffset: function(curr, xOfs, yOfs){
              var x = curr[1];

              x += xOfs;
              return ["H", x];
            },
            invertCoords: function(curr){
              var x = curr[1];

              return ["H", x];
            }
          },
          "V": {
            parmCount: 1,
            extCmd: "V",
            toAbs: function(acc, curr) {
              var cmd = curr[0].toUpperCase(),   // uppercase command means absolute coords
                  y = curr[1],
                  currAbs;
              // Check if 'curr' was a relative (lowercase) command
              if (cmd !== curr[0]) {
                y += acc.py;
              }
              currAbs = [cmd, y];
              acc.py = y;        // save the new pen position
              return currAbs;
            },
            toCangoVersion: function(acc, curr) {
              var x = acc.px,
                  y = curr[1],
                  cangoVer = ["L", x, y];

              acc.py = y;        // save the new pen position
              acc.push(cangoVer);
            },
            addXYoffset: function(curr, xOfs, yOfs){
              var y = curr[1];

              y += yOfs;
              return ["V", y];    // invert y coords to make Cgo2D format
            },
            invertCoords: function(curr){
              var y = curr[1];

              return ["V", -y];    // invert y coords to make Cgo2D format
            }
          },
          "C": {       // Cubic Bezier curve
            canvasMethod: "bezierCurveTo",
            parmCount: 6,
            extCmd: "C",
            toAbs: function(acc, curr) {
              var cmd = curr[0].toUpperCase(),  // uppercase command means absolute coords
                  c1x = curr[1],
                  c1y = curr[2],
                  c2x = curr[3],
                  c2y = curr[4],
                  x = curr[5],
                  y = curr[6],
                  currAbs;
              // Check if 'curr' was a relative (lowercase) command
              if (cmd !== curr[0]) {
                c1x += acc.px;
                c1y += acc.py;
                c2x += acc.px;
                c2y += acc.py;
                x += acc.px;
                y += acc.py;
              }
              currAbs = [cmd, c1x, c1y, c2x, c2y, x, y];
              acc.px = x;
              acc.py = y;
              return currAbs;
            },
            toCangoVersion: function(acc, curr) {
              var x = curr[5],
                  y = curr[6];

              acc.px = x;  // update the pen position for next command
              acc.py = y;
              acc.push(curr); // push the curr, "C" is a Cango internal command
            },
            addXYoffset: function(curr, xOfs, yOfs){
              var c1x = curr[1],
                  c1y = curr[2],
                  c2x = curr[3],
                  c2y = curr[4],
                  x = curr[5],
                  y = curr[6];

                c1x += xOfs;
                c1y += yOfs;
                c2x += xOfs;
                c2y += yOfs;
                x += xOfs;
                y += yOfs;
              return ["C", c1x, c1y, c2x, c2y, x, y]; // invert y coords
            },
            invertCoords: function(curr){
              var c1x = curr[1],
                  c1y = curr[2],
                  c2x = curr[3],
                  c2y = curr[4],
                  x = curr[5],
                  y = curr[6];

              return ["C", c1x, -c1y, c2x, -c2y, x, -y]; // invert y coords
            }
          },
          "S": {         // Smooth cubic Bezier curve
            parmCount: 4,
            extCmd: "S",
            toAbs: function(acc, curr) {
              var cmd = curr[0].toUpperCase(),  // uppercase means absolute coords
                  c2x = curr[1],
                  c2y = curr[2],
                  x = curr[3],
                  y = curr[4],
                  currAbs;

              // Check if 'curr' was a relative (lowercase) command
              if (cmd !== curr[0]) {
                c2x += acc.px;
                c2y += acc.py;
                x += acc.px;
                y += acc.py;
              }
              currAbs = [cmd, c2x, c2y, x, y];
              acc.px = x;
              acc.py = y;
              return currAbs;
            },
            toCangoVersion: function(acc, curr, idx) {
              var c1x = 0,    // relative coords of first (mirrored) control point
                  c1y = 0,
                  c2x = curr[1],
                  c2y = curr[2],
                  x = curr[3],
                  y = curr[4],
                  prevSeg = acc[idx-1],
                  cangoVer;

              // if prev segment was a cubic Bezier, mirror its last control point as cp1
              if (prevSeg[0] === "C")              {
                c1x = acc.px - prevSeg[prevSeg.length-4];   // relative coords of cp1
                c1y = acc.py - prevSeg[prevSeg.length-3];
              }
              // make cp1 absolute (all the curr coords are already absolute)
              c1x += acc.px;
              c1y += acc.py;
              cangoVer = ["C", c1x, c1y, c2x, c2y, x, y];  // Cubic Bezier
              acc.px = x;  // update the pen position for next command
              acc.py = y;
              acc.push(cangoVer);
            },
            addXYoffset: function(curr, xOfs, yOfs){
              var c2x = curr[1],
                  c2y = curr[2],
                  x = curr[3],
                  y = curr[4];

              c2x += xOfs;
              c2y += yOfs;
              x += xOfs;
              y += yOfs;
              return ["S", c2x, c2y, x, y];    // invert y coords to make Cgo2D format
            },
            invertCoords: function(curr){
              var c2x = curr[1],
                  c2y = curr[2],
                  x = curr[3],
                  y = curr[4];

              return ["S", c2x, -c2y, x, -y];    // invert y coords to make Cgo2D format
            }
          },
          "Q": {         // Quadratic Bezier curve
            canvasMethod: "quadraticCurveTo",
            parmCount: 4,
            extCmd: "Q",
            toAbs: function(acc, curr) {
              var cmd = curr[0].toUpperCase(),  // uppercase command means absolute coords
                  c1x = curr[1],
                  c1y = curr[2],
                  x = curr[3],
                  y = curr[4],
                  currAbs;
              // Check if 'curr' was a relative (lowercase) command
              if (cmd !== curr[0]) {
                c1x += acc.px;
                c1y += acc.py;
                x += acc.px;
                y += acc.py;
              }
              currAbs = [cmd, c1x, c1y, x, y];
              acc.px = x;
              acc.py = y;
              return currAbs;
            },
            toCangoVersion: function(acc, curr) {
              var x = curr[3],
                  y = curr[4];

              acc.px = x;  // update the pen position for next command
              acc.py = y;
              acc.push(curr); // push the curr, "Q" is a Cango internal command
            },
            addXYoffset: function(curr, xOfs, yOfs){
              var c1x = curr[1],
                  c1y = curr[2],
                  x = curr[3],
                  y = curr[4];

              c1x += xOfs;
              c1y += yOfs;
              x += xOfs;
              y += yOfs;
              return ["Q", c1x, c1y, x, y];    // invert y coords to make Cgo2D format
            },
            invertCoords: function(curr){
              var c1x = curr[1],
                  c1y = curr[2],
                  x = curr[3],
                  y = curr[4];

              return ["Q", c1x, -c1y, x, -y];    // invert y coords to make Cgo2D format
            }
          },
          "T": {         // Smooth Quadratic Bezier curve
            parmCount: 2,
            extCmd: "T",
            toAbs: function(acc, curr) {
              var cmd = curr[0].toUpperCase(),  // uppercase means absolute coords
                  x = curr[1],
                  y = curr[2],
                  currAbs;

              // Check if 'curr' was a relative (lowercase) command
              if (cmd !== curr[0]) {
                x += acc.px;
                y += acc.py;
              }
              currAbs = [cmd, x, y];
              acc.px = x;
              acc.py = y;
              return currAbs;
            },
            toCangoVersion: function(acc, curr, idx) {
              var c1x = 0,    // relative coords of first (mirrored) control point
                  c1y = 0,
                  x = curr[1],
                  y = curr[2],
                  prevSeg = acc[idx-1],
                  cangoVer;

              // if prev segment was quadratic Bezier, mirror its last control point as cp1
              if (prevSeg[0] === "Q")            {
                c1x = acc.px - prevSeg[prevSeg.length-4];   // relative coords of first cp1
                c1y = acc.py - prevSeg[prevSeg.length-3];
              }
              // make cp1 absolute
              c1x += acc.px;
              c1y += acc.py;
              cangoVer = ["Q", c1x, c1y, x, y];   // Quadratic Bezier
              acc.px = x;  // update the pen position for next command
              acc.py = y;
              acc.push(cangoVer);
            },
            addXYoffset: function(curr, xOfs, yOfs){
              var x = curr[1],
                  y = curr[2];

              x += xOfs;
              y += yOfs;
              return ["T", x, y];    // invert y coords to make Cgo2D format
            },
            invertCoords: function(curr){
              var x = curr[1],
                  y = curr[2];

              return ["T", x, -y];    // invert y coords to make Cgo2D format
            }
          },
          "A" : {      // Circular arc
            parmCount: 7,
            extCmd: "A",
            toAbs: function(acc, curr) {
              var cmd = curr[0].toUpperCase(),
                  rx = curr[1],
                  ry = curr[2],
                  xrot = curr[3],     // opposite to SVG in Cartesian coords
                  lrg = curr[4],
                  swp = curr[5],      // opposite to SVG in Cartesian coords
                  x = curr[6],
                  y = curr[7],
                  currAbs;
              // Check if current is a relative (lowercase) command
              if (cmd !== curr[0]) {
                x += acc.px;
                y += acc.py;
              }
              currAbs = [cmd, rx, ry, xrot, lrg, swp, x, y];
              acc.px = x;
              acc.py = y;
              return currAbs;
            },
            toCangoVersion: function(acc, curr) {
              var rx = curr[1],
                  ry = curr[2],
                  xrot = curr[3],     // opposite to SVG in Cartesian coords
                  lrg = curr[4],
                  swp = curr[5],      // opposite to SVG in Cartesian coords
                  x = curr[6],
                  y = curr[7],
                  sectors;

              // convert to (maybe multiple) cubic Bezier curves
              sectors = arcToBezier(acc.px, acc.py, rx, ry, xrot, lrg, swp, x, y);
              // sectors is an array of arrays of Cubic Bezier coords,
              // make a 'C' command from each sector and push it out
              sectors.forEach(function(coordAry){
                acc.push(["C"].concat(coordAry));
              });

              acc.px = x;  // update the pen position for next command
              acc.py = y;
            },
            addXYoffset: function(curr, xOfs, yOfs){
              var rx = curr[1],
                  ry = curr[2],
                  xrot = curr[3],
                  lrg = curr[4],
                  swp = curr[5],
                  x = curr[6],
                  y = curr[7];

              x += xOfs;
              y += yOfs;
              return ["A", rx, ry, xrot, lrg, swp, x, y];  // invert y coords
            },
            invertCoords: function(curr){
              var rx = curr[1],
                  ry = curr[2],
                  xrot = curr[3],
                  lrg = curr[4],
                  swp = curr[5],
                  x = curr[6],
                  y = curr[7];

              return ["A", rx, ry, -xrot, lrg, 1-swp, x, -y];  // invert coords
            }
          },
          "Z": {
            canvasMethod: "closePath",
            parmCount: 0,
            toAbs: function(acc, curr) {
              var cmd = curr[0].toUpperCase(),
                  currAbs = [cmd];
              // leave pen position where it is in case of multi-segment path
              return currAbs;
            },
            toCangoVersion: function(acc, curr) {
              // leave pen position where it is in case of multi-segment path
              acc.push(curr); // push the curr, "Z", its a Cango internal command
            },
            addXYoffset: function(curr, xOfs, yOfs){
              return ["Z"];
            },
            invertCoords: function(curr){
              return ["Z"];
            }
          }
        };
    // ========= end of vars =========

    /*==================================================
     * svgCmdCheck (a function for use with Array.reduce)
     * -------------------------------------------------
     * Checks each element, if a string it must be
     * one of the keys in the SVG proptocol. If no bad
     * cmds found then the array is returned without
     * alteration, if not an empty array is returned.
     *=================================================*/
    function svgCmdCheck(acc, current, idx)
    {
      // make a concession to SVG standard and allow all number array
      if (idx === 0)
      {
        if (typeof current !== 'string')
        {
          acc.push("M");
          // now we will fall through to normal checking
        }
      }
      // if we see a command string, check it is in SVG protocol
      if (typeof current === "string") {  // check each string element
        if (!svgProtocol.hasOwnProperty(current.toUpperCase()))
        {
          console.log("unknown command string '"+current+"'");
          acc.badCmdFound = true;
          acc.length = 0;   // any bad command will force e,pty array to be retruned
        }
      }
      if (!acc.badCmdFound)
      {
        acc.push(current);
      }
      // always return when using reduce...
      return acc;
    }

    /*======================================================
     * unExtend  (a function for use with Array.reduce)
     * -----------------------------------------------------
     * Undo the extension of commands given the svg protocol.
     * Each entry in the protocol has an extCmd property which
     * is usually the same as the command key but for "M"
     * which may be extended by a series of "L" commands.
     * Extending a command means that multiple sets of paramaeters
     * may follow a command letter without the need to repeat
     * the command letter in front of each set eg.
     * The 'reduce' accumulator is used to hold the current
     * command as a property (not an array elemet) and make it
     * available to the next element.
     *
     * var a = ['M', 1, 2, 'L', 3, 4, 5, 6, 7, 8, 'A', 5, 6, 7, 8, 3, 0, 2]
     * var b = a.reduce(unExtend, [])
     *
     * &gt;&gt; ['M', 1, 2, 'L', 3, 4, 'L', 5, 6, 'L', 7, 8, 'A', 5, 6, 7, 8, 3, 0, 2]
     *
     * This assumes no invalid commands are in the string -
     * so array should be sanitized before running unExtend
     *======================================================*/
    function unExtend(acc, current, idx, ary)
    {
      var newCmd;

      if (idx === 0)
      {
        acc.nextCmdPos = 0;  // set expected position of next command string as first element
      }
      // Check if current is a command in the protocol (protocol only indexed by upperCase)
      if (typeof current === 'string')
      {
        if (idx &lt; acc.nextCmdPos)
        {
          // we need another number but found a string
          console.log("bad number of parameters for '"+current+"' at index "+idx);
          acc.badParameter = true;  // raise flag to bailout processing this
          acc.push(0);  // try to get out without crashing (acc data will be ditched any way)
          return acc;
        }
        // its a command the protocol knows, remember it across iterations of elements
        acc.currCmd = current.toUpperCase();  // save as a property of the acc Array object (not an Array element)
        acc.uc = (current.toUpperCase() === current);  // upperCase? true or false
        // calculate where the next command should be
        acc.nextCmdPos = idx + svgProtocol[acc.currCmd].parmCount + 1;
        acc.push(current);
      }
      else if (idx &lt; acc.nextCmdPos)   // processing parameters
      {
        // keep shoving parameters
        acc.push(current);
      }
      else
      {
        // we have got a full set of paramaters but hit another number
        // instead of a command string, it must be a command extention
        // push a the extension command (same as current except for M which extend to L)
        // into the accumulator
        acc.currCmd = svgProtocol[acc.currCmd].extCmd;  // NB: don't change the acc.uc boolean
        newCmd = (acc.uc)? acc.currCmd: acc.currCmd.toLowerCase();
        acc.push(newCmd, current);
        // calculate where the next command should be
        acc.nextCmdPos = idx + svgProtocol[acc.currCmd].parmCount;
      }

      if (idx === ary.length-1)   // done processing check if all was ok
      {
        if (acc.badParameter)
        {
          acc.length = 0;
        }
      }
      // always return when using reduce...
      return acc;
    }

    /*==================================================
     * svgCmdSplitter (a function for use with Array.reduce)
     * -------------------------------------------------
     * Split an array on a string type element, e.g.
     *
     * var a = ['a', 1, 2, 'b', 3, 4, 'c', 5, 6, 7, 8]
     * var b = a.reduce(svgCmdSplitter, [])
     *
     * &gt;&gt; [['a', 1, 2],['b', 3, 4], ['c', 5, 6, 7, 8]]
     *
     *=================================================*/
    function svgCmdSplitter(acc, curr)
    {
      // if we see a command string, start a new array element
      if (typeof curr === "string") {
          acc.push([]);
      }
      // add this element to the back of the acc's last array
      acc[acc.length-1].push(curr);
      // always return when using reduce...
      return acc;
    }

    /*===========================================================
     * toAbsoluteCoords  (a function for use with Array.reduce)
     * ----------------------------------------------------------
     * Reduce is needed even though the same size elements are
     * returned because the accumulator is used to hold the pen
     * x,y coords and make them available to the next element.
     * Assumes 'current' argument is an array of form ["M", 2, 7]
     * if command letter is lower case the protocol.toAbs
     * function will add the current pen x and y values to
     * the coordinates and update the pen x, y. The
     * absolute coord version of the cmd and its coords will
     * be returned and then pushed into acc.
     *
     * eg. ['M', 1, 2, 'l', 3, 4, 'a', 5, 6, 7, 8, 3, 0, 2, 'z']
     * &gt;&gt;  ['M', 1, 2, 'L', 4, 6, 'A', 5, 6, 7, 8, 3, 4, 8, 'Z']
     *===========================================================*/
    function toAbsoluteCoords(acc, current, idx)
    {
      var currCmd, currAbs;

      if (acc.px === undefined)
      {
        acc.px = 0;
        acc.py = 0;
      }
      // get protocol object for this command, indexed by uppercase only
      currCmd = svgProtocol[current[0].toUpperCase()];
      // call protocol toAbs function for this command
      // it returns absolute coordinate version based on current
      // pen position stored in acc.px, acc.py
      currAbs = currCmd.toAbs(acc, current, idx);
      acc.push(currAbs);
      // always return when using reduce...
      return acc;
    }

    /*==================================================================================
     * toCangoCmdSet  (a function for use with Array.reduce)
     * ---------------------------------------------------------------------------------
     * Assumes 'current' argument is an array of form ["M", 2, 7]
     * All commands letters are uppercase and all coordinates
     * are absolute (referenced to world coordinate origin).
     * This function will convert "H", "V", "S", "T", and "A"
     * commands to Cango internal command set "M", "L", "Q", "C", "Z"
     * All coordinates will be returned in separate array
     *
     * eg. [['M', 1, 2], ['L', 3, 4], ['H', 3], ['A', 5, 6, 7, 8, 3, 0, 2], ['Z']]
     * &gt;&gt;  [['M', 1, 2], [['L', 3, 4], ['L', 3, 4], ['C', cp, cp, cp, cp, x, y], ['Z']]
     *==================================================================================*/
    function toCangoCmdSet(acc, current, idx)
    {
      var currCmd = current[0],
          currSvgObj = svgProtocol[currCmd];

      // call protocol toCangoVersion function for this command
      // it converts all SVG to just "M", "L", "Q", "C", "Z" command and coords
      // and pushes them into the acc
      currSvgObj.toCangoVersion(acc, current, idx);
      // always return when using reduce...
      return acc;
    }

    /*==============================================
     * toDrawCmds  (a function for use with Array.reduce)
     * ----------------------------------------------
     * Convert a Cgo2D data array to an array
     * of Cango DrawCmd objects e.g.
     *
     * [['M', 0.1, 0.2], ['L', 1, 2, 'C', 3, 4, 5, 6, 2, 9], ['Z']]
     *
     * will become
     * [{ drawFn: "moveTo",
     *    parms: [0.1, 0.2],
     *    ...
     *  },
     *  { drawFn: "lineTo",
     *    parms: [1, 2],
     *    ...
     *  },
     *  ...
     *  ]
     *
     *===============================================*/
    function toDrawCmds(current)
    {
      // first element is a command...
      var cmd = current[0],   // grab command string
          parameters = current.slice(1); // make an array of the rest

      // the array elements have been checked as all valid
      // make a new element starting with an empty array
      return new DrawCmd(svgProtocol[cmd].canvasMethod, parameters);
    }

    /*==================================================
     * strToCgo2D (a function for use with Array.reduce)
     * -------------------------------------------------
     * Assumes 'current' argument is a string of form
     * "M  2 7" or "v 7  " or "z" which always has a
     * command string as the first character
     * and the rest is numbers separated by white space
     * This function will reduce (combine) to a single
     * array in Cgo2D format ["M", 2, 7, "v", 7, "z"]
     *=================================================*/
    function strToCgo2D(acc, current)
    {
      var cmd = current[0],
          parmsStr, numberStrs;

      // push the single char command as an element
      acc.push(cmd);
      // strip off the front cmd
      parmsStr = current.slice(1);
      // convert to an array of strings, each one number
      numberStrs = parmsStr.match(/\S+/g);   // returns null if no matches (not empty array)
      if (numberStrs)      // z has no numbers to follow
      {
        // parse each to a float and push it into acc
        numberStrs.forEach(function(s){
          var num = parseFloat(s);
          if (!isNaN(num))
          {
            acc.push(num);
          }
        });
      }
      // always return when using reduce...
      return acc;
    }

    /*===========================================================
     * flipCoords  (a function for use with Array.map)
     * ----------------------------------------------------------
     * Assumes 'current' argument is an array of form ["M", 2, 7]
     * All coordinates will be be in absolute format
     * The protocol will have an 'invertCoords' method for each
     * possible command key this will return the current array
     * with the sign of the Y coords flipped and sense of arcs reversed
     * reversed
     *
     * current = ['A', 2, 2,  30, 0, 1, 3,  4]
     *       &gt;&gt;  ['A', 2, 2, -30, 0, 0, 3, -4]
     *===========================================================*/
    function flipCoords(current)
    {
      var currCmd = current[0],
          currSvgObj = svgProtocol[currCmd];

      // call protocol.invertCoords function for this command
      // it flips the sign of the y coords, for 'A' commands it flips
      // sweep and xRotation values and returns the modified array
      return currSvgObj.invertCoords(current);
    }

    /*===========================================================
     * translateOrigin  (a function for use with Array.map)
     * ----------------------------------------------------------
     * Assumes it is called with 'this' object having
     * properties {xOfs: value, yOfs: value}
     * Assumes 'current' argument is an array of form ["M", 2, 7]
     * All coordinates will be be in absolute format
     * The protocol will have an 'addXYoffset method for each
     * possible command key this will return the current array
     * with the X and Y offsets added to the coordinate elements.
     *
     * eg. if 'this = {xOfs: 100, yOfs: 10}
     * current = ['M', 1, 2]
     * &gt;&gt;  ['M', 101, 12]
     *===========================================================*/
    function translateOrigin(current)
    {
      var currCmd = current[0],
          currSvgObj = svgProtocol[currCmd],
          xofs = this.xOfs || 0,
          yofs = this.yOfs || 0;

      return currSvgObj.addXYoffset(current, xofs, yofs);
    }

    /*===========================================================
     * flatten2Dary  (a function for use with Array.reduce)
     * ----------------------------------------------------------
     * Assumes curr is an array, push each element into the acc
     * to form a 1D array.

     * eg. [['M', 1, 2], ['V',2],['Z']]
     * &gt;&gt;  ['M', 1, 2, 'V', 2, 'Z']
     *===========================================================*/
    function flatten2Dary(acc, curr){
      return acc.concat(curr);
    }

    // auto run this code to create this object holding the two translator fns
    // and return it as the svgParser
    return {
      svg2cartesian: function(svgStr, xShft, yShft) {
        var dx = xShft || 0,
            dy = yShft || 0,
            noCommas,
            cmdStrs;

        if ((typeof svgStr !== 'string')||(svgStr.length === 0))
        {
          return [];
        }
        // this SVG processor can handle comma separated or whitespace separated or mixed
        // replace any commas with spaces
        noCommas = svgStr.replace(new RegExp(',', 'g'), ' ');
        // now we have a string of commands and numbers separated by whitespace
        // split it at command chars
        cmdStrs = noCommas.split(/(?=[a-df-z])/i);  // avoid e in exponents

        return cmdStrs.reduce(strToCgo2D, [])
                      .reduce(svgCmdCheck, [])
                      .reduce(unExtend, [])
                      .reduce(svgCmdSplitter, [])
                      .reduce(toAbsoluteCoords, [])
                      .map(translateOrigin, {xOfs: dx, yOfs: dy})
                      .map(flipCoords)
                      .reduce(flatten2Dary, []);
      },
      cgo2drawcmds: function(cgo2Dary) {
        if (!isArray(cgo2Dary) || (cgo2Dary.length === 0))
        {
          return [];
        }
        return cgo2Dary.reduce(svgCmdCheck, [])
                       .reduce(unExtend, [])
                       .reduce(svgCmdSplitter, [])
                       .reduce(toAbsoluteCoords, [])
                       .reduce(toCangoCmdSet, [])
                       .map(toDrawCmds);

      }
    };

  }());

  /* =============================================================================
   * Convert Cgo2D data array ['M',x,y, 'L',x1,y1, ... 'Q',cx,cy,x2,y2, 'A',r,r ]
   * to array of canvas DrawCmd {drawFn:'moveTo', [x,y]}
   * ----------------------------------------------------------------------------*/
  cgo2DtoDrawCmd = svgParser.cgo2drawcmds;

  if (shapeDefs === undefined)
  {
    shapeDefs = {'circle': function(diameter){
                            var d = diameter || 1;
                            return ["m", -0.5*d,0,
                            "c", 0,-0.27614*d, 0.22386*d,-0.5*d, 0.5*d,-0.5*d,
                            "c", 0.27614*d,0, 0.5*d,0.22386*d, 0.5*d,0.5*d,
                            "c", 0,0.27614*d, -0.22386*d,0.5*d, -0.5*d,0.5*d,
                            "c", -0.27614*d,0, -0.5*d,-0.22386*d, -0.5*d,-0.5*d];},

                'ellipse': function(width, height){
                            var w = width || 1,
                                h = w;
                            if ((typeof height === 'number')&amp;&amp;(height&gt;0))
                            {
                              h = height;
                            }
                            return ["m", -0.5*w,0,
                            "c", 0,-0.27614*h, 0.22386*w,-0.5*h, 0.5*w,-0.5*h,
                            "c", 0.27614*w,0, 0.5*w,0.22386*h, 0.5*w,0.5*h,
                            "c", 0,0.27614*h, -0.22386*w,0.5*h, -0.5*w,0.5*h,
                            "c", -0.27614*w,0, -0.5*w,-0.22386*h, -0.5*w,-0.5*h];},

                'square': function(width){
                            var w = width || 1;
                            return ['m', 0.5*w, -0.5*w, 'l', 0, w, -w, 0, 0, -w, 'z'];},

                'rectangle': function(w, h, rad){
                            var r;
                            if ((rad === undefined)||(rad&lt;=0))
                            {
                              return ["m",-w/2,-h/2, "l",w,0, 0,h, -w,0, 'z'];
                            }
                            r = Math.min(w/2, h/2, rad);
                            return ["m", -w/2+r,-h/2, "l",w-2*r,0, "a",r,r,0,0,1,r,r, "l",0,h-2*r,
                                    "a",r,r,0,0,1,-r,r, "l",-w+2*r,0, "a",r,r,0,0,1,-r,-r, "l",0,-h+2*r,
                                    "a",r,r,0,0,1,r,-r];},

                'triangle': function(side){
                            var s = side || 1;
                            return ['m', 0.5*s, -0.289*s, 'l', -0.5*s, 0.866*s, -0.5*s, -0.866*s, 'z'];},

                'cross': function(width){
                            var w = width || 1;
                            return ['m', -0.5*w, 0, 'l', w, 0, 'm', -0.5*w, -0.5*w, 'l', 0, w];},

                'ex': function(diagonal){
                            var d = diagonal || 1;
                            return ['m', -0.3535*d,-0.3535*d, 'l',0.707*d,0.707*d,
                                    'm',-0.707*d,0, 'l',0.707*d,-0.707*d];}
                };
  }

  function Drag2D(grabFn, dragFn, dropFn)
  {
    var savThis = this,
        nLrs, topCvs;

    this.cgo = null;                    // filled in by render
    this.layer = null;                  // filled in by render
    this.target = null;                 // filled by enableDrag method
    this.parent = null;                 // filled in on grab
    this.grabCallback = grabFn || null;
    this.dragCallback = dragFn || null;
    this.dropCallback = dropFn || null;
    this.grabCsrPos = {x:0, y:0};
    this.dwgOrg = {x:0, y:0};           // target drawing origin in world coords
    this.dwgOrgOfs = {x:0, y:0};        // target dwgOrg offset from target's parent dwgOrg
    this.grabOfs = {x:0, y:0};          // csr offset from target (maybe Obj or Group) drawing origin
    // the following closures hold the scope of the Drag2D instance so 'this' points to the Drag2D
    // multplie Obj2D may use this Drag2D, hitTest passes back which it was
    this.grab = function(evt, grabbedObj)
    {
      var event = evt||window.event,
          csrPosWC;
      // this Drag2D may be attached to Obj2D's Group2D parent
      if (grabbedObj.dragNdrop !== null)
      {
        this.parent = grabbedObj;      // the parent is an Obj2D
      }
      else  // cant find the dragNdrop for this grab
      {
        return true;
      }

      // calc top canvas at grab time since layers can come and go
      nLrs = this.cgo.bkgCanvas.layers.length;
      topCvs = this.cgo.bkgCanvas.layers[nLrs-1].cElem;

      topCvs.onmouseup = function(e){savThis.drop(e);};
      topCvs.onmouseout = function(e){savThis.drop(e);};
      csrPosWC = this.cgo.getCursorPosWC(event);      // update mouse pos to pass to the owner
      // save the cursor pos its very useful
      this.grabCsrPos.x = csrPosWC.x;
      this.grabCsrPos.y = csrPosWC.y;
      // copy the parent drawing origin (for convenience)
      this.dwgOrg.x = this.target.dwgOrg.x;
      this.dwgOrg.y = this.target.dwgOrg.y;
      if (this.target.parent)
      {
        // save the cursor offset from the parent's parent Group2D drawing origin (world coords)
        this.dwgOrgOfs = {x:this.target.dwgOrg.x - this.target.parent.dwgOrg.x,
                          y:this.target.dwgOrg.y - this.target.parent.dwgOrg.y};
      }
      else
      {
        // no parent, so same as adding 0s
        this.dwgOrgOfs = {x:this.target.dwgOrg.x,
                          y:this.target.dwgOrg.y};
      }
      this.grabOfs = {x:csrPosWC.x - this.dwgOrgOfs.x,
                      y:csrPosWC.y - this.dwgOrgOfs.y};

      if (this.grabCallback)
      {
        this.grabCallback(csrPosWC);    // call in the scope of dragNdrop object
      }

      topCvs.onmousemove = function(event){savThis.drag(event);};
      if (event.preventDefault)       // prevent default browser action (W3C)
      {
        event.preventDefault();
      }
      else                        // shortcut for stopping the browser action in IE
      {
        window.event.returnValue = false;
      }
      return false;
    };

    this.drag = function(event)
    {
      var csrPosWC = this.cgo.getCursorPosWC(event);  // update mouse pos to pass to the owner
      if (this.dragCallback)
      {
        this.dragCallback(csrPosWC);
      }
    };

    this.drop = function(event)
    {
      var csrPosWC = this.cgo.getCursorPosWC(event);  // update mouse pos to pass to the owner
      topCvs.onmouseup = null;
      topCvs.onmouseout = null;
      topCvs.onmousemove = null;
      if (this.dropCallback)
      {
        this.dropCallback(csrPosWC);
      }
    };

    // version of drop that can be called from an app to stop a drag before the mouseup event
    this.cancelDrag = function(mousePos)
    {
      topCvs.onmouseup = null;
      topCvs.onmouseout = null;
      topCvs.onmousemove = null;
      if (this.dropCallback)
      {
        this.dropCallback(mousePos);
      }
    };
  }

  LinearGradient = function(p1x, p1y, p2x, p2y)
  {
    this.grad = [p1x, p1y, p2x, p2y];
    this.colorStops = [];
    this.addColorStop = function(){this.colorStops.push(arguments);};
  };

  RadialGradient = function(p1x, p1y, r1, p2x, p2y, r2)
  {
    this.grad = [p1x, p1y, r1, p2x, p2y, r2];
    this.colorStops = [];
    this.addColorStop = function(){this.colorStops.push(arguments);};
  };

  function DrawCmd(cmdStr, coords)   // canvas syntax draw commands
  {
    // coords = world coordinates in [cp1x,cp1y, cp2x,cp2y, ... x,y]
    var i;

    this.drawFn = cmdStr;       // String version of the canvas command to call
    this.parms = [];
    this.parmsPx = [];          // parms transformed into pixel coords
    this.parmsOrg = [];
    for (i=0; i&lt;coords.length; i+=2)
    {
      this.parms.push(coords.slice(i, i+2));
      this.parmsOrg.push(coords.slice(i, i+2));     // original path parms for distort methods (in world coords)
    }
  }

  // Generate a 2D identity matrix
  function identityMatrix()
  {
    return [[1, 0, 0],
            [0, 1, 0],
            [0, 0, 1]];
  }

  // Generate a 2D translation matrix
  function translateMatrix(tx, ty)
  {
    var x = tx || 0,
        y = ty || 0;

    return [[1, 0, 0],
            [0, 1, 0],
            [x, y, 1]];
  }

  // Generate a 2D rotate matrix, angle in degrees
  function rotateMatrix(degs)
  {
    var angle = degs || 0,
        t = Math.PI/180.0,
        s	= Math.sin(-angle*t),
        c	= Math.cos(-angle*t);

    return [[c, -s, 0],
            [s,  c, 0],
            [0,  0, 1]];
  }

  // Skew matrix, angle in degrees applied before translate
  function skewMatrix(degH, degV)
  {
    var ha = degH || 0,
        va = degV || 0,
        rad = Math.PI/180.0,
        htn	= Math.tan(-ha*rad),
        vtn	= Math.tan(va*rad);

    return [[1,   vtn, 0],
            [htn, 1,   0],
            [0,   0,   1]];
  }

  // Generate a 2D revolve (identical to rotate) but may be applied after soft translate.
  function revolveMatrix(degs)
  {
    var angle = degs || 0,
        t = Math.PI/180.0,
        s	= Math.sin(-angle*t),
        c	= Math.cos(-angle*t);

    return [[c, -s, 0],
            [s,  c, 0],
            [0,  0, 1]];
  }

  // Generate a 2D scale matrix
  function scaleMatrix(xScale, yScale)
  {
    var sx = xScale || 1,
        sy = yScale || sx;

    return [[sx, 0, 0],
            [0, sy, 0],
            [0, 0,  1]];
  }

  /*===============================================
   * Object holding an array of 3 1x3 arrays,
   * representing a 3x3 matrix and methods to
   * apply matrix tranforms.
   *----------------------------------------------*/
  function TransformMatrix()
  {
    this.matrix = identityMatrix();
  }

  // Reset the matrix to the identity matrix
  TransformMatrix.prototype.reset = function()
  {
    this.matrix[0][0] = 1;
    this.matrix[0][1] = 0;
    this.matrix[0][2] = 0;
    this.matrix[1][0] = 0;
    this.matrix[1][1] = 1;
    this.matrix[1][2] = 0;
    this.matrix[2][0] = 0;
    this.matrix[2][1] = 0;
    this.matrix[2][2] = 1;
  };

  TransformMatrix.prototype.applyTransform = function(m)
  {
    // apply a transform by multiplying this.matrix by matrix 'm'
    var a11 = this.matrix[0][0],
        a12 = this.matrix[0][1],
        a13 = this.matrix[0][2],
        a21 = this.matrix[1][0],
        a22 = this.matrix[1][1],
        a23 = this.matrix[1][2],
        a31 = this.matrix[2][0],
        a32 = this.matrix[2][1],
        a33 = this.matrix[2][2],
        b11 = m[0][0],
        b12 = m[0][1],
        b13 = m[0][2],
        b21 = m[1][0],
        b22 = m[1][1],
        b23 = m[1][2],
        b31 = m[2][0],
        b32 = m[2][1],
        b33 = m[2][2];

    this.matrix[0][0] = a11 * b11 + a12 * b21 + a13 * b31;
    this.matrix[0][1] = a11 * b12 + a12 * b22 + a13 * b32;
    this.matrix[0][2] = a11 * b13 + a12 * b23 + a13 * b33;
    this.matrix[1][0] = a21 * b11 + a22 * b21 + a23 * b31;
    this.matrix[1][1] = a21 * b12 + a22 * b22 + a23 * b32;
    this.matrix[1][2] = a21 * b13 + a22 * b23 + a23 * b33;
    this.matrix[2][0] = a31 * b11 + a32 * b21 + a33 * b31;
    this.matrix[2][1] = a31 * b12 + a32 * b22 + a33 * b32;
    this.matrix[2][2] = a31 * b13 + a32 * b23 + a33 * b33;
  };

  // Multiply two matricies
  function matrixMult(a, b)
  {
    var a11 = a[0][0],
        a12 = a[0][1],
        a13 = a[0][2],
        a21 = a[1][0],
        a22 = a[1][1],
        a23 = a[1][2],
        a31 = a[2][0],
        a32 = a[2][1],
        a33 = a[2][2],
        b11 = b[0][0],
        b12 = b[0][1],
        b13 = b[0][2],
        b21 = b[1][0],
        b22 = b[1][1],
        b23 = b[1][2],
        b31 = b[2][0],
        b32 = b[2][1],
        b33 = b[2][2];

    return [[a11 * b11 + a12 * b21 + a13 * b31,
             a11 * b12 + a12 * b22 + a13 * b32,
             a11 * b13 + a12 * b23 + a13 * b33],
            [a21 * b11 + a22 * b21 + a23 * b31,
             a21 * b12 + a22 * b22 + a23 * b32,
             a21 * b13 + a22 * b23 + a23 * b33],
            [a31 * b11 + a32 * b21 + a33 * b31,
             a31 * b12 + a32 * b22 + a33 * b32,
             a31 * b13 + a32 * b23 + a33 * b33]];
  }

  function transformPoint(px, py, m)
  {
    var a1 = px,
        a2 = py,
        a3 = 1,
        b11 = m[0][0],
        b12 = m[0][1],
        b21 = m[1][0],
        b22 = m[1][1],
        b31 = m[2][0],
        b32 = m[2][1];

    return {x:a1 * b11 + a2 * b21 + a3 * b31 , y: a1 * b12 + a2 * b22 + a3 * b32};
  }

  function translater(args)      // will be called with 'this' pointing to an Obj2D
  {
    var savThis = this,
        time = args[0],
        tx = args[1],
        ty = args[2],
        x = 0,
        y = 0,
        transMat;

    if (tx instanceof Tweener)
    {
      x = tx.getValue(time);
    }
    else
    {
      x = tx;
    }
    if (ty instanceof Tweener)
    {
      y = ty.getValue(time);
    }
    else
    {
      y = ty;
    }
    transMat = [[1, 0, 0],
                [0, 1, 0],
                [x, y, 1]];

    if (this instanceof Obj2D)    // this transformer may be called on point object {x:, y: }
    {
      this.ofsTfm.applyTransform(transMat);      // used for TEXT obj, IMG obj and gradient fills
      if ((this.type === "PATH")||(this.type === "SHAPE"))
      {
        this.drawCmds.forEach(function(cmd){
          cmd.parms = cmd.parms.map(function(p){
            return [p[0] + x, p[1] + y];
          });
        });
      }
    }
    else
    {
      return {x:savThis.x + x, y:savThis.y + y};  // transfromPoint returns an Object {x:, y: }
    }
  }

  function bender(args)      // will be called with 'this' pointing to an Obj2D
  {
    var savThis = this,
        time = args[0],
        deg = args[1],
        A, sinA, cosA,
        max;

    if (deg instanceof Tweener)
    {
      A = deg.getValue(time)*Math.PI/180;
    }
    else
    {
      A = deg*Math.PI/180;
    }
    if (this instanceof Obj2D)    // this transformer may be called on point object {x:, y: }
    {
      // calc the distance to the furthest node, it will rotate the full 'deg'
      max = this.drawCmds.reduce(function(acc, currCmd){
        currCmd.parms.forEach(function(coord){
          var d = Math.sqrt(coord[0]*coord[0] + coord[1]*coord[1]);
          if (d &gt; acc)
          {
            acc = d;
          }
        });
        return acc;
      }, 0);
      // calc the fraction of obj length to each node and rotate it by that fraction of 'deg'
      this.drawCmds.forEach(function(cmd){
        cmd.parms = cmd.parms.map(function(p){
          var r = Math.sqrt(p[0]*p[0] + p[1]*p[1]), // distance of p from dwg org
              fracA = A*r/(max);                    // fraction of angle is fraction of node distance from dwg org
          sinA = Math.sin(-fracA);
          cosA = Math.cos(-fracA);

          return [p[0]*cosA + p[1]*sinA, -p[0]*sinA + p[1]*cosA];  // rotate each node by some fraction of total angle
        });
      });
    }
    else
    {
      sinA = Math.sin(-deg*Math.PI/180);    // just do a rotate
      cosA = Math.cos(-deg*Math.PI/180);
      return {x:savThis.x*cosA + savThis.y*sinA, y:-savThis.x*sinA + savThis.y*cosA}; // return an Object {x:, y: }
    }
  }

  function skewer(args)      // will be called with 'this' pointing to an Obj2D
  {
    // Skew matrix, angles in degrees applied before translate or revolve
    var savThis = this,
        time = args[0],
        degH = args[1] || 0,
        degV = args[2] || 0,
        rad = Math.PI/180.0,
        ha, va,
        htn, vtn, skewMat;

    if (degH instanceof Tweener)
    {
      ha = degH.getValue(time);
    }
    else
    {
      ha = degH;
    }
    if (degV instanceof Tweener)
    {
      va = degV.getValue(time);
    }
    else
    {
      va = degV;
    }
    htn	= Math.tan(-ha*rad);
    vtn	= Math.tan(va*rad);
    skewMat = [[1,   vtn, 0],
               [htn, 1,   0],
               [0,   0,   1]];

    if (this instanceof Obj2D)    // this transformer may be called on point object {x:, y: }
    {
      this.ofsTfm.applyTransform(skewMat);
      if ((this.type === "PATH")||(this.type === "SHAPE"))
      {
        this.drawCmds.forEach(function(cmd){
          cmd.parms = cmd.parms.map(function(p){
            return [p[0] + p[1]*htn, p[0]*vtn + p[1]];
          });
        });
      }
    }
    else
    {
      return {x:savThis.x + savThis.y*htn, y:savThis.x*vtn + savThis.y};  // transfromPoint returns an Object {x:, y: }
    }
  }

  function scaler(args)      // will be called with 'this' pointing to an Obj2D
  {
    // scale matrix, applied before translate or revolve
    var savThis = this,
        time = args[0],
        xScale = args[1] || 1,
        yScale = args[2] || xScale,
        sx, sy, sclMat;

    if (xScale instanceof Tweener)
    {
      sx = xScale.getValue(time);
    }
    else
    {
      sx = xScale;
    }
    if (yScale instanceof Tweener)
    {
      sy = yScale.getValue(time);
    }
    else
    {
      sy = yScale;
    }
    sclMat = [[sx, 0, 0],
              [0, sy, 0],
              [0,  0, 1]];

    if (this instanceof Obj2D)    // this transformer may be called on point object {x:, y: }
    {
      this.ofsTfm.applyTransform(sclMat);
      if ((this.type === "PATH")||(this.type === "SHAPE"))
      {
        this.drawCmds.forEach(function(cmd){
          cmd.parms = cmd.parms.map(function(p){
            return [p[0]*sx, p[1]*sy];
          });
        });
      }
    }
    else
    {
      return {x:savThis.x*sx, y:savThis.y*sy};  // transfromPoint returns an Object {x:, y: }
    }
  }

  function rotater(args)      // will be called with 'this' pointing to an Obj2D or point {x:, y: }
  {
    // rotate matrix, angles in degrees applied before translate or revolve
    var savThis = this,
        time = args[0],
        deg = args[1] || 0,
        rad = Math.PI/180.0,
        angle,
        s, c, rotMat;

    if (deg instanceof Tweener)
    {
      angle = deg.getValue(time);
    }
    else
    {
      angle = deg;
    }
    s	= Math.sin(-angle*rad);
    c	= Math.cos(-angle*rad);
    rotMat = [[c, -s, 0],
              [s,  c, 0],
              [0,  0, 1]];

    if (this instanceof Obj2D)    // this transformer may be called on point object {x:, y: }
    {
      this.ofsTfm.applyTransform(rotMat);
      if ((this.type === "PATH")||(this.type === "SHAPE"))
      {
        this.drawCmds.forEach(function(cmd){
          cmd.parms = cmd.parms.map(function(p){
            return [p[0]*c + p[1]*s, -p[0]*s + p[1]*c];
          });
        });
      }
    }
    else
    {
      return {x:savThis.x*c + savThis.y*s, y:-savThis.x*s + savThis.y*c};  // transfromPoint returns an Object {x:, y: }
    }
  }

  function revolver(args)      // will be called with 'this' pointing to an Obj2D or point {x:, y: }
  {
    // Rotate matrix, angles in degrees can be applied after tranlation away from World Coord origin
    var savThis = this,
        time = args[0],
        deg = args[1] || 0,
        rad = Math.PI/180.0,
        angle,
        s, c, revMat;

    if (deg instanceof Tweener)
    {
      angle = deg.getValue(time);
    }
    else
    {
      angle = deg;
    }
    s	= Math.sin(-angle*rad);
    c	= Math.cos(-angle*rad);
    revMat = [[c, -s, 0],
              [s,  c, 0],
              [0,  0, 1]];

    if (this instanceof Obj2D)    // this transformer may be called on point object {x:, y: }
    {
      this.ofsTfm.applyTransform(revMat);
      if ((this.type === "PATH")||(this.type === "SHAPE"))
      {
        // calc the fraction of obj length to each node and rotate it by that fraction of 'deg'
        this.drawCmds.forEach(function(cmd){
          cmd.parms = cmd.parms.map(function(p){
            return [p[0]*c + p[1]*s, -p[0]*s + p[1]*c];
          });
        });
      }
    }
    else  // point
    {
      return {x:savThis.x*c + savThis.y*s, y:-savThis.x*s + savThis.y*c};  // transfromPoint returns an Object {x:, y: }
    }
  }

  Tweener = function(values, delayTime, dur, loopStr)
  {
    var loopParm = "noloop";
    if (typeof loopStr === 'string')
    {
      loopParm = loopStr.toLowerCase();
    }

    this.tfmType = "";               // 'ROT', 'SCL'... filled in by transform methods
    this.values = values;
    this.delay = delayTime || 0;
    this.duration = dur || 5000;
    this.startTime = 0;              // this.startTime fakes 0 time in looping
    this.loop = false;
    this.loopAll = false;

    if (loopParm === 'loop')
    {
      this.loop = true;
    }
    else if (loopParm === 'loopall')
    {
      this.loopAll = true;
    }
  };

  Tweener.prototype.getValue = function(time)
  {
    var localTime, numSlabs, slabDur, slab, frac, newVal,
        t = 0;

    if (time === 0)   // re-starting after a stop (delay will be included)
    {
      this.startTime = 0;
    }
    localTime = time - this.startTime;       // handles local looping
    if ((localTime &gt; this.duration+this.delay) &amp;&amp; (this.duration &gt; 0) &amp;&amp; (this.loop || this.loopAll))
    {
      this.startTime = this.loop? time-this.delay : time;   // we will re-start
      localTime = this.loop? this.delay : 0;   // force re-start at end of delay or at time 0
    }
    if (localTime &gt; this.delay)  // repeat initial frame if there is a delay to start
    {
      t = localTime - this.delay;
    }
    if (isArray(this.values) &amp;&amp; (this.values.length &gt; 1))
    {
      if (t &gt;= this.duration)
      {
        newVal = this.values[this.values.length-1];  // freeze at end value
      }
      else
      {
        numSlabs = this.values.length-1;
        slabDur = this.duration/numSlabs;
        slab = Math.floor(t/slabDur);
        frac = (t - slab*slabDur)/slabDur;
        newVal = this.values[slab] + frac*(this.values[slab+1] - this.values[slab]);
      }
    }
    else   // single value or single valued array
    {
      newVal = isArray(this.values)? this.values[0] : this.values;
    }

    return newVal;
  };

  function Distorter(type, fn)  // and other arguments
  {
    var argAry = Array.prototype.slice.call(arguments).slice(2);     // skip type and fn parameters ave the rest

    this.type = type;
    this.distortFn = fn;
    this.args = argAry;      // array of arguments
    this.currVal = 0;       // hold the value returned from Tweener (or static value)
  }

  function TfmTools(obj)
  {
    var savThis = this;

    this.parent = obj;
    // container for methods to add animation Tweeners to a Group2D or Obj2D
    this.translate = function(tx, ty)
    {
      var trnsDstr = new Distorter("TRN", translater, tx, ty);
      // add the Distorter Object to the array of offset transforms to be applied to the obj
      savThis.parent.ofsTfmAry.push(trnsDstr);
    };
    this.scale = function(scaleX, scaleY)
    {
      var sclDstr = new Distorter("SCL", scaler, scaleX, scaleY);
      // add the Distorter Object to the array of offset transforms to be applied to the obj
      savThis.parent.ofsTfmAry.unshift(sclDstr);
    };
    this.rotate = function(deg)
    {
      var rotDstr = new Distorter("ROT", rotater, deg);
      // add the Distorter Object to the array of offset transforms to be applied to the obj
      savThis.parent.ofsTfmAry.unshift(rotDstr);
    };
    this.skew = function(degH, degV)
    {
      var skwDstr = new Distorter("SKW", skewer, degH, degV);
      // add the Distorter Object to the array of offset transforms to be applied to the obj
      savThis.parent.ofsTfmAry.unshift(skwDstr);
    };
    this.revolve = function(deg)
    {
      var revDstr = new Distorter("REV", revolver, deg);
      // add the Distorter Object to the array of offset transforms to be applied to the obj
      savThis.parent.ofsTfmAry.push(revDstr);
    };
    this.bend = function(deg)       // deg may be a Tweener
    {
      var bendDstr = new Distorter("BND", bender, deg);
      // add the Distorter Object to the array of offset transforms to be applied to the obj
      savThis.parent.ofsTfmAry.unshift(bendDstr);
    };
    this.reset = function()
    {
      savThis.parent.ofsTfmAry = [];
      savThis.parent.ofsTfm.reset();  // reset the accumulation matrix
    };
  }

  Group2D = function()
  {
    this.type = "GRP";                    // enum of type to instruct the render method
    this.parent = null;                   // pointer to parent group if any
    this.children = [];                   // only Groups have children
    this.dwgOrg = {x:0, y:0};             // drawing origin (0,0) may get translated
    this.ofsTfmAry = [];                  // transforms re-built after render
    this.netTfmAry = [];
    this.ofsTfm = new TransformMatrix();  // sum total of ofsTfmAry actions
    this.netTfm = new TransformMatrix();
    // enable grp.transform.rotate etc. API
    this.transform = new TfmTools(this);
    // add any objects passed by forwarding them to addObj
    this.addObj.apply(this, arguments);
  };

  Group2D.prototype.deleteObj = function(obj)
  {
    // remove from children array
    var idx = this.children.indexOf(obj);
    this.children.splice(idx, 1);
  };

  Group2D.prototype.addObj = function()
  {
    var args = Array.prototype.slice.call(arguments), // grab array of arguments
        i, j;
    for (i=0; i&lt;args.length; i++)
    {
      if (isArray(args[i]))
      {
        // check that only Groups or Obj2Ds are passed
        for (j=0; j&lt;args[i].length; j++)
        {
          if (args[i][j].type)
          {
            // point the Obj2D or Group2D parent property at this Group2D
            if (args[i][j].parent !== null)      // already a member of a Group2D, remove it
            {
              args[i][j].parent.deleteObj(args[i][j]);
            }
            args[i][j].parent = this;           // now its a free agent link it to this group
            this.children.push(args[i][j]);
            // enable drag and drop if this group has drag
            if (!args[i][j].dragNdrop &amp;&amp; this.dragNdrop)
            {
              args[i][j].dragNdrop = this.dragNdrop;
            }
          }
        }
      }
      else
      {
        if (args[i].type)
        {
          // point the Obj2D or Group2D parent property at this Group2D
          if (args[i].parent !== null)       // already a member of a Group2D, remove it
          {
            args[i].parent.deleteObj(args[i]);
          }
          args[i].parent = this;            // now its a free agent link it to this group
          this.children.push(args[i]);
          // enable drag and drop if this group has drag
          if (!args[i].dragNdrop &amp;&amp; this.dragNdrop)
          {
            args[i].dragNdrop = this.dragNdrop;
          }
        }
      }
    }
  };

  /*======================================
   * Recursively apply a hard translation
   * to all the Obj2Ds in the family tree.
   *-------------------------------------*/
  Group2D.prototype.translate = function(x, y)
  {
    // Apply transform to the hardOfsTfm of all Obj2D children recursively
  	function iterate(grp)
  	{
  		grp.children.forEach(function(childNode){
  			if (childNode.type === "GRP")
        {
  				iterate(childNode);
        }
        else
        {
          childNode.translate(x, y);
        }
  		});
  	}

    iterate(this);
  };

  /*======================================
   * Recursively apply a hard rotation
   * to all the Obj2Ds in the family tree.
   *-------------------------------------*/
  Group2D.prototype.rotate = function(degs)
  {
    // Apply transform to the hardOfsTfm of all Obj2D children recursively
  	function iterate(grp)
  	{
  		grp.children.forEach(function(childNode){
  			if (childNode.type === "GRP")
        {
  				iterate(childNode);
        }
        else
        {
          childNode.rotate(degs);
        }
  		});
  	}

    iterate(this);
  };

  /*======================================
   * Recursively apply a hard skew
   * to all the Obj2Ds in the family tree.
   *-------------------------------------*/
  Group2D.prototype.skew = function(degH, degV)
  {
    // Apply transform to the hardOfsTfm of all Obj2D children recursively
  	function iterate(grp)
  	{
  		grp.children.forEach(function(childNode){
  			if (childNode.type === "GRP")
        {
  				iterate(childNode);
        }
        else
        {
          childNode.skew(degH, degV);
        }
  		});
  	}

    iterate(this);
  };

  /*======================================
   * Recursively apply a hard scale
   * to all the Obj2Ds in the family tree.
   *-------------------------------------*/
  Group2D.prototype.scale = function(xsc, ysc)
  {
    var xScl = xsc,
        yScl = ysc ||xScl;

    // Apply transform to the hardOfsTfm of all Obj2D children recursively
  	function iterate(grp)
  	{
  		grp.children.forEach(function(childNode){
  			if (childNode.type === "GRP")
        {
  				iterate(childNode);
        }
        else
        {
          childNode.scale(xScl, yScl);
        }
  		});
  	}

    iterate(this);
  };

  /*======================================
   * Recursively add drag object to Obj2D
   * decendants.
   * When rendered all these Obj2D will be
   * added to dragObjects to be checked on
   * mousedown
   *-------------------------------------*/
  Group2D.prototype.enableDrag = function(grabFn, dragFn, dropFn)
  {
    var savThis = this;

  	function iterate(grp)
  	{
  		grp.children.forEach(function(childNode){
  			if (childNode.type === "GRP")
        {
  				iterate(childNode);
        }
        else   // Obj2D
        {
          if (childNode.dragNdrop === null)    // don't over-write if its already assigned a handler
          {
            childNode.enableDrag(grabFn, dragFn, dropFn);
            childNode.dragNdrop.target = savThis;     // the Group2D is the target being dragged
          }
        }
  		});
  	}

    iterate(this);
  };

  /*======================================
   * Disable dragging on Obj2D children
   *-------------------------------------*/
  Group2D.prototype.disableDrag = function()
  {
  	function iterate(grp)
  	{
  		grp.children.forEach(function(childNode){
  			if (childNode.type === "GRP")
        {
  				iterate(childNode);
        }
        else
        {
          childNode.disableDrag();
        }
  		});
  	}

    iterate(this);
  };

  function Path(commands)
  {
    this.type = "PATH";               // type string to instruct the render method
    this.parent = null;               // pointer to parent group if any
    this.drawCmds = cgo2DtoDrawCmd(commands);   // send the Cgo2D (SVG) commands off to the Cgo2D (SVG) processor
    this.dwgOrg = {x:0, y:0};         // drawing origin (0,0) may get translated
    this.dragNdrop = null;
    this.hardOfsTfm = new TransformMatrix();  // hard offset from any parent Group2D's transform
    // properties set by setProperty method, if undefined render uses Cango2D default
    this.border = false;              // true = stroke outline with strokeColor &amp; lineWidth
    this.strokeCol = null;            // render will stroke a path in this color
    this.lineWidth = 1;               // in case fat outline is wanted for Path or Shape outline
    this.lineCap = 'butt';            // in case something fancy is wanted
    // dashed line properties
    this.dashed = null;
    this.dashOffset = 0;
  }

  Path.prototype.applyHardOfsTfm = function()
  {
    var savThis = this;
    // apply hardOfsTfm for PATH and SHAPE Obj2Ds immediately so appendPath and revWinding are valid
    this.drawCmds.forEach(function(cmd){
      cmd.parms = cmd.parms.map(function(p){    // assumes p is a 2 element array [x, y]
        var tp = transformPoint(p[0], p[1], savThis.hardOfsTfm.matrix);
        return [tp.x, tp.y];
      });
      cmd.parmsOrg = clone(cmd.parms);  // do a deep copy of the new array of arrays
    });

    // to avoid applying twice, reset the hardOfsTfm to identity matrix
    this.hardOfsTfm.reset();
  };

  /*======================================
   * Apply a translation transform to the
   * Obj2D's hardOfsTfm.
   *-------------------------------------*/
  Path.prototype.translate = function(x, y)
  {
    this.hardOfsTfm.applyTransform(translateMatrix(x, y));
    this.applyHardOfsTfm();
  };

  /*======================================
   * Apply a rotation transform to the
   * Obj2D's hardOfsTfm.
   *-------------------------------------*/
  Path.prototype.rotate = function(degs)
  {
    this.hardOfsTfm.applyTransform(rotateMatrix(degs));
    this.applyHardOfsTfm();
  };

  /*======================================
   * Apply a skew transform to the
   * Obj2D's hardOfsTfm.
   *-------------------------------------*/
  Path.prototype.skew = function(degH, degV)
  {
    this.hardOfsTfm.applyTransform(skewMatrix(degH, degV));
    this.applyHardOfsTfm();
  };

  /*======================================
   * Apply a scale transform to the
   * Obj2D's hardOfsTfm.
   *-------------------------------------*/
  Path.prototype.scale = function(xScl, yScl)
  {
    this.hardOfsTfm.applyTransform(scaleMatrix(xScl, yScl));
    this.applyHardOfsTfm();
  };

  Path.prototype.appendPath = function(obj, delMove)
  {
    var dcs = clone(obj.drawCmds);  // make new element not references

    if (delMove)  // delete the inital 'moveTo' command
    {
      this.drawCmds = this.drawCmds.concat(dcs.slice(1));
    }
    else
    {
      this.drawCmds = this.drawCmds.concat(dcs);
    }
  };

  Path.prototype.revWinding = function()
  {
    // reverse the direction of drawing around a path, stops holes in shapes being filled
    var cmds,
        zCmd = null,
        revCmds = [],
        k, len,
        dParms, dCmd;

    function revPairs(ary)
    {
      // return a single array of x,y coords made by taking array of [x,y] arrays and reversing the order
      // eg. [[1,2], [3,4], [5,6]] returns [5,6,3,4,1,2]
      return ary.reduceRight(function(acc, curr){
        acc.push(curr[0], curr[1]);
        return acc;
      }, []);
    }

    if (this.drawCmds[this.drawCmds.length-1].drawFn === "closePath")
    {
      cmds = this.drawCmds.slice(0, -1);  // leave off 'closePath'
      zCmd = this.drawCmds.slice(-1);
    }
    else
    {
      cmds = this.drawCmds.slice(0);  // copy the whole array
    }
    // now step back along the path
    k = cmds.length-1;    // k points at the last segment DrawCmd
    len = cmds[k].parms.length;  // length of last DrawCmd's parms array
    dCmd = new DrawCmd("moveTo", cmds[k].parms[len-1]);   // make a 'M' command from final coord pair
    revCmds.push(dCmd);         // make this the first command of the output
    cmds[k].parms = cmds[k].parms.slice(0,-1);  // weve used the last point so slice it off
    while (k&gt;0)
    {
      dParms = revPairs(cmds[k].parms);   // dParms is a flat array
      len = cmds[k-1].parms.length;       // find the last DrawCmd of the next segment back
      dParms = dParms.concat(cmds[k-1].parms[len-1]); // add the last point of next cmd
      dCmd = new DrawCmd(cmds[k].drawFn, dParms);     // construct the DrawCmd for this segment
      revCmds.push(dCmd);                             // shove it out
      cmds[k-1].parms = cmds[k-1].parms.slice(0,-1);  // weve used the last point so slice it off
      k--;
    }
    // add the 'z' if it was a closed path
    if (zCmd)
    {
      revCmds.push(zCmd);
    }

    this.drawCmds = revCmds;
  };

  function Shape(commands)
  {
    // build all the Path properties and assign them to this Object's properties
    Path.call(this, commands);

    this.type = "SHAPE";
    this.fillCol = null;              // only used if type == SHAPE
  }

  Shape.prototype = new Path();       // make the Path methods the methods of this Shape object

  function Img(url)
  {
    this.type = "IMG";                // type string to instruct the render method
    this.parent = null;               // pointer to parent group if any
    this.drawCmds = url;              // just store the Image URL
    this.imgBuf = new Image();     // pointer to the Image object when image is loaded
    this.bBoxCmds = [];               // DrawCmd array for the text or img bounding box
    this.dwgOrg = {x:0, y:0};         // drawing origin (0,0) may get translated
    this.width = 0;                   // only used for type = IMG, TEXT, set to 0 until image loaded
    this.height = 0;                  //     "
    this.imgLorgX = 0;                //     "
    this.imgLorgY = 0;                //     "
    this.lorg = 1;                    // used by IMG and TEXT to set drawing origin
    this.dragNdrop = null;
    this.hardOfsTfm = new TransformMatrix();  // hard offset from any parent Group2D's transform
    // properties set by setProperty method, if undefined render uses Cango2D default
    this.border = false;              // true = stroke outline with strokeColor &amp; lineWidth
    this.strokeCol = null;            // render will stroke a path in this color
    this.lineWidth = 1;               // in case fat outline is wanted for Path or Shape outline

    this.imgBuf.src = url;            // start loading the image immediately
  }

  /*======================================
   * Apply a translation transform to the
   * Obj2D's hardOfsTfm.
   *-------------------------------------*/
  Img.prototype.translate = function(x, y)
  {
    this.hardOfsTfm.applyTransform(translateMatrix(x, y));
  };

  /*======================================
   * Apply a rotation transform to the
   * Obj2D's hardOfsTfm.
   *-------------------------------------*/
  Img.prototype.rotate = function(degs)
  {
    this.hardOfsTfm.applyTransform(rotateMatrix(degs));
  };

  /*======================================
   * Apply a skew transform to the
   * Obj2D's hardOfsTfm.
   *-------------------------------------*/
  Img.prototype.skew = function(degH, degV)
  {
    this.hardOfsTfm.applyTransform(skewMatrix(degH, degV));
  };

  /*======================================
   * Apply a scale transform to the
   * Obj2D's hardOfsTfm.
   *-------------------------------------*/
  Img.prototype.scale = function(xScl, yScl)
  {
    this.hardOfsTfm.applyTransform(scaleMatrix(xScl, yScl));
  };

  Img.prototype.formatImg = function()
  {
    var wid, hgt, wid2, hgt2,
        dx = 0,
        dy = 0,
        ulx, uly, llx, lly, lrx, lry, urx, ury,
        lorgWC;

    if (!this.imgBuf.width)
    {
      console.log("in image onload handler yet image NOT loaded!");
    }
    if (this.width &amp;&amp; this.height)
    {
      wid = this.width;
      hgt = this.height;
    }
    else if (this.width &amp;&amp; !this.height)  // width only passed height is auto
    {
      wid = this.width;
      hgt = this.height || wid*this.imgBuf.height/this.imgBuf.width;  // default keep aspect ratio
    }
    else if (this.height &amp;&amp; !this.width)  // height only passed width is auto
    {
      hgt = this.height;
      wid = this.width || hgt*this.imgBuf.width/this.imgBuf.height;    // default to keep aspect ratio
    }
    else    // no width or height default to natural size;
    {
      wid = this.imgBuf.width;    // default to natural width if none passed
      hgt = this.imgBuf.height;   // default to natural height if none passed
    }
    wid2 = wid/2;
    hgt2 = hgt/2;
    lorgWC = [0, [0, 0],    [wid2, 0],   [wid, 0],
                 [0, hgt2], [wid2, hgt2], [wid, hgt2],
                 [0, hgt],  [wid2, hgt],  [wid, hgt]];
    if (lorgWC[this.lorg] !== undefined)
    {
      dx = -lorgWC[this.lorg][0];
      dy = -lorgWC[this.lorg][1];
    }
    this.imgLorgX = dx;     // world coords offset to drawing origin
    this.imgLorgY = dy;
    this.width = wid;   // in case it was not set and natural used
    this.height = hgt;
    // construct the DrawCmds for the text bounding box
    ulx = dx; uly = dy;
    llx = dx; lly = dy+hgt;
    lrx = dx+wid; lry = dy+hgt;
    urx = dx+wid; ury = dy;
    this.bBoxCmds[0] = new DrawCmd("moveTo", [ulx, -uly]);
    this.bBoxCmds[1] = new DrawCmd("lineTo", [llx, -lly]);
    this.bBoxCmds[2] = new DrawCmd("lineTo", [lrx, -lry]);
    this.bBoxCmds[3] = new DrawCmd("lineTo", [urx, -ury]);
    this.bBoxCmds[4] = new DrawCmd("closePath", []);
  };

  function Text(txtString)
  {
    this.type = "TEXT";               // type string to instruct the render method
    this.parent = null;               // pointer to parent group if any
    this.drawCmds = txtString;        // just store the text String
    this.bBoxCmds = [];               // DrawCmd array for the text or img bounding box
    this.dwgOrg = {x:0, y:0};         // drawing origin (0,0) may get translated
    this.width = 0;                   // only used for type = IMG, TEXT, set to 0 until image loaded
    this.height = 0;                  //     "
    this.imgLorgX = 0;                //     "
    this.imgLorgY = 0;                //     "
    this.lorg = 1;                    // used by IMG and TEXT to set drawing origin
    this.dragNdrop = null;
    this.hardOfsTfm = new TransformMatrix();  // hard offset from any parent Group2D's transform
    // properties set by setProperty method, if undefined render uses Cango2D default
    this.border = false;              // true = stroke outline with strokeColor &amp; lineWidth
    this.fillCol = null;              // only used if type == SHAPE or TEXT
    this.strokeCol = null;            // render will stroke a path in this color
    this.lineWidth = 1;               // in case fat outline is wanted for Path or Shape outline
    this.fontSize = null;             // fontSize in pixels (TEXT only)
    this.fontWeight = null;           // fontWeight 100..900 (TEXT only)
    this.fontFamily = null;           // (TEXT only)
  }

  /*======================================
   * Apply a translation transform to the
   * Obj2D's hardOfsTfm.
   *-------------------------------------*/
  Text.prototype.translate = function(x, y)
  {
    this.hardOfsTfm.applyTransform(translateMatrix(x, y));
  };

  /*======================================
   * Apply a rotation transform to the
   * Obj2D's hardOfsTfm.
   *-------------------------------------*/
  Text.prototype.rotate = function(degs)
  {
    this.hardOfsTfm.applyTransform(rotateMatrix(degs));
  };

  /*======================================
   * Apply a skew transform to the
   * Obj2D's hardOfsTfm.
   *-------------------------------------*/
  Text.prototype.skew = function(degH, degV)
  {
    this.hardOfsTfm.applyTransform(skewMatrix(degH, degV));
  };

  /*======================================
   * Apply a scale transform to the
   * Obj2D's hardOfsTfm.
   *-------------------------------------*/
  Text.prototype.scale = function(xScl, yScl)
  {
    this.hardOfsTfm.applyTransform(scaleMatrix(xScl, yScl));
  };

  Text.prototype.formatText = function(gc)
  {
    var size = this.fontSize || gc.fontSize,     // fontSize in pxls
        fntFm = this.fontFamily || gc.fontFamily,
        lorg = this.lorg || 1,
        wid, hgt,   // Note: char cell is ~1.4*fontSize pixels high
        wid2, hgt2,
        lorgWC,
        dx = 0,
        dy = 0,
        ulx, uly, llx, lly, lrx, lry, urx, ury;

    // set the drawing context to measure the size
    gc.ctx.save();
    gc.ctx.font = size+"px "+fntFm;
    wid = gc.ctx.measureText(this.drawCmds).width;   // drawCmds = text string to render
    gc.ctx.restore();
    hgt = size;       // char cell height (bottom of decender to top of capitals)
    wid2 = wid/2;     // wid is in pixels too
    hgt2 = hgt/2;
    lorgWC = [0, [0, hgt],  [wid2, hgt],  [wid, hgt],
                 [0, hgt2], [wid2, hgt2], [wid, hgt2],
                 [0, 0],    [wid2, 0],    [wid, 0]];
    if (lorgWC[lorg] !== undefined)
    {
      dx = -lorgWC[lorg][0];
      dy = lorgWC[lorg][1];
    }
    this.imgLorgX = dx;      // pixel offsets to drawing origin
    this.imgLorgY = dy-0.25*hgt;  // correct for alphabetic baseline, its offset about 0.25*char height
    this.width = wid;
    this.height = hgt;
    // construct the DrawCmds for the text bounding box
    ulx = dx;
    uly = dy;
    llx = dx;
    lly = dy-hgt;
    lrx = dx+wid;
    lry = dy-hgt;
    urx = dx+wid;
    ury = dy;
    this.bBoxCmds[0] = new DrawCmd("moveTo", [ulx, -uly]);
    this.bBoxCmds[1] = new DrawCmd("lineTo", [llx, -lly]);
    this.bBoxCmds[2] = new DrawCmd("lineTo", [lrx, -lry]);
    this.bBoxCmds[3] = new DrawCmd("lineTo", [urx, -ury]);
    this.bBoxCmds[4] = new DrawCmd("closePath", []);
  };

  Obj2D = function(data, objtype, options)
  {
    var classObj = Path,    // default to a Path type Cobj
        objClass,
        opt, prop;

    switch (objtype)
    {
      case "PATH":
        classObj = Path;
        break;
      case "SHAPE":
        classObj = Shape;
        break;
      case "IMG":
        classObj = Img;
        break;
      case "TEXT":
        classObj = Text;
        break;
    }

    // build all the properties of the Object and make them properties of this Cobj
    classObj.call(this, data);
    // make an instance of the Object type so we can inherit its methods
    objClass = new classObj();
    for (prop in objClass)
    {
      if (typeof objClass[prop] === "function")    // copy references to the methods only
      {
        this[prop] = objClass[prop];
      }
    }

    this.parent = null;                       // pointer to parent group if any
    // properties handling transform inheritance
    this.ofsTfmAry = [];                      // soft offset from any parent Group2D's transform
    this.netTfmAry = [];                      // ofsTfmAry with grpTfmAry concatinated
    this.ofsTfm = new TransformMatrix();      // product of hard &amp; ofs tfm actions, filled in at render
    this.netTfm = new TransformMatrix();      // parent Group2D netTfm applied to this.ofsTfm
    this.zIndex = 0;                          // depth sort on this
    // enable obj.transform.rotate etc. API
    this.transform = new TfmTools(this);
    // drop shadow properties
    this.shadowOffsetX = 0;
    this.shadowOffsetY = 0;
    this.shadowBlur = 0;
    this.shadowColor = "#000000";

    opt = (typeof options === 'object')? options: {};   // avoid undeclared object errors
    // check for all supported options
    for (prop in opt)
    {
      // check that this is opt's own property, not inherited from prototype
      if (opt.hasOwnProperty(prop))
      {
        this.setProperty(prop, opt[prop]);
      }
    }
  };

  Obj2D.prototype.enableDrag = function(grabFn, dragFn, dropFn)
  {
    this.dragNdrop = new Drag2D(grabFn, dragFn, dropFn);
    // fill in the Drag2D properties for use by callBacks
    this.dragNdrop.target = this;
  };

  Obj2D.prototype.disableDrag = function()
  {
    var aidx;

    if (!this.dragNdrop)
    {
      return;
    }
    // remove this object from array to be checked on mousedown
    aidx = this.dragNdrop.layer.dragObjects.indexOf(this);
    this.dragNdrop.layers.dragObjects.splice(aidx, 1);
    this.dragNdrop = null;
  };

  Obj2D.prototype.setProperty = function(propertyName, value)
  {
    var lorgVals = [1, 2, 3, 4, 5, 6, 7, 8, 9];

    if ((typeof propertyName !== "string")||(value === undefined)||(value === null))
    {
      return;
    }

    switch (propertyName.toLowerCase())
    {
      case "fillcolor":
        this.fillCol = value;
        break;
      case "strokecolor":
        this.strokeCol = value;
        break;
      case "linewidth":
      case "strokewidth":                 // for backward compatability
        this.lineWidth = Math.abs(value);
        break;
      case "linecap":
        if (typeof value !== "string")
        {
          return;
        }
        if ((value === "butt")||(value ==="round")||(value === "square"))
        {
          this.lineCap = value;
        }
        break;
      case "dashed":
        if (Array.isArray(value) &amp;&amp; value[0])
        {
          this.dashed = value;
        }
        else     // setDashed() will clear dashed settings
        {
          this.dashed = null;
        }
        break;
      case "dashoffset":
        this.dashOffset = value || 0;
        break;
      case "border":
        if (value === true)
        {
          this.border = true;
        }
        if (value === false)
        {
          this.border = false;
        }
        break;
      case "fontsize":
        this.fontSize = Math.abs(value);
        break;
      case "fontweight":
        if ((typeof value === "string")||((typeof value === "number")&amp;&amp;(value&gt;=100)&amp;&amp;(value&lt;=900)))
        {
          this.fontWeight = value;
        }
        break;
      case "fontfamily":
        if (typeof value === "string")
        {
          this.fontFamily = value;
        }
        break;
      case "imgwidth":
        this.width = Math.abs(value);
        break;
      case "imgheight":
        this.height = Math.abs(value);
        break;
      case "lorg":
        if (lorgVals.indexOf(value) !== -1)
        {
          this.lorg = value;
        }
        break;
      case "zindex":
        this.zIndex = 1*value;   // force it to be a number
        break;
      case "shadowoffsetx":
        this.shadowOffsetX = value || 0;
        break;
      case "shadowoffsety":
        this.shadowOffsetY = value || 0;
        break;
      case "shadowblur":
        this.shadowBlur = value || 0;
        break;
      case "shadowcolor":
        this.shadowColor = value;
        break;
      default:
        return;
    }
  };

  Obj2D.prototype.dup = function()
  {
    var newObj = new Obj2D();

    newObj.type = this.type;
    newObj.drawCmds = clone(this.drawCmds);
    newObj.imgBuf = this.imgBuf;         // just copy reference
    newObj.bBoxCmds = clone(this.bBoxCmds);
    newObj.dwgOrg = clone(this.dwgOrg);
    newObj.border = this.border;
    newObj.strokeCol = this.strokeCol;
    newObj.fillCol = this.fillCol;
    newObj.lineWidth = this.lineWidth;
    newObj.lineCap = this.lineCap;
    newObj.dashed = this.dashed;
    newObj.dashOffset = this.dashOffset;
    newObj.width = this.width;
    newObj.height = this.height;
    newObj.imgLorgX = this.imgLorgX;
    newObj.imgLorgY = this.imgLorgY;
    newObj.lorg = this.lorg;
    newObj.fontSize = this.fontSize;
    newObj.fontWeight = this.fontWeight;
    newObj.fontFamily = this.fontFamily;
    newObj.hardOfsTfm = clone(this.hardOfsTfm);
    newObj.zIndex = this.zIndex;                  // depth sort on this
    newObj.shadowOffsetX = this.shadowOffsetX;
    newObj.shadowOffsetY = this.shadowOffsetY;
    newObj.shadowBlur = this.shadowBlur;
    newObj.shadowColor = this.shadowColor;
    // The other objects are dynamic, calculated at render

    return newObj;         // return a object which inherits Obj2D properties
  };

  function transformCtx(ctx, xfm)  // apply a matrix transform to a canvas 2D context
  {
    if (xfm === undefined)
    {
      ctx.setTransform(1, 0, 0,
                       0, 1, 0);
    }
    else
    {
      ctx.setTransform(xfm.matrix[0][0], xfm.matrix[0][1], xfm.matrix[1][0],
                       xfm.matrix[1][1], xfm.matrix[2][0], xfm.matrix[2][1]);
    }
  }

//===============================================================================

  function Animation(gCtx, rootObj)
  {
    this.gc = gCtx;                          // the Cango context to do the drawing
    this.animationObj = rootObj || null;         // root object (Obj2D or Group2D) of scene to be draw
    // each obj2d in the family tree knows how to genterate the frame tranforms given the localTime value
  }

  function Timeline()
  {
    this.animTasks = [];    // each layer can push an Animation object in here
    this.timer = null;                // need to save the rAF id for cancelling
    this.modes = {PAUSED:1, STOPPED:2, PLAYING:3, STEPPING:4};     // animation modes
    this.animMode = this.modes.STOPPED;
    this.prevAnimMode = this.modes.STOPPED;
    this.startTime = 0;               // animation start time (relative to 1970)
    this.currTime = 0;                // timestamp of frame on screen
    this.stepTime = 50;               // animation step time interval (in msec)
  }

  Timeline.prototype.stopAnimation = function()
  {
    window.cancelAnimationFrame(this.timer);
    this.prevAnimMode = this.animMode;
    this.animMode = this.modes.STOPPED;
    // reset the currTime so play and step know to start again
    this.currTime = 0;
  };

  Timeline.prototype.pauseAnimation = function()
  {
    window.cancelAnimationFrame(this.timer);
    this.prevAnimMode = this.animMode;
    this.animMode = this.modes.PAUSED;
  };

  Timeline.prototype.stepAnimation = function()
  {
    var savThis = this;

    // this is the actual animator that draws the frame
    function drawIt()
    {
      var localTime,
          time = Date.now();    // use this as a time stamp, browser don't all pass the same time code

      if (savThis.prevAnimMode === savThis.modes.STOPPED)
      {
        savThis.startTime = time;                // forces localTime = 0 to start from beginning
      }
      localTime =  time - savThis.startTime;
      // step through all the animation tasks
      savThis.animTasks.forEach(function(at){
        at.gc.render(at.animationObj, true, localTime);  // handle clearCanvas here
      });

      savThis.currTime = localTime;      // timestamp of what is currently on screen
      savThis.prevAnimMode = savThis.modes.PAUSED;
      savThis.animMode = savThis.modes.PAUSED;
    }

    // eqivalent to play for one frame and pause
    if (this.animMode === this.modes.PLAYING)
    {
      return;
    }
    if (this.animMode === this.modes.PAUSED)
    {
      this.startTime = Date.now() - this.currTime;  // move time as if currFrame just drawn
    }
    this.prevAnimMode = this.animMode;
    this.animMode = this.modes.STEPPING;

    setTimeout(drawIt, this.stepTime);
  };

  Timeline.prototype.playAnimation = function()
  {
    // this.animationObj and its family tree get drawn each frame any object with
    // transform set have had their tweener added to the ofsTfmAry
    // When rendered the Tweener getMatrix is called and its matrix applied like any
    // other transform. All getMatrix calls get passed the same value of localtime
    // each frame to keep sync.
    // this routine is the 'stepper' from timeline
    var savThis = this;

    // this is the actual animator that draws each frame
    function drawIt()
    {
      var localTime,
          time = Date.now();    // use this as a time stamp, browser don't all pass the same time code

      if (savThis.prevAnimMode === savThis.modes.STOPPED)
      {
        savThis.startTime = time;                // forces localTime = 0 to start from beginning
      }
      localTime =  time - savThis.startTime;

      // step through all the animation tasks
      savThis.animTasks.forEach(function(at){
        at.gc.render(at.animationObj, true, localTime);  // clear is false, clearing handled here
      });

      savThis.currTime = localTime;      // timestamp of what is currently on screen
      savThis.prevAnimMode = savThis.modes.PLAYING;
      savThis.timer = window.requestAnimationFrame(drawIt);
    }

    if (this.animMode === this.modes.PLAYING)
    {
      return;
    }
    if (this.animMode === this.modes.PAUSED)
    {
      this.startTime = Date.now() - this.currTime;  // move time as if currFrame just drawn
    }

    this.prevAnimMode = this.animMode;
    this.animMode = this.modes.PLAYING;

    this.timer = window.requestAnimationFrame(drawIt);
  };

//===============================================================================

  function Layer(canvasID, canvasElement)
  {
    this.id = canvasID;
    this.cElem = canvasElement;
    this.dragObjects = [];
  }

  function getLayer(cgo)
  {
    var i, lyr = cgo.bkgCanvas.layers[0];

    for (i=1; i &lt; cgo.bkgCanvas.layers.length; i++)
    {
      if (cgo.bkgCanvas.layers[i].id === cgo.cId)
      {
        lyr = cgo.bkgCanvas.layers[i];
        break;
      }
    }
    return lyr;    // Layer object
  }

  function initDragAndDrop(savThis)
  {
    function dragHandler(evt)
    {
      var event = evt || window.event,
          csrPos, testObj, nLyrs, lyr,
          j, k;

      function getCursorPos(e)
      {
        // pass in any mouse event, returns the position of the cursor in raw pixel coords
        var rect = savThis.cnvs.getBoundingClientRect();

        return {x: e.clientX - rect.left, y: e.clientY - rect.top};
      }

      function hitTest(pathObj, csrX, csrY)
      {
        // create the path (don't stroke it - no-one will see) to test for hit
        savThis.ctx.beginPath();
        if ((pathObj.type === 'TEXT')||(pathObj.type === 'IMG'))   // use bounding box not drawCmds
        {
          pathObj.bBoxCmds.forEach(function(dCmd){
            savThis.ctx[dCmd.drawFn].apply(savThis.ctx, dCmd.parmsPx);
          });
        }
        else
        {
          pathObj.drawCmds.forEach(function(dCmd){
            savThis.ctx[dCmd.drawFn].apply(savThis.ctx, dCmd.parmsPx);
          });
        }
/*
    // for diagnostics on hit region, uncomment
    savThis.ctx.strokeStyle = 'red';
    savThis.ctx.lineWidth = 4;
    savThis.ctx.stroke();
*/
        return savThis.ctx.isPointInPath(csrX, csrY);
      }

      csrPos = getCursorPos(event);  // savThis is any Cango ctx on the canvas
      nLyrs = savThis.bkgCanvas.layers.length;
      // run through all the registered objects and test if cursor pos is in their path
      loops:      // label to break out of nested loops
      for (j = nLyrs-1; j &gt;= 0; j--)       // search top layer down the stack
      {
        lyr = savThis.bkgCanvas.layers[j];
        for (k = lyr.dragObjects.length-1; k &gt;= 0; k--)  // search from last drawn to first (underneath)
        {
          testObj = lyr.dragObjects[k];
          if (hitTest(testObj, csrPos.x, csrPos.y))
          {
            // call the grab handler for this object (check it is still enabled)
            if (testObj.dragNdrop)
            {
              testObj.dragNdrop.grab(event, testObj);
              break loops;
            }
          }
        }
      }
    }

    // =========== Start Here ===========

    savThis.cnvs.onmousedown = dragHandler;   // added to all layers but only top layer will catch events
  }

  Cango2D = function(canvasId)
  {
    var savThis = this,
        bkgId, bkgL;

    function resizeLayers()
    {
      var j, ovl,
          t = savThis.bkgCanvas.offsetTop + savThis.bkgCanvas.clientTop,
          l = savThis.bkgCanvas.offsetLeft + savThis.bkgCanvas.clientLeft,
          w = savThis.bkgCanvas.offsetWidth,
          h = savThis.bkgCanvas.offsetHeight;

      // fix all Cango contexts to know about new size
      savThis.rawWidth = w;
      savThis.rawHeight = h;
      savThis.aRatio = w/h;
      // there may be multiple Cango contexts a layer, try to only fix actual canvas properties once
      if (savThis.bkgCanvas !== savThis.cnvs)
      {
        return;
      }
      savThis.cnvs.setAttribute('width', w);    // reset canvas pixels width
      savThis.cnvs.setAttribute('height', h);   // don't use style for this
      // step throungh the stack of canvases (if any)
      for (j=1; j&lt;savThis.bkgCanvas.layers.length; j++)  // bkg is layer[0]
      {
        ovl = savThis.bkgCanvas.layers[j].cElem;
        if (ovl)
        {
          ovl.style.top = t+'px';
          ovl.style.left = l+'px';
          ovl.style.width = w+'px';
          ovl.style.height = h+'px';
          ovl.setAttribute('width', w);    // reset canvas pixels width
          ovl.setAttribute('height', h);   // don't use style for this
        }
      }
    }

    this.cId = canvasId;
    this.cnvs = document.getElementById(canvasId);
    if (this.cnvs === null)
    {
      alert("can't find canvas "+canvasId);
      return;
    }
    this.bkgCanvas = this.cnvs;  // this is a background canvas so bkgCanvas points to itself
    // check if this is a context for an overlay
    if (canvasId.indexOf("_ovl_") !== -1)
    {
      // this is an overlay. get a reference to the backGround canvas
      bkgId = canvasId.slice(0,canvasId.indexOf("_ovl_"));
      this.bkgCanvas = document.getElementById(bkgId);
    }
    this.rawWidth = this.cnvs.offsetWidth;
    this.rawHeight = this.cnvs.offsetHeight;
    this.aRatio = this.rawWidth/this.rawHeight;
    if (!this.bkgCanvas.hasOwnProperty('layers'))
    {
      // create an array to hold all the overlay canvases for this canvas
      this.bkgCanvas.layers = [];
      // make a Layerobject for the bkgCanvas
      bkgL = new Layer(this.cId, this.cnvs);
      this.bkgCanvas.layers[0] = bkgL;
    }
    if ((Timeline !== undefined) &amp;&amp; !this.bkgCanvas.hasOwnProperty('timeline'))
    {
      // create an array to hold all the overlay canvases for this bkgCanavs
      this.bkgCanvas.timeline = new Timeline();
    }
    if (!this.cnvs.hasOwnProperty('resized'))
    {
      // make canvas native aspect ratio equal style box aspect ratio.
      // Note: rawWidth and rawHeight are floats, assignment to ints will truncate
      this.cnvs.setAttribute('width', this.rawWidth);    // reset canvas pixels width
      this.cnvs.setAttribute('height', this.rawHeight);  // don't use style for this
      this.cnvs.resized = true;
    }
    this.ctx = this.cnvs.getContext('2d');    // draw direct to screen canvas
    this.vpW = this.rawWidth;         // vp width in pixels (no more viewport so use full canvas)
    this.vpH = this.rawHeight;        // vp height in pixels, canvas height = width/aspect ratio
    this.vpLLx = 0;                   // vp lower left of viewport (not used) from canvas left, in pixels
    this.vpLLy = this.rawHeight;      // vp lower left of viewport from canvas top
    this.xscl = 1;                    // world x axis scale factor, default: pixels
    this.yscl = -1;                   // world y axis scale factor, +ve up (always -xscl since isotropic)
    this.xoffset = 0;                 // world x origin offset from viewport left in pixels
    this.yoffset = 0;                 // world y origin offset from viewport bottom in pixels
    this.ctx.textAlign = "left";      // all offsets are handled by lorg facility
    this.ctx.textBaseline = "alphabetic";
    this.penCol = "rgba(0, 0, 0, 1.0)";           // black
    this.penWid = 1;                  // pixels
    this.lineCap = "butt";
    this.paintCol = "rgba(128, 128, 128, 1.0)";   // gray
    this.fontSize = 12;               // pixels
    this.fontWeight = 400;            // 100..900, 400 = normal,700 = bold
    this.fontFamily = "Consolas, Monaco, 'Andale Mono', monospace";

    this.worldToPixel = new TransformMatrix();

    this.getUnique = function()
    {
      uniqueVal += 1;     // a private 'global'
      return uniqueVal;
    };

    initDragAndDrop(this);

    addEvent(window, 'resize', resizeLayers);
  };

  Cango2D.prototype.pauseAnimation = function()
  {
    this.bkgCanvas.timeline.pauseAnimation();
  };

  Cango2D.prototype.playAnimation = function()
  {
    this.bkgCanvas.timeline.playAnimation();
  };

  Cango2D.prototype.stopAnimation = function()
  {
    this.bkgCanvas.timeline.stopAnimation();
  };

  Cango2D.prototype.stepAnimation = function()
  {
    this.bkgCanvas.timeline.stepAnimation();
  };

  Cango2D.prototype.toPixelCoords = function(x, y)
  {
    // transform x,y in world coords to canvas pixel coords (top left is 0,0 y axis +ve down)
    var xPx = this.vpLLx+this.xoffset+x*this.xscl,
        yPx = this.vpLLy+this.yoffset+y*this.yscl;

    return {x: xPx, y: yPx};
  };

  Cango2D.prototype.toWorldCoords = function(xPx, yPx)
  {
    // transform xPx,yPx in raw canvas pixels to world coords (lower left is 0,0 +ve up)
    var xW = (xPx - this.vpLLx - this.xoffset)/this.xscl,
        yW = (yPx - this.vpLLy - this.yoffset)/this.yscl;

    return {x: xW, y: yW};
  };

  Cango2D.prototype.getCursorPosWC = function(evt)
  {
    // pass in any mouse event, returns the position of the cursor in raw pixel coords
    var e = evt||window.event,
        rect = this.cnvs.getBoundingClientRect(),
        xW = (e.clientX - rect.left - this.vpLLx - this.xoffset)/this.xscl,
        yW = (e.clientY - rect.top - this.vpLLy - this.yoffset)/this.yscl;

    return {x: xW, y: yW};
  };

  Cango2D.prototype.clearCanvas = function(fillColor)
  {
    var savThis = this,
        layerObj;

    function genLinGrad(lgrad)
    {
      var p1 = savThis.toPixelCoords(lgrad.grad[0], lgrad.grad[1]),
          p2 = savThis.toPixelCoords(lgrad.grad[2], lgrad.grad[3]),
          grad = savThis.ctx.createLinearGradient(p1.x, p1.y, p2.x, p2.y);

      lgrad.colorStops.forEach(function(colStop){grad.addColorStop(colStop[0], colStop[1]);});

      return grad;
    }

    function genRadGrad(rgrad)
    {
      var p1 = savThis.toPixelCoords(rgrad.grad[0], rgrad.grad[1]),
          r1 = rgrad.grad[2]*savThis.xscl,
          p2 = savThis.toPixelCoords(rgrad.grad[3], rgrad.grad[4]),
          r2 = rgrad.grad[5]*savThis.xscl,
          grad = savThis.ctx.createRadialGradient(p1.x, p1.y, r1, p2.x, p2.y, r2);

      rgrad.colorStops.forEach(function(colStop){grad.addColorStop(colStop[0], colStop[1]);});

      return grad;
    }

    if (fillColor)
    {
      this.ctx.save();
      if (fillColor instanceof LinearGradient)
      {
        this.ctx.fillStyle = genLinGrad(fillColor);
      }
      else if (fillColor instanceof RadialGradient)
      {
        this.ctx.fillStyle = genRadGrad(fillColor);
      }
      else
      {
        this.ctx.fillStyle = fillColor;
      }
      this.ctx.fillRect(0, 0, this.rawWidth, this.rawHeight);
      this.ctx.restore();
    }
    else
    {
      this.ctx.clearRect(0, 0, this.rawWidth, this.rawHeight);
    }
    // all drawing erased, but graphics contexts remain intact
    // clear the dragObjects array, draggables put back when rendered
    layerObj = getLayer(this);
    layerObj.dragObjects.length = 0;
  };

  Cango2D.prototype.setWorldCoords = function(lowerLeftX, lowerLeftY, spanX)
  {
    var vpLLxWC = lowerLeftX || 0,     // viewport lower left x in world coords
        vpLLyWC = lowerLeftY || 0;     // viewport lower left y in world coords
    if ((spanX === undefined) || (spanX &lt;= 0))
    {
      this.xscl = 1;                    // use pixel units
    }
    else
    {
      this.xscl = this.vpW/spanX;
    }
    this.yscl = -this.xscl;             // isotropic scale
    this.xoffset = -vpLLxWC*this.xscl;
    this.yoffset = -vpLLyWC*this.yscl;
  };

  Cango2D.prototype.setPropertyDefault = function(propertyName, value)
  {
    if ((typeof propertyName !== "string")||(value === undefined)||(value === null))
    {
      return;
    }
    switch (propertyName.toLowerCase())
    {
      case "fillcolor":
        if ((typeof value === "string")||(typeof value === "object"))  // gradient will be an object
        {
          this.paintCol = value;
        }
        break;
      case "strokecolor":
        if ((typeof value === "string")||(typeof value === "object"))  // gradient will be an object
        {
          this.penCol = value;
        }
        break;
      case "lineWidth":
      case "strokewidth":
        this.penWid = value;
        break;
      case "linecap":
        if ((typeof value === "string")&amp;&amp;((value === "butt")||(value ==="round")||(value === "square")))
        {
          this.lineCap = value;
        }
        break;
      case "fontfamily":
        if (typeof value === "string")
        {
          this.fontFamily = value;
        }
        break;
      case "fontsize":
        this.fontSize = value;
        break;
      case "fontweight":
        if ((typeof value === "string")||((value &gt;= 100)&amp;&amp;(value &lt;= 900)))
        {
          this.fontWeight = value;
        }
        break;
      case "steptime":
        if ((value &gt;= 15)&amp;&amp;(value &lt;= 500))
        {
          this.stepTime = value;
        }
        break;
      default:
        return;
    }
  };

  // this method allows the Object Group2D to be passed the Cango2D environment if necessary
  Cango2D.prototype.createGroup2D = function()
  {
    var grp = new Group2D();
    grp.addObj.apply(grp, arguments);

    return grp;
  };

  Cango2D.prototype.renderFrame = function(obj)
  {
    var savThis = this;

    function drawObj()
    {
      savThis.render(obj, true);  // pass clear canvas = true
    }

    window.requestAnimationFrame(drawObj);
  };

  Cango2D.prototype.dropShadow = function(obj, scl)
  {
    var xOfs = obj.shadowOffsetX || 0,
        yOfs = obj.shadowOffsetY || 0,
        radius = obj.shadowBlur || 0,
        color = obj.shadowColor || "#000000",
        xScale = scl || 1,
        yScale = scl || 1;

    if (this.ctx.shadowOffsetX !== undefined)     // check if supported
    {
      xScale *= this.xscl;
      yScale *= -this.xscl;

      this.ctx.shadowOffsetX = xOfs*xScale;
      this.ctx.shadowOffsetY = yOfs*yScale;
      this.ctx.shadowBlur = radius*xScale;
      this.ctx.shadowColor = color;
    }
  };

  /*=============================================
   * render will draw a Group2D or Obj2D.
   * If an Obj2D is passed, update the netTfm
   * and render it.
   * If a Group2D is passed, recursively update
   * the netTfm of the group's family tree,
   * then render all Obj2Ds.
   *--------------------------------------------*/
  Cango2D.prototype.render = function(rootObj, clear, animTime)
  {
    var savThis = this,
        objAry,
        time = animTime || 0;       // may be static render with animation possible - just paint t=0 frame

    function applyXfms(obj)
    {
      var grpTfmAry, grpTfm;

      if (obj.parent)
      {
        grpTfmAry = obj.parent.netTfmAry;    // grpTfm is always netTfm of the parent Group2D
        grpTfm = obj.parent.netTfm;
      }
      else                                   // must be the rootObj has no parent
      {
        grpTfmAry = [];
        grpTfm = new TransformMatrix();
      }
      obj.ofsTfm.reset();       // clear out previous transforms for TEXT and IMG Obj2D
      // now generate the group's netTfm which will be passed on to its kids (start with empty array)
      obj.netTfmAry = obj.ofsTfmAry.concat(grpTfmAry);
      // apply the transforms to the dwgOrg of the Group2 or the Obj2D
      obj.dwgOrg = {x:0, y:0};
      obj.netTfmAry.forEach(function(dtr){
        // call the user distort fn to do the distorting now
        dtr.args.unshift(time);    // shove the time into argument array for Tweeners
        obj.dwgOrg = dtr.distortFn.call(obj.dwgOrg, dtr.args);
        dtr.args.shift(time);    // dont' leave an old time there
      });
      if (obj.type !== "GRP")    // must be a Obj2D
      {
        if ((obj.type === "PATH")||(obj.type === "SHAPE"))
        {
          // reset the parms to orginal for each render
          obj.drawCmds.forEach(function(dc){
            dc.parms = clone(dc.parmsOrg);
          });  // make a copy
        }
        // apply the net transform to the obj2D (rotate, scale, skew and band first, while dwgOrg is 0,0
        obj.netTfmAry.forEach(function(dtr){
            // call the user distort fn to do the distorting now
            dtr.args.unshift(time);    // shove the time into argument array for Tweeners
            // call the user distort fn to do the distorting now
            dtr.distortFn.call(obj, dtr.args);
            dtr.args.shift(time);    // dont' leave an old time there
        });
        // update the matrix transforms for TEXT obj, IMG obj and gradient fills
        obj.netTfm.matrix = matrixMult(obj.hardOfsTfm.matrix, obj.ofsTfm.matrix); // apply softTfm to hardTfm
        obj.netTfm.applyTransform(grpTfm.matrix);     // apply inherited group tfms
      }
    }

    function recursiveApplyXfms()
    {
      var flatAry = [];

      // task:function, grp: group with children
    	function iterate(task, obj)
    	{
     		task(obj);
    	  if (obj.type === "GRP")    // find Obj2Ds to draw
        {
      		obj.children.forEach(function(childNode){
    				iterate(task, childNode);
    		  });
        }
        else
        {
          flatAry.push(obj);       // just push into the array to be drawn
        }
    	}
      // now propagate the current grpXfm through the tree of children
      iterate(applyXfms, rootObj);

      return flatAry;
    }

    function paintersSort(p1, p2)
    {
      return p1.zIndex - p2.zIndex;
    }

    function processObj2D(obj)
    {
      function imgLoaded(){
        obj.formatImg();
        savThis.paintImg(obj);
      }

      if (obj.type === "IMG")
      {
        if (obj.imgBuf.complete)    // see if already loaded
        {
          imgLoaded();
        }
        else
        {
          addEvent(obj.imgBuf, 'load', imgLoaded);
        }
      }
      else if (obj.type === "TEXT")
      {
        obj.formatText(savThis);
        savThis.paintText(obj);
      }
      else    // PATH, SHAPE
      {
        savThis.paintPath(obj);
      }
    }

// ============ Start Here =====================================================

    if (clear === true)
    {
      this.clearCanvas();
    }
    if (rootObj.type === "GRP")
    {
      // recursively apply transforms and return the flattened tree as an array of Obj2D to be drawn
      objAry = recursiveApplyXfms();
      objAry.sort(paintersSort);   // Depth sort Obj2Ds within group
      // now render the Obj2Ds onto the canvas
      objAry.forEach(processObj2D);
    }
    else   // Obj2D
    {
      applyXfms(rootObj);
      // draw the single Obj2D onto the canvas
      processObj2D(rootObj);
    }
  };

  Cango2D.prototype.paintImg = function(pathObj)
  {
    // should only be called after image has been loaded into drawCmds
    var savThis = this,
        tp,
        img = pathObj.imgBuf,  // this is the place the image is stored in object
        currLr, aidx;

    this.ctx.save();   // save the clean ctx
    // set up dropShadow if any
    this.dropShadow(pathObj, 1);
    // NOTE: these transforms get applied in reverse order
    this.worldToPixel.reset();   // reset to identity matrix
    // these transforms aprear as if in reverse order
    this.worldToPixel.applyTransform(scaleMatrix(1, -1));    // invert all world coords values
    this.worldToPixel.applyTransform(pathObj.netTfm.matrix); // apply net translates, scale and rotations
    this.worldToPixel.applyTransform(scaleMatrix(this.xscl, this.yscl));    // world coords to pixels
    this.worldToPixel.applyTransform(translateMatrix(this.vpLLx + this.xoffset, this.vpLLy + this.yoffset)); //  viewport offset
    transformCtx(this.ctx, this.worldToPixel);
    // now insert the image scaled in  pixels
    this.ctx.drawImage(img, pathObj.imgLorgX, pathObj.imgLorgY, pathObj.width, pathObj.height);
    this.ctx.restore();    // undo the transforms
    // make a hitRegion boundary path around the image to be checked on mousedown
    pathObj.bBoxCmds.forEach(function(dCmd){
      if (dCmd.parms.length)    // last cmd is closePath has no parms
      {
        tp = transformPoint(dCmd.parms[0][0], dCmd.parms[0][1], pathObj.netTfm.matrix);
        dCmd.parmsPx[0] = savThis.vpLLx+savThis.xoffset+tp.x*savThis.xscl;
        dCmd.parmsPx[1] = savThis.vpLLy+savThis.yoffset+tp.y*savThis.yscl;
      }
    });
    if (pathObj.border)
    {
      this.ctx.beginPath();
      pathObj.bBoxCmds.forEach(function(dCmd){
        savThis.ctx[dCmd.drawFn].apply(savThis.ctx, dCmd.parmsPx);
      });
      this.ctx.strokeStyle = pathObj.strokeCol || this.penCol;
      // if properties are undefined use Cango2D default
      this.ctx.lineWidth = pathObj.lineWidth || this.penWid;
      this.ctx.lineCap = pathObj.lineCap || this.lineCap;
      this.ctx.stroke();
    }

    if (pathObj.dragNdrop !== null)
    {
      // update dragNdrop layer to match this canavs
      currLr = getLayer(this);
      if (currLr !== pathObj.dragNdrop.layer)
      {
        if (pathObj.dragNdrop.layer)  // if not the first time rendered
        {
          // remove the object reference from the old layer
          aidx = pathObj.dragNdrop.layer.dragObjects.indexOf(this);
          if (aidx !== -1)
          {
            pathObj.dragNdrop.layer.dragObjects.splice(aidx, 1);
          }
        }
      }
      pathObj.dragNdrop.cgo = this;
      pathObj.dragNdrop.layer = currLr;
      // now push it into Cango.dragObjects array, its checked by canvas mousedown event handler
      if (!pathObj.dragNdrop.layer.dragObjects.contains(pathObj))
      {
        pathObj.dragNdrop.layer.dragObjects.push(pathObj);
      }
    }
  };

  Cango2D.prototype.paintPath = function(pathObj)
  {
    // used for type: PATH, SHAPE
    var savThis = this,
        lineWd,
        col, gradFill,
        currLr, aidx,
        dashedPx = [],
        xsc = this.xscl;

    function genLinGrad(lgrad)
    {
      var p1x = lgrad.grad[0],
          p1y = lgrad.grad[1],
          p2x = lgrad.grad[2],
          p2y = lgrad.grad[3],
          grad = savThis.ctx.createLinearGradient(p1x, p1y, p2x, p2y);

      lgrad.colorStops.forEach(function(colStop){grad.addColorStop(colStop[0], colStop[1]);});

      return grad;
    }

    function genRadGrad(rgrad)
    {
      var p1x = rgrad.grad[0],
          p1y = rgrad.grad[1],
          r1 = rgrad.grad[2],
          p2x = rgrad.grad[3],
          p2y = rgrad.grad[4],
          r2 = rgrad.grad[5],
          grad = savThis.ctx.createRadialGradient(p1x, p1y, r1, p2x, p2y, r2);

      rgrad.colorStops.forEach(function(colStop){grad.addColorStop(colStop[0], colStop[1]);});

      return grad;
    }

    this.ctx.save();   // save current context
    this.dropShadow(pathObj, 1); // set up dropShadow if any
    this.worldToPixel.reset();   // reset to identity matrix
    // convert world coordinates to pixel coords for raw canvas commands
    this.worldToPixel.applyTransform(scaleMatrix(this.xscl, this.yscl));  // isotropic (yscl = -xscl)
    this.worldToPixel.applyTransform(translateMatrix(this.vpLLx+this.xoffset, this.vpLLy+this.yoffset));
    transformCtx(this.ctx, this.worldToPixel);
    // now draw the path onto the canvas in pixel coords
    this.ctx.beginPath();
    pathObj.drawCmds.forEach(function(drwCmd){
      var flatAry = [];   // start with new array
      drwCmd.parms.forEach(function(coord){
        flatAry.push(coord[0], coord[1]);
      });
      savThis.ctx[drwCmd.drawFn].apply(savThis.ctx, flatAry); // add the path segment
    });
    // rescale canvas to apply the matrix transforms to linewidth and gradients when we stroke and fill
    this.ctx.save();   // save current context
    this.worldToPixel.reset();   // reset to identity matrix
    this.worldToPixel.applyTransform(pathObj.netTfm.matrix);
    this.worldToPixel.applyTransform(scaleMatrix(this.xscl, this.yscl));
    this.worldToPixel.applyTransform(translateMatrix(this.vpLLx+this.xoffset, this.vpLLy+this.yoffset));
    transformCtx(this.ctx, this.worldToPixel);   // scaled to pixels with all transforms applied
    if (pathObj.type === "SHAPE")
    {
      // if a SHAPE, fill with color
      col = pathObj.fillCol || this.paintCol;
      if (col instanceof LinearGradient)
      {
        gradFill = genLinGrad(col);
        this.ctx.fillStyle = gradFill;
      }
      else if (col instanceof RadialGradient)
      {
        gradFill = genRadGrad(col);
        this.ctx.fillStyle = gradFill;
      }
      else
      {
        this.ctx.fillStyle = col;
      }
      this.ctx.fill();
      // clear drop shadow its done (and we might want to stroke border)
      this.ctx.shadowOffsetX = 0;
      this.ctx.shadowOffsetY = 0;
      this.ctx.shadowBlur = 0;
    }
    if ((pathObj.type === "PATH")|| pathObj.border)
    {
      // handle dashed lines
      if (pathObj.dashed)
      {
        pathObj.dashed.forEach(function(d, i){dashedPx[i] = d/xsc;});   // undo the effect of pixel scaling
        this.ctx.setLineDash(dashedPx);
        this.ctx.lineDashOffset = pathObj.dashOffset/xsc;
      }
      // pathObj.strokeCol may be a function that generates dynamic color (so call it)
      this.ctx.strokeStyle = pathObj.strokeCol || this.penCol;
      lineWd = pathObj.lineWidth || this.penWid;
      this.ctx.lineWidth = lineWd/this.xscl;  // lineWidth in pixels and we are currently scaled to WC
      this.ctx.lineCap = pathObj.lineCap || this.lineCap;
      this.ctx.stroke();
    }
    this.ctx.restore();   // undo the matrix transforms
    this.ctx.restore();   // undo world to pixels
    if (pathObj.dragNdrop !== null)
    {
      // generate the outline path in pixel coords for hit testing
      pathObj.drawCmds.forEach(function(dCmd){
        dCmd.parmsPx = [];
        dCmd.parms.forEach(function(coord){
          dCmd.parmsPx.push(savThis.vpLLx+savThis.xoffset+coord[0]*savThis.xscl);
          dCmd.parmsPx.push(savThis.vpLLy+savThis.yoffset+coord[1]*savThis.yscl);
        });
      });
      // update dragNdrop layer to match this canvas
      currLr = getLayer(this);
      if (currLr !== pathObj.dragNdrop.layer)
      {
        if (pathObj.dragNdrop.layer)  // if not the first time rendered
        {
          // remove the object reference from the old layer
          aidx = pathObj.dragNdrop.layer.dragObjects.indexOf(this);
          if (aidx !== -1)
          {
            pathObj.dragNdrop.layer.dragObjects.splice(aidx, 1);
          }
        }
      }
      pathObj.dragNdrop.cgo = this;
      pathObj.dragNdrop.layer = currLr;
      // now push it into Cango.dragObjects array, its checked by canvas mousedown event handler
      if (!pathObj.dragNdrop.layer.dragObjects.contains(pathObj))
      {
        pathObj.dragNdrop.layer.dragObjects.push(pathObj);
      }
    }
  };

  Cango2D.prototype.paintText = function(pathObj)
  {
    var savThis = this,
        tp,
        fntWt, fntSz, fntFm,
        currLr, aidx;

    this.ctx.save();   // save the clean ctx
    // set up dropShadow if any
    this.dropShadow(pathObj, 1/this.xscl);  // compensate for world coord scaling
    this.worldToPixel.reset();   // reset to identity matrix
    this.worldToPixel.applyTransform(scaleMatrix(1/this.xscl, 1/this.yscl));    // text is in pixels, make it world coords
    this.worldToPixel.applyTransform(pathObj.netTfm.matrix);  // apply offsets scale and rotations (now in wolrd ccords)
    this.worldToPixel.applyTransform(scaleMatrix(this.xscl, this.yscl));       // world to pixels ready to renders
    this.worldToPixel.applyTransform(translateMatrix(this.vpLLx + this.xoffset, this.vpLLy + this.yoffset)); // move origin px
    transformCtx(this.ctx, this.worldToPixel);

    // if Obj2D fontWeight or fontSize undefined use Cango2D default
    fntWt = pathObj.fontWeight || this.fontWeight;
    fntSz = pathObj.fontSize || this.fontSize;
    fntFm = pathObj.fontFamily || this.fontFamily;
    this.ctx.font = fntWt+" "+fntSz+"px "+fntFm;
    this.ctx.fillStyle = pathObj.fillCol || this.paintCol;
    this.ctx.fillText(pathObj.drawCmds, pathObj.imgLorgX, pathObj.imgLorgY); // imgLorgX,Y are in pixels for text
    if (pathObj.border)
    {
      // fill done, if dropShadow dont apply to the border (it will be on top of fill)
      this.ctx.shadowOffsetX = 0;
      this.ctx.shadowOffsetY = 0;
      this.ctx.shadowBlur = 0;
      // if properties are undefined use Cango2D default
      this.ctx.strokeStyle = pathObj.strokeCol || this.penCol;
      this.ctx.lineWidth = pathObj.lineWidth || this.penWid;
      this.ctx.lineCap = pathObj.lineCap || this.lineCap;
      this.ctx.strokeText(pathObj.drawCmds, pathObj.imgLorgX, pathObj.imgLorgY);
    }
    // undo the translation
    this.ctx.restore();

    // make a hitRegion boundary path around the text to be checked on mousedown
    pathObj.bBoxCmds.forEach(function(dCmd){
      if (dCmd.parms.length)    // last cmd is closePath has no parms
      {
        tp = transformPoint(dCmd.parms[0][0]/savThis.xscl, dCmd.parms[0][1]/savThis.xscl, pathObj.netTfm.matrix);
        dCmd.parmsPx[0] = savThis.vpLLx+savThis.xoffset+tp.x*savThis.xscl;
        dCmd.parmsPx[1] = savThis.vpLLy+savThis.yoffset+tp.y*savThis.yscl;
      }
    });
    if (pathObj.dragNdrop !== null)
    {
      // update dragNdrop layer to match this canavs
      currLr = getLayer(this);
      if (currLr !== pathObj.dragNdrop.layer)
      {
        if (pathObj.dragNdrop.layer)  // if not the first time rendered
        {
          // remove the object reference from the old layer
          aidx = pathObj.dragNdrop.layer.dragObjects.indexOf(this);
          if (aidx !== -1)
          {
            pathObj.dragNdrop.layer.dragObjects.splice(aidx, 1);
          }
        }
      }
      pathObj.dragNdrop.cgo = this;
      pathObj.dragNdrop.layer = currLr;
      // now push it into Cango.dragObjects array, its checked by canvas mousedown event handler
      if (!pathObj.dragNdrop.layer.dragObjects.contains(pathObj))
      {
        pathObj.dragNdrop.layer.dragObjects.push(pathObj);
      }
    }
  };

  Cango2D.prototype.drawPath = function(path, x, y, options)
  {
    var pathObj = new Obj2D(path, "PATH", options);

    if ((typeof x === 'number')&amp;&amp;(typeof y === 'number'))
    {
      pathObj.transform.translate(x, y);
    }
    this.render(pathObj);

    return pathObj;
  };

  Cango2D.prototype.drawShape = function(path, x, y, options)
  {
    // outline the same as fill color
    var pathObj = new Obj2D(path, "SHAPE", options);

    if ((typeof x === 'number')&amp;&amp;(typeof y === 'number'))
    {
      pathObj.transform.translate(x, y);
    }
    this.render(pathObj);

    return pathObj;
  };

  Cango2D.prototype.drawText = function(str, x, y, options)
  {
    var txtObj = new Obj2D(str, "TEXT", options);

    if ((typeof x === 'number')&amp;&amp;(typeof y === 'number'))
    {
      txtObj.transform.translate(x, y);
    }
    this.render(txtObj);

    return txtObj;
  };

  Cango2D.prototype.drawImg = function(imgRef, x, y, options)  // just load img then call render
  {
    var imgObj = new Obj2D(imgRef, "IMG", options);  // imgObj.drawCmds = new image object

    if ((typeof x === 'number')&amp;&amp;(typeof y === 'number'))
    {
      imgObj.transform.translate(x, y);
    }
    this.render(imgObj);

    return imgObj;
  };

  Cango2D.prototype.clipPath = function(pathObj)
  {
    if ((pathObj.type === "IMG")||(pathObj.type === "TEXT"))
    {
      return;
    }
    this.ctx.save();              // undo using resetClip method
    this.ctx.beginPath();
    pathObj.drawCmds.forEach(function(dCmd){
      var pxlCoords = [];
      dCmd.parms.forEach(function(coord){
        // convert x,y coord pairs to pixel coords
        pxlCoords.push(this.vpLLx+this.xoffset+this.xscl*coord[0]);
        pxlCoords.push(this.vpLLy+this.yoffset+this.yscl*coord[1]);
      });
      this.ctx[dCmd.drawFn].apply(this.ctx, pxlCoords); // actually draw the path
    });
    this.ctx.clip();
  };

  Cango2D.prototype.resetClip = function()
  {
    // this.ctx.resetClip();       // not supported in bowsers yet (Feb13)
    this.ctx.restore();            // use this until resetClip is supported
  };

  Cango2D.prototype.animate = function(rootObj)
  {
    var animObj = new Animation(this, rootObj);

    this.stopAnimation();   // make sure we are not still running and old animation
    this.bkgCanvas.timeline.animTasks.push(animObj);
  };

  Cango2D.prototype.createLayer = function()
  {
    var ovlHTML, newCvs,
        w = this.rawWidth,
        h = this.rawHeight,
        unique, ovlId,
        nLyrs = this.bkgCanvas.layers.length,  // bkg is layer 0 so at least 1
        newL,
        topCvs;

    // do not create layers on overlays - only an background canvases
    if (this.cId.indexOf("_ovl_") !== -1)
    {
      // this is an overlay canvas - can't have overlays itself
      console.log("canvas layers can't create layers");
      return "";
    }

    unique = this.getUnique();
    ovlId = this.cId+"_ovl_"+unique;
    ovlHTML = "&lt;canvas id='"+ovlId+"' style='position:absolute' width='"+w+"' height='"+h+"'&gt;&lt;/canvas&gt;";
    topCvs = this.bkgCanvas.layers[nLyrs-1].cElem;  // eqv to this.cnvs.layers since only bkgCanavs can get here
    topCvs.insertAdjacentHTML('afterend', ovlHTML);
    newCvs = document.getElementById(ovlId);
    newCvs.style.backgroundColor = "transparent";
    newCvs.style.left = (this.bkgCanvas.offsetLeft+this.bkgCanvas.clientLeft)+'px';
    newCvs.style.top = (this.bkgCanvas.offsetTop+this.bkgCanvas.clientTop)+'px';
    // make it the same size as the background canvas
    newCvs.style.width = this.bkgCanvas.offsetWidth+'px';
    newCvs.style.height = this.bkgCanvas.offsetHeight+'px';
//    newCvs.style.pointerEvents = 'none';    // allow mouse events to pass down to bkgCanvas
    newL = new Layer(ovlId, newCvs);
    // save the ID in an array to facilitate removal
    this.bkgCanvas.layers.push(newL);

    return ovlId;    // return the new canvas id for call to new Cango(id)
  };

  Cango2D.prototype.deleteLayer = function(ovlyId)
  {
    var ovlNode, i;

    for (i=1; i&lt;this.bkgCanvas.layers.length; i++)
    {
      if (this.bkgCanvas.layers[i].id === ovlyId)
      {
        ovlNode = this.bkgCanvas.layers[i].cElem;
        if (ovlNode)
        {
          // in case the CangoHTMLtext extension is used
          if (ovlNode.alphaOvl &amp;&amp; ovlNode.alphaOvl.parentNode)
          {
            ovlNode.alphaOvl.parentNode.removeChild(ovlNode.alphaOvl);
          }
          ovlNode.parentNode.removeChild(ovlNode);
        }
        // now delete layers array element
        this.bkgCanvas.layers.splice(i,1);       // delete the id
      }
    }
  };

  Cango2D.prototype.deleteAllLayers = function()
  {
    var i, ovlNode;

    for (i = this.bkgCanvas.layers.length-1; i&gt;0; i--)   // don't delete layers[0] its the bakg canavs
    {
      ovlNode = this.bkgCanvas.layers[i].cElem;
      if (ovlNode)
      {
        // in case the CangoHTMLtext extension is used
        if (ovlNode.alphaOvl &amp;&amp; ovlNode.alphaOvl.parentNode)
        {
          ovlNode.alphaOvl.parentNode.removeChild(ovlNode.alphaOvl);
        }
        ovlNode.parentNode.removeChild(ovlNode);
      }
      // now delete layers array element
      this.bkgCanvas.layers.splice(i,1);
    }
  };

  // copy the basic graphics context values (for an overlay)
  Cango2D.prototype.dupCtx = function(src_graphCtx)
  {
    // copy all the graphics context parameters into the overlay ctx.
    this.vpW = src_graphCtx.vpW;          // vp width in pixels
    this.vpH = src_graphCtx.vpH;          // vp height in pixels
    this.vpLLx = src_graphCtx.vpLLx;      // vp lower left from canvas left in pixels
    this.vpLLy = src_graphCtx.vpLLy;      // vp lower left from canvas top
    this.xscl = src_graphCtx.xscl;        // world x axis scale factor
    this.yscl = src_graphCtx.yscl;        // world y axis scale factor
    this.xoffset = src_graphCtx.xoffset;  // world x origin offset from viewport left in pixels
    this.yoffset = src_graphCtx.yoffset;  // world y origin offset from viewport bottom in pixels
    this.penCol = src_graphCtx.penCol.slice(0);   // copy value not reference
    this.penWid = src_graphCtx.penWid;    // pixels
    this.lineCap = src_graphCtx.lineCap.slice(0);
    this.paintCol = src_graphCtx.paintCol.slice(0);
    this.fontSize = src_graphCtx.fontSize;
    this.fontWeight = src_graphCtx.fontWeight;
    this.fontFamily = src_graphCtx.fontFamily.slice(0);
  };

  svgToCgo2D = svgParser.svg2cartesian;

  return Cango2D;
}());</t>
<t tx="amd.20151125094905.1">/*=================================================================
  Filename: Cango3D-7v09.js
  By: A.R.Collins

  A basic 3D graphics interface for the canvas
  element using Right Handed coordinate system.

  Kindly give credit to Dr A R Collins &lt;http://www.arc.id.au/&gt;
  Report bugs to tony at arc.id.au

  Date   |Description                                          |By
  -----------------------------------------------------------------
  05May13 First beta after major re-write: soft transforms
          now applied by Group3D method not by render3D.
          Transforms now use grpTfm, ofsTfm, netTfm             ARC
  06May13 bugfix: order of transform multiply reversed
          Make matrixMultiply and transform point globals
          Use RequestAnimationFrame                             ARC
  07May13 Give Group3Ds and Obj3Ds a render method
          Use rAF to limit code in event handlers
          bugfix: group nettFm mat multiply in wrong order
          Only propagate transform updates when rendering       ARC
  08May13 Changed labelShape3D to labelShape                    ARC
  09May13 Don't allow clone to clone cgo property
          Allow only Group3Ds or Obj3Ds to join a Group3D.
          Removed clearCanvas color setting ability (not
          compatable with the new render method). Set
          canvas backgroundColor with setPropertyDefault.
          Added noclear parameter to render3D
          Added noclear, noRaf options to obj and grp render    ARC
  10May13 bugfix: non existant cgo used in compileText3D
          bugfix: bad vectors for calcNormal if cmd = 'Q'       ARC
  11May13 Removed unsed dupCtx
          renamed jsonToDrawCnds3D to _cgo3DtoDrawCmd3D
          Gave objectOfRevolution a 'straight' side option      ARC
  12May13 Replace objOfRev 'radius' with 'xOfs' (opp sign)      ARC
  13May13 Change the depth sort algorithm, sort Group3Ds
          by group centroid.tz, then sort Obj3Ds children.
          If objectOfRevolution has flat top or bottom
          replace multi-segments with single disc
          Patched JSONtoObj3D Group3D decode to be robust
          bugfix: dwgOrg not getting transformed - re-write
          dump Obj3D.dwgOrg and dwgOrgPx, leave in dragNdrop
          bugfix: calcNormal and calcIncAngle could /zero       ARC
  16May13 renamed undocumented methods calcShapeShade,
          getCursorPos and render3D to _calcShapeShade,
          _getCursorPos and _render3D                           ARC
  17May13 Release 3v19                                          ARC
  21May13 Add grpDwgOrg to dragNdrop tracking rootGrp dwgOrg
          and include Z dimension in all drag offsets
          bugfix: bad loop end test (typo in 3v20)
          Added z:0 to cursor positon passed to dragNdrop
          handlers                                              ARC
  22May13 Pass cursor position in world coords                  ARC
  01Jun13 bugfix: _resized etc should be Objects not Arrays     ARC
  02Jun13 Many style changes to make JSLint happy               ARC
  03Jun13 Make clone a private function of objectOfRotation     ARC
  08Jun13 Make PaintersSort a private function                  ARC
  12Jun13 Refactor for performance
          Mod Obj3DtoJSON, JSONtoObj3D to new DrawCmd3Ds
          bugfix: Obj3DtoJSON miss-handled TEXT path
          Add Transform3D.reset to avoid new object creation    ARC
  13Jun13 Re-write matrix ops to assist code optimizers
          Add dwgOrg to Group3Ds and Obj3Ds                     ARC
  14Jun13 Filter rAF calls with rAFactive flag
          Have default rAF loop state running not stopped
          bugfix: textBoxCmds not transformed
          bugfix: no check if draggable already in draggables   ARC
  15Jun13 Use strict mode                                       ARC
  20Jun13 Fix bugs in dragNdrop parent being over-written etc   ARC
  12Aug13 Renamed shapeDefs to shapes3D (avoid 2D shapeDefs)    ARC
  04Sep13 Replace setViewpointDistance with set FOV
          Don't expose Transform3D to user, use StaticTfm       ARC
  06Sep13 Code tidied for JSLint
          Remove drag as a parameter from compile methods
          grpDwgOrg now refers to parent Group3D not root       ARC
  07Sep13 Add parent property to Obj3D and Group3D
          Renamed Drag3D.parent to target for clarity           ARC
  09Sep13 Remove Obj3D.render and Group3D.render, use only
          use Cango3D.render or Cango3D.renderFrame             ARC
  11Sep13 bugfix: memory leak, ofsTfmAry not reset every frame  ARC
  14Sep13 Use better algorithm for viewpointDistance calc       ARC
  22Feb14 Added check that lorg values are always in [1..9]
          bugfix: lineWidth badly tracking fontSize             ARC
  25Feb14 Re-write of text include Hershey font Greek letters   ARC
  31May14 Drop scl parm from compilePath3D and compileShape3D
          Make shapes3D functions returns array of Cgo3D
          Change labelShape parms order to match compileText3D  ARC
  01Jun14 Make _cgo3DtoDrawCmd3D into cgo3DtoDrawCmd3D function
          Add Obj3D property backHidden (Boolean)               ARC
  09Jun14 Replace labelShape3D with tagShape3D and appendTag
          this drops obj.textCmds from SHAPE objects            ARC
  10Jun14 New depth sort algorithm
          Removed redundant transform matrix definitons
          Removed now unused drawObjs property from Group3D     ARC
  11Jun14 Removed pointer to Cango3D instance from Obj3D args   ARC
  14Jun14 bugfix: grp.enableDrag only 2 generations deep, make
          enable recursive                                      ARC
  16Jun14 Added grabCsrPos and target properties to Drag3D      ARC
  17Jun14 Cleaned up redundant dwgOrg transforms in render      ARC
  22Jun14 Text compiled at original size, fontSize and lorg
          transforms applied at render using lorgTfm matrix.
          JSON file methods updated to handle new text style    ARC
  23Jun14 Change property name 'strokeWidth' to 'lineWidth'.
          Added setProperty method to Obj3D.
          hardTransform TEXT centroid immediately to match
          behavoiur of SHAPE when TEXT used as a tag            ARC
  24Jun14 Change Obj3D args to take an 'options' object that
          can set any property.
          Obj3D now takes Cgo3D (SVG) data not DrawCmd3D        ARC
  26Jun14 Don't overwrite Obj3D colors in render use local var
          bugfix: cgo.backColor used, should be cgo.backCol     ARC
  28Jun14 Release 6v00 from 6beta-38                            ARC
  16Aug14 Update dragNdrop, Drag3D becomes private,
          enableDrag takes callbacks as arguments.
          Released as 7v00                                      ARC
  14Dec14 Adjusted Hershey fontSize to match canvas fontSzie    ARC
  25Jun15 Refactor for readability
          Renamed Transform3D to TransformMatrix
          shapeDefs.circle &amp; ellipse had 'm' z coord missing    ARC
  28Jun15 Cleanup all the application of transforms in render
          Use functional programming version of the svgParser   ARC
  =================================================================*/

  // exposed globals
  var Obj3D, Group3D,
      svgToCgo3D, // SVG path data string conversion utility function
      calcNormal, calcIncAngle,
      shapes3D;   // predefined geometric shapes in Cgo3D format

var Cango3D = (function()
{
  "use strict";

  var cgo3DtoDrawCmd3D,
      hersheyFont = { };

  if (!Date.now)
  {
    Date.now = function now()
    {
      return new Date().getTime();
    };
  }

  var isArray = function(obj)
  {
    return Array.isArray(obj);
  };

  var isNumber = function(o)
  {
    return !isNaN(o) &amp;&amp; o !== null &amp;&amp; o !== "" &amp;&amp; o !== false;
  };

  // simple add event handler that has the handlers called in the sequence that they were set
  var addLoadEvent = function(obj, func)
  {
  	var oldonload = obj.onload;

  	if (typeof(obj.onload) !== "function")
    {
      obj.onload = func;
    }
  	else
    {
    	obj.onload = function(){ oldonload(); func(); };
    }
  };

  var addEvent = function(element, eventType, handler)
  {
    if (element.attachEvent)
    {
     return element.attachEvent('on'+eventType, handler);
    }
    return element.addEventListener(eventType, handler, false);
  };

  var removeEvent = function(element, eventType, handler)
  {
   if (element.removeEventListener)
   {
      element.removeEventListener (eventType, handler, false);
   }
   if (element.detachEvent)
   {
      element.detachEvent ('on'+eventType, handler);
   }
  };

  if (!Array.prototype.contains)
  {
    Array.prototype.contains = function(obj)
    {
      var i = this.length;
      while (i--)
      {
        if (this[i] === obj)
        {
          return true;
        }
      }
      return false;
    };
  }

  /* ========================================================================
   * This svgParser is an object with 2 methods.
   *
   * svg2cgo3d: Converts SVG format 2D data which can be either a String or an
   * Array in format "M, x, y, L, x, y ... " or ['M', x, y, 'L', x, y ... ]
   * to Cgo3D array ['M',x,y,z, 'L',x,y,z, ... 'Q',cx,cy,cz,x,y,z ]
   * Path data from SVG editors often have the drawing origin offset a long
   * way, xRef, yRef will be added to all coords to correct this
   * NOTE: String format data is assumed to be Y +ve down and so all
   * Y coordinates are flipped in sign. This does not happen to array data.
   *
   * cgo3DtoDrawcmd: Converts an array of Cgo3D dta if the format
   * ['M',x,y,z, 'L',x,y,z, ... 'Q',cx,cy,cz,x,y,z, 'Z'] to DrawCmd3D objects
   * -----------------------------------------------------------------------*/
  var svgParser = (function ()
  {
    var segmentToBezier = function(cx, cy, th0, th1, rx, ry, sin_th, cos_th) {
          var a00 = cos_th * rx,
              a01 = -sin_th * ry,
              a10 = sin_th * rx,
              a11 = cos_th * ry,
              th_half = 0.5 * (th1 - th0),
              t = (8/3) * Math.sin(th_half * 0.5) * Math.sin(th_half * 0.5) / Math.sin(th_half),
              x1 = cx + Math.cos(th0) - t * Math.sin(th0),
              y1 = cy + Math.sin(th0) + t * Math.cos(th0),
              x3 = cx + Math.cos(th1),
              y3 = cy + Math.sin(th1),
              x2 = x3 + t * Math.sin(th1),
              y2 = y3 - t * Math.cos(th1);

          return [ a00 * x1 + a01 * y1, a10 * x1 + a11 * y1, 0,    // add the z coord here
                   a00 * x2 + a01 * y2, a10 * x2 + a11 * y2, 0,
                   a00 * x3 + a01 * y3, a10 * x3 + a11 * y3, 0 ];
        },
        arcToBezier = function(ox, oy, radx, rady, rotateX, large, sweep, x, y)
        {
          var th = rotateX * (Math.PI/180),
              sin_th = Math.sin(th),
              cos_th = Math.cos(th),
              rx = Math.abs(radx),
              ry = Math.abs(rady),
              px = cos_th * (ox - x) * 0.5 + sin_th * (oy - y) * 0.5,
              py = cos_th * (oy - y) * 0.5 - sin_th * (ox - x) * 0.5,
              pl = (px*px) / (rx*rx) + (py*py) / (ry*ry),
              a00, a01, a10, a11,
              x0, y0, x1, y1,
              d,
              sfactor_sq,
              sfactor,
              xc, yc,
              th0, th1,
              th_arc,
              segments,
              seg, tidySeg,
              result = [],
              i, th2, th3;

          function roundZeros(coord)
          {
            return ((Math.abs(coord) &lt; 0.00001)? 0: coord);
          }

          if (pl &gt; 1)
          {
            pl = Math.sqrt(pl);
            rx *= pl;
            ry *= pl;
          }
          a00 = cos_th / rx;
          a01 = sin_th / rx;
          a10 = -sin_th / ry;
          a11 = cos_th / ry;
          x0 = a00 * ox + a01 * oy;
          y0 = a10 * ox + a11 * oy;
          x1 = a00 * x + a01 * y;
          y1 = a10 * x + a11 * y;
          d = (x1-x0) * (x1-x0) + (y1-y0) * (y1-y0);
          sfactor_sq = 1 / d - 0.25;
          if (sfactor_sq &lt; 0)
          {
            sfactor_sq = 0;
          }
          sfactor = Math.sqrt(sfactor_sq);
          if (sweep === large)
          {
            sfactor = -sfactor;
          }
          xc = 0.5 * (x0 + x1) - sfactor * (y1-y0);
          yc = 0.5 * (y0 + y1) + sfactor * (x1-x0);
          th0 = Math.atan2(y0-yc, x0-xc);
          th1 = Math.atan2(y1-yc, x1-xc);
          th_arc = th1-th0;
          if (th_arc &lt; 0 &amp;&amp; sweep === 1)
          {
            th_arc += 2*Math.PI;
          }
          else if (th_arc &gt; 0 &amp;&amp; sweep === 0)
          {
            th_arc -= 2 * Math.PI;
          }
          segments = Math.ceil(Math.abs(th_arc / (Math.PI * 0.5 + 0.001)));
          for (i=0; i&lt;segments; i++)
          {
            th2 = th0 + i * th_arc / segments;
            th3 = th0 + (i+1) * th_arc / segments;
            seg = segmentToBezier(xc, yc, th2, th3, rx, ry, sin_th, cos_th);
            tidySeg = seg.map(roundZeros);
            result.push(tidySeg);
          }

          return result;
        },
        /*===============================================
         *
         * svgProtocol object defining each command
         * with methods to convert to Cgo2D for both
         * cartesian and SVG coordinate systems
         *
         *==============================================*/
        svgProtocol = {
          "M": {
            parmCount: 2,
            parmCount3D: 3,
            extCmd: "L",
            toAbs: function(acc, curr) {
              var cmd = curr[0].toUpperCase(),  // uppercase command means absolute coords
                  x = curr[1],
                  y = curr[2],
                  currAbs;
              // Check if 'curr' was a relative (lowercase) command
              if (cmd !== curr[0]) {
                x += acc.px;
                y += acc.py;
              }
              currAbs = [cmd, x, y];
              acc.px = x;
              acc.py = y;
              return currAbs;
            },
            toAbs3D: function(acc, curr) {
              var cmd = curr[0].toUpperCase(),  // uppercase command means absolute coords
                  x = curr[1],
                  y = curr[2],
                  z = curr[3],
                  currAbs;
              // Check if 'curr' was a relative (lowercase) command
              if (cmd !== curr[0]) {
                x += acc.px;
                y += acc.py;
                z += acc.pz;
              }
              currAbs = [cmd, x, y, z];
              acc.px = x;
              acc.py = y;
              acc.pz = z;
              return currAbs;
            },
            toCango3DVersion: function(acc, curr) {
              var cmd = curr[0],
                  x = curr[1],
                  y = curr[2],
                  z = 0;

              acc.px = x;  // update the pen position for next command
              acc.py = y;
              acc.push([cmd, x, y, z]); // push the curr, "M" is a Cango internal command
            },
            addXYoffset: function(curr, xOfs, yOfs){
              var x = curr[1],
                  y = curr[2];

              x += xOfs;
              y += yOfs;
              return ["M", x, y];   // invert y coords to make Cgo2D format
            },
            invertCoords: function(curr){
              var x = curr[1],
                  y = curr[2];

              return ["M", x, -y];   // invert y coords to make Cgo2D format
            },
            toDrawCmd: function(curr){
              var x = curr[1],
                  y = curr[2],
                  z = curr[3],
                  cPts = [],
                  ep = new Point(x, y, z);

              return new DrawCmd3D('moveTo', cPts, ep);
            }
          },
          "L": {
            parmCount: 2,
            parmCount3D: 3,
            extCmd: "L",
            toAbs: function(acc, curr) {
              var cmd = curr[0].toUpperCase(),  // uppercase command means absolute coords
                  x = curr[1],
                  y = curr[2],
                  currAbs;
              // Check if 'curr' was a relative (lowercase) command
              if (cmd !== curr[0]) {
                x += acc.px;
                y += acc.py;
              }
              currAbs = [cmd, x, y];
              acc.px = x;
              acc.py = y;
              return currAbs;
            },
            toAbs3D: function(acc, curr) {
              var cmd = curr[0].toUpperCase(),  // uppercase command means absolute coords
                  x = curr[1],
                  y = curr[2],
                  z = curr[3],
                  currAbs;
              // Check if 'curr' was a relative (lowercase) command
              if (cmd !== curr[0]) {
                x += acc.px;
                y += acc.py;
                z += acc.pz;
              }
              currAbs = [cmd, x, y, z];
              acc.px = x;
              acc.py = y;
              acc.pz = z;
              return currAbs;
            },
            toCango3DVersion: function(acc, curr) {
              var cmd = curr[0],
                  x = curr[1],
                  y = curr[2],
                  z = 0;

              acc.px = x;  // update the pen position for next command
              acc.py = y;
              acc.push([cmd, x, y, z]); // push the curr, "L" is a Cango internal command
            },
            addXYoffset: function(curr, xOfs, yOfs){
              var x = curr[1],
                  y = curr[2];

              x += xOfs;
              y += yOfs;
              return ["L", x, y];   // invert y coords to make Cgo2D format
            },
            invertCoords: function(curr){
              var x = curr[1],
                  y = curr[2];

              return ["L", x, -y];   // invert y coords to make Cgo2D format
            },
            toDrawCmd: function(curr){
              var x = curr[1],
                  y = curr[2],
                  z = curr[3],
                  cPts = [],
                  ep = new Point(x, y, z);

              return new DrawCmd3D('lineTo', cPts, ep);
            }
          },
          "H": {
            parmCount: 1,
            extCmd: "H",
            toAbs: function(acc, curr) {
              var cmd = curr[0].toUpperCase(),   // uppercase command means absolute coords
                  x = curr[1],
                  currAbs;
              // Check if 'curr' was a relative (lowercase) command
              if (cmd !== curr[0]) {
                x += acc.px;
              }
              currAbs = [cmd, x];
              acc.px = x;        // save the new pen position
              return currAbs;
            },
            toCango3DVersion: function(acc, curr) {
              var x = curr[1],
                  y = acc.py,
                  z = 0,
                  cangoVer = ["L", x, y, z];

              acc.px = x;        // save the new pen position
              acc.push(cangoVer);
            },
            addXYoffset: function(curr, xOfs, yOfs){
              var x = curr[1];

              x += xOfs;
              return ["H", x];
            },
            invertCoords: function(curr){
              var x = curr[1];

              return ["H", x];
            }
          },
          "V": {
            parmCount: 1,
            extCmd: "V",
            toAbs: function(acc, curr) {
              var cmd = curr[0].toUpperCase(),   // uppercase command means absolute coords
                  y = curr[1],
                  currAbs;
              // Check if 'curr' was a relative (lowercase) command
              if (cmd !== curr[0]) {
                y += acc.py;
              }
              currAbs = [cmd, y];
              acc.py = y;        // save the new pen position
              return currAbs;
            },
            toCango3DVersion: function(acc, curr) {
              var x = acc.px,
                  y = curr[1],
                  z = 0,
                  cangoVer = ["L", x, y, z];

              acc.py = y;        // save the new pen position
              acc.push(cangoVer);
            },
            addXYoffset: function(curr, xOfs, yOfs){
              var y = curr[1];

              y += yOfs;
              return ["V", y];    // invert y coords to make Cgo2D format
            },
            invertCoords: function(curr){
              var y = curr[1];

              return ["V", -y];    // invert y coords to make Cgo2D format
            }
          },
          "C": {       // Cubic Bezier curve
            parmCount: 6,
            parmCount3D: 9,
            extCmd: "C",
            toAbs: function(acc, curr) {
              var cmd = curr[0].toUpperCase(),  // uppercase command means absolute coords
                  c1x = curr[1],
                  c1y = curr[2],
                  c2x = curr[3],
                  c2y = curr[4],
                  x = curr[5],
                  y = curr[6],
                  currAbs;
              // Check if 'curr' was a relative (lowercase) command
              if (cmd !== curr[0]) {
                c1x += acc.px;
                c1y += acc.py;
                c2x += acc.px;
                c2y += acc.py;
                x += acc.px;
                y += acc.py;
              }
              currAbs = [cmd, c1x, c1y, c2x, c2y, x, y];
              acc.px = x;
              acc.py = y;
              return currAbs;
            },
            toAbs3D: function(acc, curr) {
              var cmd = curr[0].toUpperCase(),  // uppercase command means absolute coords
                  c1x = curr[1],
                  c1y = curr[2],
                  c1z = curr[3],
                  c2x = curr[4],
                  c2y = curr[5],
                  c2z = curr[6],
                  x = curr[7],
                  y = curr[8],
                  z = curr[9],
                  currAbs;
              // Check if 'curr' was a relative (lowercase) command
              if (cmd !== curr[0]) {
                c1x += acc.px;
                c1y += acc.py;
                c1z += acc.pz;
                c2x += acc.px;
                c2y += acc.py;
                c2z += acc.pz;
                x += acc.px;
                y += acc.py;
                z += acc.pz;
              }
              currAbs = [cmd, c1x, c1y, c1z, c2x, c2y, c2z, x, y, z];
              acc.px = x;
              acc.py = y;
              acc.pz = z;
              return currAbs;
            },
            toCango3DVersion: function(acc, curr) {
              var cmd = curr[0],
                  c1x = curr[1],
                  c1y = curr[2],
                  c1z = 0,
                  c2x = curr[3],
                  c2y = curr[4],
                  c2z = 0,
                  x = curr[5],
                  y = curr[6],
                  z = 0;

              acc.px = x;  // update the pen position for next command
              acc.py = y;
              acc.push([cmd, c1x, c1y, c1z, c2x, c2y, c2z, x, y, z]); // push the curr, "C" is a Cango internal command
            },
            addXYoffset: function(curr, xOfs, yOfs){
              var c1x = curr[1],
                  c1y = curr[2],
                  c2x = curr[3],
                  c2y = curr[4],
                  x = curr[5],
                  y = curr[6];

                c1x += xOfs;
                c1y += yOfs;
                c2x += xOfs;
                c2y += yOfs;
                x += xOfs;
                y += yOfs;
              return ["C", c1x, c1y, c2x, c2y, x, y]; // invert y coords
            },
            invertCoords: function(curr){
              var c1x = curr[1],
                  c1y = curr[2],
                  c2x = curr[3],
                  c2y = curr[4],
                  x = curr[5],
                  y = curr[6];

              return ["C", c1x, -c1y, c2x, -c2y, x, -y]; // invert y coords
            },
            toDrawCmd: function(curr){
              var c1x = curr[1],
                  c1y = curr[2],
                  c1z = curr[3],
                  c2x = curr[4],
                  c2y = curr[5],
                  c2z = curr[6],
                  x = curr[7],
                  y = curr[8],
                  z = curr[9],
                  cp1 = new Point(c1x, c1y, c1z),
                  cp2 = new Point(c2x, c2y, c2z),
                  cPts = [cp1, cp2],
                  ep = new Point(x, y, z);

              return new DrawCmd3D('bezierCurveTo', cPts, ep);
            }
          },
          "S": {         // Smooth cubic Bezier curve
            parmCount: 4,
            extCmd: "S",
            toAbs: function(acc, curr) {
              var cmd = curr[0].toUpperCase(),  // uppercase means absolute coords
                  c2x = curr[1],
                  c2y = curr[2],
                  x = curr[3],
                  y = curr[4],
                  currAbs;

              // Check if 'curr' was a relative (lowercase) command
              if (cmd !== curr[0]) {
                c2x += acc.px;
                c2y += acc.py;
                x += acc.px;
                y += acc.py;
              }
              currAbs = [cmd, c2x, c2y, x, y];
              acc.px = x;
              acc.py = y;
              return currAbs;
            },
            toCango3DVersion: function(acc, curr, idx) {
              var c1x = 0,    // relative coords of first (mirrored) control point
                  c1y = 0,
                  c1z = 0,
                  c2x = curr[1],
                  c2y = curr[2],
                  c2z = 0,
                  x = curr[3],
                  y = curr[4],
                  z = 0,
                  prevSeg = acc[idx-1],
                  cangoVer;

              // if prev segment was a cubic Bezier, mirror its last control point as cp1
              if (prevSeg[0] === "C")              {
                c1x = acc.px - prevSeg[prevSeg.length-4];   // relative coords of cp1
                c1y = acc.py - prevSeg[prevSeg.length-3];
              }
              // make cp1 absolute (all the curr coords are already absolute)
              c1x += acc.px;
              c1y += acc.py;
              cangoVer = ["C", c1x, c1y, c1z, c2x, c2y, c2z, x, y, z];  // Cubic Bezier
              acc.px = x;  // update the pen position for next command
              acc.py = y;
              acc.push(cangoVer);
            },
            addXYoffset: function(curr, xOfs, yOfs){
              var c2x = curr[1],
                  c2y = curr[2],
                  x = curr[3],
                  y = curr[4];

              c2x += xOfs;
              c2y += yOfs;
              x += xOfs;
              y += yOfs;
              return ["S", c2x, c2y, x, y];    // invert y coords to make Cgo2D format
            },
            invertCoords: function(curr){
              var c2x = curr[1],
                  c2y = curr[2],
                  x = curr[3],
                  y = curr[4];

              return ["S", c2x, -c2y, x, -y];    // invert y coords to make Cgo2D format
            }
          },
          "Q": {         // Quadratic Bezier curve
            parmCount: 4,
            parmCount3D: 6,
            extCmd: "Q",
            toAbs: function(acc, curr) {
              var cmd = curr[0].toUpperCase(),  // uppercase command means absolute coords
                  c1x = curr[1],
                  c1y = curr[2],
                  x = curr[3],
                  y = curr[4],
                  currAbs;
              // Check if 'curr' was a relative (lowercase) command
              if (cmd !== curr[0]) {
                c1x += acc.px;
                c1y += acc.py;
                x += acc.px;
                y += acc.py;
              }
              currAbs = [cmd, c1x, c1y, x, y];
              acc.px = x;
              acc.py = y;
              return currAbs;
            },
            toAbs3D: function(acc, curr) {
              var cmd = curr[0].toUpperCase(),  // uppercase command means absolute coords
                  c1x = curr[1],
                  c1y = curr[2],
                  c1z = curr[3],
                  x = curr[4],
                  y = curr[5],
                  z = curr[6],
                  currAbs;
              // Check if 'curr' was a relative (lowercase) command
              if (cmd !== curr[0]) {
                c1x += acc.px;
                c1y += acc.py;
                c1z += acc.pz;
                x += acc.px;
                y += acc.py;
                z += acc.pz;
              }
              currAbs = [cmd, c1x, c1y, c1z, x, y, z];
              acc.px = x;
              acc.py = y;
              acc.pz = z;
              return currAbs;
            },
            toCango3DVersion: function(acc, curr) {
              var cmd = curr[0],
                  c1x = curr[1],
                  c1y = curr[2],
                  c1z = 0,
                  x = curr[3],
                  y = curr[4],
                  z = 0;

              acc.px = x;  // update the pen position for next command
              acc.py = y;
              acc.push([cmd, c1x, c1y, c1z, x, y, z]); // push the curr, "Q" is a Cango internal command
            },
            addXYoffset: function(curr, xOfs, yOfs){
              var c1x = curr[1],
                  c1y = curr[2],
                  x = curr[3],
                  y = curr[4];

              c1x += xOfs;
              c1y += yOfs;
              x += xOfs;
              y += yOfs;
              return ["Q", c1x, c1y, x, y];    // invert y coords to make Cgo2D format
            },
            invertCoords: function(curr){
              var c1x = curr[1],
                  c1y = curr[2],
                  x = curr[3],
                  y = curr[4];

              return ["Q", c1x, -c1y, x, -y];    // invert y coords to make Cgo2D format
            },
            toDrawCmd: function(curr){
              var c1x = curr[1],
                  c1y = curr[2],
                  c1z = curr[3],
                  x = curr[4],
                  y = curr[5],
                  z = curr[6],
                  cp1 = new Point(c1x, c1y, c1z),
                  cPts = [cp1],
                  ep = new Point(x, y, z);

              return new DrawCmd3D('quadraticCurveTo', cPts, ep);
            }
          },
          "T": {         // Smooth Quadratic Bezier curve
            parmCount: 2,
            extCmd: "T",
            toAbs: function(acc, curr) {
              var cmd = curr[0].toUpperCase(),  // uppercase means absolute coords
                  x = curr[1],
                  y = curr[2],
                  currAbs;

              // Check if 'curr' was a relative (lowercase) command
              if (cmd !== curr[0]) {
                x += acc.px;
                y += acc.py;
              }
              currAbs = [cmd, x, y];
              acc.px = x;
              acc.py = y;
              return currAbs;
            },
            toCango3DVersion: function(acc, curr, idx) {
              var c1x = 0,    // relative coords of first (mirrored) control point
                  c1y = 0,
                  c1z = 0,
                  x = curr[1],
                  y = curr[2],
                  z = 0,
                  prevSeg = acc[idx-1],
                  cangoVer;

              // if prev segment was quadratic Bezier, mirror its last control point as cp1
              if (prevSeg[0] === "Q")            {
                c1x = acc.px - prevSeg[prevSeg.length-4];   // relative coords of first cp1
                c1y = acc.py - prevSeg[prevSeg.length-3];
              }
              // make cp1 absolute
              c1x += acc.px;
              c1y += acc.py;
              cangoVer = ["Q", c1x, c1y, c1z, x, y, z];   // Quadratic Bezier
              acc.px = x;  // update the pen position for next command
              acc.py = y;
              acc.push(cangoVer);
            },
            addXYoffset: function(curr, xOfs, yOfs){
              var x = curr[1],
                  y = curr[2];

              x += xOfs;
              y += yOfs;
              return ["T", x, y];    // invert y coords to make Cgo2D format
            },
            invertCoords: function(curr){
              var x = curr[1],
                  y = curr[2];

              return ["T", x, -y];    // invert y coords to make Cgo2D format
            }
          },
          "A" : {      // Circular arc
            parmCount: 7,
            extCmd: "A",
            toAbs: function(acc, curr) {
              var cmd = curr[0].toUpperCase(),
                  rx = curr[1],
                  ry = curr[2],
                  xrot = curr[3],     // opposite to SVG in Cartesian coords
                  lrg = curr[4],
                  swp = curr[5],      // opposite to SVG in Cartesian coords
                  x = curr[6],
                  y = curr[7],
                  currAbs;
              // Check if current is a relative (lowercase) command
              if (cmd !== curr[0]) {
                x += acc.px;
                y += acc.py;
              }
              currAbs = [cmd, rx, ry, xrot, lrg, swp, x, y];
              acc.px = x;
              acc.py = y;
              return currAbs;
            },
            toCango3DVersion: function(acc, curr) {
              var rx = curr[1],
                  ry = curr[2],
                  xrot = curr[3],     // opposite to SVG in Cartesian coords
                  lrg = curr[4],
                  swp = curr[5],      // opposite to SVG in Cartesian coords
                  x = curr[6],
                  y = curr[7],
                  sectors;

              // convert to (maybe multiple) cubic Bezier curves and add the z=0 coords
              sectors = arcToBezier(acc.px, acc.py, rx, ry, xrot, lrg, swp, x, y);
              // sectors is an array of arrays of Cubic Bezier coords,
              // make a 'C' command from each sector and push it out
              sectors.forEach(function(coordAry){
                acc.push(["C"].concat(coordAry));
              });

              acc.px = x;  // update the pen position for next command
              acc.py = y;
            },
            addXYoffset: function(curr, xOfs, yOfs){
              var rx = curr[1],
                  ry = curr[2],
                  xrot = curr[3],
                  lrg = curr[4],
                  swp = curr[5],
                  x = curr[6],
                  y = curr[7];

              x += xOfs;
              y += yOfs;
              return ["A", rx, ry, xrot, lrg, swp, x, y];  // invert y coords
            },
            invertCoords: function(curr){
              var rx = curr[1],
                  ry = curr[2],
                  xrot = curr[3],
                  lrg = curr[4],
                  swp = curr[5],
                  x = curr[6],
                  y = curr[7];

              return ["A", rx, ry, -xrot, lrg, 1-swp, x, -y];  // invert coords
            }
          },
          "Z": {
            parmCount: 0,
            parmCount3D: 0,
            toAbs: function(acc, curr) {
              var cmd = curr[0].toUpperCase(),
                  currAbs = [cmd];
              // leave pen position where it is in case of multi-segment path
              return currAbs;
            },
            toAbs3D: function(acc, curr) {
              var cmd = curr[0].toUpperCase(),
                  currAbs = [cmd];
              // leave pen position where it is in case of multi-segment path
              return currAbs;
            },
            toCango3DVersion: function(acc, curr) {
              // leave pen position where it is in case of multi-segment path
              acc.push(curr); // push the curr, "Z", its a Cango internal command
            },
            addXYoffset: function(curr, xOfs, yOfs){
              return ["Z"];
            },
            invertCoords: function(curr){
              return ["Z"];
            },
            toDrawCmd: function(curr){
              return new DrawCmd3D("closePath");
            }
          }
        };
    // ========= end of vars =========

    /*==================================================
     * svgCmdCheck (a function for use with Array.reduce)
     * -------------------------------------------------
     * Checks each element, if a string it must be
     * one of the keys in the SVG protocol. If no bad
     * cmds found then the array is returned without
     * alteration, if not an empty array is returned.
     *=================================================*/
    function svgCmdCheck(acc, current, idx)
    {
      // make a concession to SVG standard and allow all number array
      if (idx === 0)
      {
        if (typeof current !== 'string')
        {
          acc.push("M");
          // now we will fall through to normal checking
        }
      }
      // if we see a command string, check it is in SVG protocol
      if (typeof current === "string") {  // check each string element
        if (!svgProtocol.hasOwnProperty(current.toUpperCase()))
        {
          console.log("unknown command string '"+current+"'");
          acc.badCmdFound = true;
          acc.length = 0;   // any bad command will force empty array to be returned
        }
      }
      if (!acc.badCmdFound)
      {
        acc.push(current);
      }
      // always return when using reduce...
      return acc;
    }

    /*==================================================
     * Cgo3DCmdCheck (a function for use with Array.reduce)
     * -------------------------------------------------
     * Checks each array element, if its a string it must be
     * one of the cmd letters in the Cgo3D protocol. If no bad
     * cmds found then the array is returned without
     * alteration, if not an empty array is returned.
     *=================================================*/
    function Cgo3DCmdCheck(acc, current, idx)
    {
      var cgo3Dcmds = ["M", "L", "C", "Q", "Z"];

      // make a concession to SVG standard and allow all number array
      if (idx === 0)
      {
        if (typeof current !== 'string')
        {
          acc.push("M");
          // now we will fall through to normal checking
        }
      }
      // if we see a command string, check it is in SVG protocol
      if (typeof current === "string") {  // check each string element
        if (cgo3Dcmds.indexOf(current.toUpperCase()) === -1)
        {
          console.log("unknown command string '"+current+"'");
          acc.badCmdFound = true;
          acc.length = 0;   // any bad command will force empty array to be returned
        }
      }
      if (!acc.badCmdFound)
      {
        acc.push(current);
      }
      // always return when using reduce...
      return acc;
    }

    /*======================================================
     * unExtend  (a function for use with Array.reduce)
     * -----------------------------------------------------
     * Undo the extension of commands allowed in the svg protocol.
     * Each entry in the protocol has an extCmd property which
     * is usually the same as the command key but for "M"
     * which may be extended by a series of "L" commands.
     * Extending a command means that multiple sets of paramaeters
     * may follow a command letter without the need to repeat
     * the command letter in front of each set eg.
     * var a = ['M', 1, 2, 'L', 3, 4, 5, 6, 7, 8, 'A', 5, 6, 7, 8, 3, 0, 2]
     * var b = a.reduce(unExtend, [])
     * &gt;&gt; ['M', 1, 2, 'L', 3, 4, 'L', 5, 6, 'L', 7, 8, 'A', 5, 6, 7, 8, 3, 0, 2]
     *
     * The 'reduce' accumulator is used to hold the current
     * command as a property (not an array element) and make it
     * available to the next element.
     *
     * This assumes no invalid commands are in the string -
     * so array should be sanitized before running unExtend
     *======================================================*/
    function unExtend(acc, current, idx, ary)
    {
      var newCmd;

      if (idx === 0)
      {
        acc.nextCmdPos = 0;  // set expected position of next command string as first element
      }
      // Check if current is a command in the protocol (protocol only indexed by upperCase)
      if (typeof current === 'string')
      {
        if (idx &lt; acc.nextCmdPos)
        {
          // we need another number but found a string
          console.log("bad number of parameters for '"+current+"' at index "+idx);
          acc.badParameter = true;  // raise flag to bailout processing this
          acc.push(0);  // try to get out without crashing (acc data will be ditched any way)
          return acc;
        }
        // its a command the protocol knows, remember it across iterations of elements
        acc.currCmd = current.toUpperCase();  // save as a property of the acc Array object (not an Array element)
        acc.uc = (current.toUpperCase() === current);  // upperCase? true or false
        // calculate where the next command should be
        acc.nextCmdPos = idx + svgProtocol[acc.currCmd].parmCount + 1;
        acc.push(current);
      }
      else if (idx &lt; acc.nextCmdPos)   // processing parameters
      {
        // keep shoving parameters
        acc.push(current);
      }
      else
      {
        // we have got a full set of parameters but hit another number
        // instead of a command string, it must be a command extension
        // push a the extension command (same as current except for M which extend to L)
        // into the accumulator
        acc.currCmd = svgProtocol[acc.currCmd].extCmd;  // NB: don't change the acc.uc boolean
        newCmd = (acc.uc)? acc.currCmd: acc.currCmd.toLowerCase();
        acc.push(newCmd, current);
        // calculate where the next command should be
        acc.nextCmdPos = idx + svgProtocol[acc.currCmd].parmCount;
      }

      if (idx === ary.length-1)   // done processing check if all was ok
      {
        if (acc.badParameter)
        {
          acc.length = 0;
        }
      }
      // always return when using reduce...
      return acc;
    }

    /*=================================================================
     * unExtend3D  (a function for use with Array.reduce)
     * ----------------------------------------------------------------
     * Undo the extension of commands given the svg protocol.
     * see description of 'unExtend above.
     * This version expects 3D coordinates eg.
     *
     * var a = ['M', 1, 2, 0, 'L', 3, 4, 0, 5, 6, 0, 7, 8, 0, 'Z']
     * var b = a.reduce(unExtend3D, [])
     *
     * &gt;&gt; ['M', 1, 2, 0, 'L', 3, 4, 0, 'L', 5, 6, 0, 'L', 7, 8, 0, 'Z']
     *
     * This assumes no invalid commands are in the string -
     * so array should be sanitized before running unExtend3D
     *=================================================================*/
    function unExtend3D(acc, current, idx, ary)
    {
      var newCmd;

      if (idx === 0)
      {
        acc.nextCmdPos = 0;  // set expected position of next command string as first element
      }
      // Check if current is a command in the protocol (protocol only indexed by upperCase)
      if (typeof current === 'string')
      {
        if (idx &lt; acc.nextCmdPos)
        {
          // we need another number but found a string
          console.log("bad number of parameters for '"+current+"' at index "+idx);
          acc.badParameter = true;  // raise flag to bailout processing this
          acc.push(0);  // try to get out without crashing (acc data will be ditched any way)
          return acc;
        }
        // its a command the protocol knows, remember it across iterations of elements
        acc.currCmd = current.toUpperCase();  // save as a property of the acc Array object (not an Array element)
        acc.uc = (current.toUpperCase() === current);  // upperCase? true or false
        // calculate where the next command should be
        acc.nextCmdPos = idx + svgProtocol[acc.currCmd].parmCount3D + 1;
        acc.push(current);
      }
      else if (idx &lt; acc.nextCmdPos)   // processing parameters
      {
        // keep shoving parameters
        acc.push(current);
      }
      else
      {
        // we have got a full set of parameters but hit another number
        // instead of a command string, it must be a command extension
        // push a the extension command (same as current except for M which extend to L)
        // into the accumulator
        acc.currCmd = svgProtocol[acc.currCmd].extCmd;  // NB: don't change the acc.uc boolean
        newCmd = (acc.uc)? acc.currCmd: acc.currCmd.toLowerCase();
        acc.push(newCmd, current);
        // calculate where the next command should be
        acc.nextCmdPos = idx + svgProtocol[acc.currCmd].parmCount3D;
      }

      if (idx === ary.length-1)   // done processing check if all was ok
      {
        if (acc.badParameter)
        {
          acc.length = 0;
        }
      }
      // always return when using reduce...
      return acc;
    }

    /*=======================================================
     * svgCmdSplitter (a function for use with Array.reduce)
     * ------------------------------------------------------
     * Split an array on a string type element, e.g.
     *
     * var a = ['a', 1, 2, 'b', 3, 4, 'c', 5, 6, 7, 8]
     * var b = a.reduce(svgCmdSplitter, [])
     *
     * &gt;&gt; [['a', 1, 2],['b', 3, 4], ['c', 5, 6, 7, 8]]
     *
     *======================================================*/
    function svgCmdSplitter(acc, curr)
    {
      // if we see a command string, start a new array element
      if (typeof curr === "string") {
          acc.push([]);
      }
      // add this element to the back of the acc's last array
      acc[acc.length-1].push(curr);
      // always return when using reduce...
      return acc;
    }

    /*===========================================================
     * toAbsoluteCoords  (a function for use with Array.reduce)
     * ----------------------------------------------------------
     * Reduce is needed even though the same size elements are
     * returned because the accumulator is used to hold the pen
     * x,y coords and make them available to the next element.
     * Assumes 'current' argument is an array of form ["M", 2, 7]
     * if command letter is lower case the protocol.toAbs
     * function will add the current pen x and y values to
     * the coordinates and update the pen x, y. The
     * absolute coord version of the cmd and its coords will
     * be returned and then pushed into acc.
     *
     * eg. ['M', 1, 2, 'l', 3, 4, 'a', 5, 6, 7, 8, 3, 0, 2, 'z']
     * &gt;&gt;  ['M', 1, 2, 'L', 4, 6, 'A', 5, 6, 7, 8, 3, 4, 8, 'Z']
     *===========================================================*/
    function toAbsoluteCoords(acc, current, idx)
    {
      var currCmd, currAbs;

      if (acc.px === undefined)
      {
        acc.px = 0;
        acc.py = 0;
      }
      // get protocol object for this command, indexed by uppercase only
      currCmd = svgProtocol[current[0].toUpperCase()];
      // call protocol toAbs function for this command
      // it returns absolute coordinate version based on current
      // pen position stored in acc.px, acc.py
      currAbs = currCmd.toAbs(acc, current, idx);
      acc.push(currAbs);
      // always return when using reduce...
      return acc;
    }

    /*====================================================================
     * toAbsoluteCoords3D  (a function for use with Array.reduce)
     * -------------------------------------------------------------------
     * Version of the toAbsoluteCoords but expecting 3D coordinates
     * eg. ['M', 1, 2, 0, 'l', 3, 4, 1, 'm', 5, 6, 7, 'l', 8, 3, 0, 'z']
     * &gt;&gt;  ['M', 1, 2, 0, 'L', 4, 6, 1, 'M', 5, 6, 7, 'L', 13, 9, 7, 'Z']
     *====================================================================*/
    function toAbsoluteCoords3D(acc, current, idx)
    {
      var currCmd, currAbs;

      if (acc.px === undefined)
      {
        acc.px = 0;
        acc.py = 0;
        acc.pz = 0;
      }
      // get protocol object for this command, indexed by uppercase only
      currCmd = svgProtocol[current[0].toUpperCase()];
      // call protocol toAbs3D function for this command
      // it returns absolute coordinate version based on current
      // pen position stored in acc.px, acc.py, acc.pz
      currAbs = currCmd.toAbs3D(acc, current, idx);
      acc.push(currAbs);
      // always return when using reduce...
      return acc;
    }

    /*=================================================================================================
     * toCango3DCmdSet  (a function for use with Array.reduce)
     * ------------------------------------------------------------------------------------------------
     * Assumes 'current' argument is an array with one Cgo2D command in format ["M", 2, 7]
     * All commands letters are uppercase and all coordinates are absolute (referenced to world
     * coordinate origin).
     * This function will convert "H", "V", "S", "T", and "A"
     * commands to Cango internal command set "M", "L", "Q", "C", "Z"
     * All coordinates will be returned in separate array
     *
     * eg. [['M', 1, 2], ['L', 3, 4], ['H', 3], ['A', 5, 6, 7, 8, 3, 0, 2], ['Z']]
     * &gt;&gt;  [['M', 1, 2, 0], ['L', 3, 4, 0], ['L', 3, 4, 0], ['C', cp, cp, 0, cp, cp, 0, x, y, ], ['Z']]
     *=================================================================================================*/
    function toCango3DCmdSet(acc, current, idx)
    {
      var currSvgObj = svgProtocol[current[0].toUpperCase()];
      // call protocol toCango3DVersion function for this command
      // it converts all SVG to just "M", "L", "Q", "C", "Z" command and coords
      // adds a z=0 coord and pushes them into the acc
      currSvgObj.toCango3DVersion(acc, current, idx);
      // always return when using reduce...
      return acc;
    }

    /*===============================================================================
     * toDrawCmds3D  (a function for use with Array.reduce)
     * ------------------------------------------------------------------------------
     * Convert a Cgo3D data array to an array
     * of Cango DrawCmd objects e.g.
     *
     * [['M', 0.1, 0.2, 0], ['L', 1, 2, 0], ['C', 3, 4, 5, 6, 2, 9, 0, 1, 2], ['Z']]
     *
     * will become
     * [{ drawFn: "moveTo",
     *    cPts: [cp1, cp2],   // cp1, cp2 are Point objects
     *    ep: eP              // Point object
     *  },
     *  { drawFn: "lineTo",
     *    cPts: [cp1, cp2],
     *    ep: eP
     *  },
     *  ...
     *  ]
     *
     *===============================================================================*/
    function toDrawCmd3D(acc, current)
    {
      // call protocol toDrawCmd function for this command
      // it returns a DrawCmd3D object made from the current cmd and parms
      var currCmd = svgProtocol[current[0].toUpperCase()],
          currDC = currCmd.toDrawCmd(current);

      if (currDC !== null)
      {
        acc.push(currDC);
      }
      // always return when using reduce...
      return acc;
    }

    /*==================================================
     * strToCgo2D (a function for use with Array.reduce)
     * -------------------------------------------------
     * Assumes 'current' argument is a string of form
     * "M  2 7" or "v 7  " or "z" which always has a
     * command string as the first character
     * and the rest is numbers separated by white space
     * This function will reduce (combine) to a single
     * array in Cgo2D format ["M", 2, 7, "v", 7, "z"]
     *=================================================*/
    function strToCgo2D(acc, current)
    {
      var cmd = current[0],
          parmsStr, numberStrs;

      // push the single char command as an element
      acc.push(cmd);
      // strip off the front cmd
      parmsStr = current.slice(1);
      // convert to an array of strings, each one a number
      numberStrs = parmsStr.match(/\S+/g);   // returns null if no matches (not empty array)
      if (numberStrs)      // z has no numbers to follow
      {
        // parse each to a float and push it into acc
        numberStrs.forEach(function(s){
          var num = parseFloat(s);
          if (!isNaN(num))
          {
            acc.push(num);
          }
        });
      }
      // always return when using reduce...
      return acc;
    }

    /*===========================================================
     * flipCoords  (a function for use with Array.map)
     * ----------------------------------------------------------
     * Assumes 'current' argument is an array of form ["M", 2, 7]
     * All coordinates will be be in absolute format
     * The protocol will have an 'invertCoords' method for each
     * possible command key this will return the current array
     * with the sign of the Y coords flipped and sense of arcs
     * reversed
     *
     * current = ['A', 2, 2,  30, 0, 1, 3,  4]
     *       &gt;&gt;  ['A', 2, 2, -30, 0, 0, 3, -4]
     *===========================================================*/
    function flipCoords(current)
    {
      var currCmd = current[0],
          currSvgObj = svgProtocol[currCmd];

      // call protocol.invertCoords function for this command
      // it flips the sign of the y coords, for 'A' commands it flips
      // sweep and xRotation values and returns the modified array
      return currSvgObj.invertCoords(current);
    }

    /*===========================================================
     * translateOrigin  (a function for use with Array.map)
     * ----------------------------------------------------------
     * Assumes it is called with 'this' object having
     * properties {xOfs: value, yOfs: value}
     * Assumes 'current' argument is an array of form ["M", 2, 7]
     * All coordinates will be be in absolute format
     * The protocol will have an 'addXYoffset method for each
     * possible command key this will return the current array
     * with the X and Y offsets added to the coordinate elements.
     *
     * eg. if 'this = {xOfs: 100, yOfs: 10}
     * current = ['M', 1, 2]
     * &gt;&gt;  ['M', 101, 12]
     *===========================================================*/
    function translateOrigin(current)
    {
      var currCmd = current[0],
          currSvgObj = svgProtocol[currCmd],
          xofs = this.xOfs || 0,
          yofs = this.yOfs || 0;

      return currSvgObj.addXYoffset(current, xofs, yofs);
    }

    /*===========================================================
     * flatten2Dary  (a function for use with Array.reduce)
     * ----------------------------------------------------------
     * Assumes curr is an array, push each element into the acc
     * to form a 1D array.

     * eg. [[a, b, c], [d, e],[f]]
     * &gt;&gt;  [a, b, c, d, e, f]
     *===========================================================*/
    function flatten2Dary(acc, curr){
      return acc.concat(curr);
    }

    // auto run this code to create this object holding the two translator fns
    // and return it as the svgParser
    return {
      svg2cgo3D: function(data2D, xShft, yShft) {
        // svgtoCgo3D can handle an SVG format string or a Cgo2D array
        var dx = xShft || 0,
            dy = yShft || 0,
            noCommas,
            cmdStrs;

        if (typeof data2D === 'string')
        {
          // this SVG processor can handle comma separated or whitespace separated or mixed
          // replace any commas with spaces
          noCommas = data2D.replace(new RegExp(',', 'g'), ' ');
          // now we have a string of commands and numbers separated by whitespace
          // split it at command chars
          cmdStrs = noCommas.split(/(?=[a-df-z])/i);  // avoid e in exponents
          // now convert to Cgo3D format
          return cmdStrs.reduce(strToCgo2D, [])
                        .reduce(svgCmdCheck, [])
                        .reduce(unExtend, [])
                        .reduce(svgCmdSplitter, [])
                        .reduce(toAbsoluteCoords, [])
                        .map(translateOrigin, {xOfs: dx, yOfs: dy})
                        .map(flipCoords)
                        .reduce(toCango3DCmdSet, [])   // to 3D coords
                        .reduce(flatten2Dary, []);     // return valid Cgo3D array
        }
        else if (!isArray(data2D))
        {
          return [];
        }
        else  // treat this as a cgo2D array
        {
          return data2D.reduce(svgCmdCheck, [])
                       .reduce(unExtend, [])
                       .reduce(svgCmdSplitter, [])
                       .reduce(toAbsoluteCoords, [])
                       .reduce(toCango3DCmdSet, [])      // to 3D coords
                       .reduce(flatten2Dary, []);        // return valid Cgo3D array
        }
      },
      cgo3DtoDrawcmd: function(cgo3Dary) {
        if (!isArray(cgo3Dary) || (cgo3Dary.length === 0))
        {
          return [];
        }

        return cgo3Dary.reduce(Cgo3DCmdCheck, [])
                       .reduce(unExtend3D, [])
                       .reduce(svgCmdSplitter, [])
                       .reduce(toAbsoluteCoords3D, [])
                       .reduce(toDrawCmd3D, []);
      }
    };

  }());

  if (shapes3D === undefined)
  {
    shapes3D = {'circle': function(diameter){
                            var d = diameter || 1;
                            return ["m", -0.5*d,0,0,
                            "c", 0,-0.27614*d,0, 0.22386*d,-0.5*d,0, 0.5*d,-0.5*d,0,
                            "c", 0.27614*d,0,0, 0.5*d,0.22386*d,0, 0.5*d,0.5*d,0,
                            "c", 0,0.27614*d,0, -0.22386*d,0.5*d,0, -0.5*d,0.5*d,0,
                            "c", -0.27614*d,0,0, -0.5*d,-0.22386*d,0, -0.5*d,-0.5*d,0];},

                'ellipse': function(width, height){
                            var w = width || 1,
                                h = w;
                            if ((typeof height === 'number')&amp;&amp;(height&gt;0))
                            {
                              h = height;
                            }
                            return ["m", -0.5*w,0,0,
                            "c", 0,-0.27614*h,0, 0.22386*w,-0.5*h,0, 0.5*w,-0.5*h,0,
                            "c", 0.27614*w,0,0, 0.5*w,0.22386*h,0, 0.5*w,0.5*h,0,
                            "c", 0,0.27614*h,0, -0.22386*w,0.5*h,0, -0.5*w,0.5*h,0,
                            "c", -0.27614*w,0,0, -0.5*w,-0.22386*h,0, -0.5*w,-0.5*h,0];},

                'square': function(width){
                            var w = width || 1;
                            return ['m', 0.5*w,-0.5*w,0, 'l',0,w,0, -w,0,0, 0,-w,0, 'z'];},

                'triangle': function(side){
                            var s = side || 1;
                            return ['m',0.5*s,-0.289*s,0, 'l',-0.5*s,0.866*s,0, -0.5*s,-0.866*s,0, 'z'];},

                'cross': function(width){
                            var w = width || 1;
                            return ['m',-0.5*w,0,0, 'l',w,0,0, 'm',-0.5*w,-0.5*w,0, 'l',0,w,0];},

                'ex': function(diagonal){
                            var d = diagonal || 1;
                            return ['m',-0.3535*d,-0.3535*d,0, 'l',0.707*d,0.707*d,0,
                                    'm',-0.707*d,0,0, 'l',0.707*d,-0.707*d,0];}
                };
  }

  /**
   * A class to parse color values
   * @author Stoyan Stefanov &lt;sstoo@gmail.com&gt;
   * @link   http://www.phpied.com/rgb-color-parser-in-javascript/
   * @license Use it if you like it
   *
   * supplemented to handle rgba format (alpha 0 .. 1.0)  by arc 04SEP09
   */
  function RGBAColor(color_string)
  {
    var simple_colors = {
        aliceblue: 'f0f8ff',
        antiquewhite: 'faebd7',
        aqua: '00ffff',
        aquamarine: '7fffd4',
        azure: 'f0ffff',
        beige: 'f5f5dc',
        bisque: 'ffe4c4',
        black: '000000',
        blanchedalmond: 'ffebcd',
        blue: '0000ff',
        blueviolet: '8a2be2',
        brown: 'a52a2a',
        burlywood: 'deb887',
        cadetblue: '5f9ea0',
        chartreuse: '7fff00',
        chocolate: 'd2691e',
        coral: 'ff7f50',
        cornflowerblue: '6495ed',
        cornsilk: 'fff8dc',
        crimson: 'dc143c',
        cyan: '00ffff',
        darkblue: '00008b',
        darkcyan: '008b8b',
        darkgoldenrod: 'b8860b',
        darkgray: 'a9a9a9',
        darkgreen: '006400',
        darkkhaki: 'bdb76b',
        darkmagenta: '8b008b',
        darkolivegreen: '556b2f',
        darkorange: 'ff8c00',
        darkorchid: '9932cc',
        darkred: '8b0000',
        darksalmon: 'e9967a',
        darkseagreen: '8fbc8f',
        darkslateblue: '483d8b',
        darkslategray: '2f4f4f',
        darkturquoise: '00ced1',
        darkviolet: '9400d3',
        deeppink: 'ff1493',
        deepskyblue: '00bfff',
        dimgray: '696969',
        dodgerblue: '1e90ff',
        feldspar: 'd19275',
        firebrick: 'b22222',
        floralwhite: 'fffaf0',
        forestgreen: '228b22',
        fuchsia: 'ff00ff',
        gainsboro: 'dcdcdc',
        ghostwhite: 'f8f8ff',
        gold: 'ffd700',
        goldenrod: 'daa520',
        gray: '808080',
        green: '008000',
        greenyellow: 'adff2f',
        honeydew: 'f0fff0',
        hotpink: 'ff69b4',
        indianred : 'cd5c5c',
        indigo : '4b0082',
        ivory: 'fffff0',
        khaki: 'f0e68c',
        lavender: 'e6e6fa',
        lavenderblush: 'fff0f5',
        lawngreen: '7cfc00',
        lemonchiffon: 'fffacd',
        lightblue: 'add8e6',
        lightcoral: 'f08080',
        lightcyan: 'e0ffff',
        lightgoldenrodyellow: 'fafad2',
        lightgrey: 'd3d3d3',
        lightgreen: '90ee90',
        lightpink: 'ffb6c1',
        lightsalmon: 'ffa07a',
        lightseagreen: '20b2aa',
        lightskyblue: '87cefa',
        lightslateblue: '8470ff',
        lightslategray: '778899',
        lightsteelblue: 'b0c4de',
        lightyellow: 'ffffe0',
        lime: '00ff00',
        limegreen: '32cd32',
        linen: 'faf0e6',
        magenta: 'ff00ff',
        maroon: '800000',
        mediumaquamarine: '66cdaa',
        mediumblue: '0000cd',
        mediumorchid: 'ba55d3',
        mediumpurple: '9370d8',
        mediumseagreen: '3cb371',
        mediumslateblue: '7b68ee',
        mediumspringgreen: '00fa9a',
        mediumturquoise: '48d1cc',
        mediumvioletred: 'c71585',
        midnightblue: '191970',
        mintcream: 'f5fffa',
        mistyrose: 'ffe4e1',
        moccasin: 'ffe4b5',
        navajowhite: 'ffdead',
        navy: '000080',
        oldlace: 'fdf5e6',
        olive: '808000',
        olivedrab: '6b8e23',
        orange: 'ffa500',
        orangered: 'ff4500',
        orchid: 'da70d6',
        palegoldenrod: 'eee8aa',
        palegreen: '98fb98',
        paleturquoise: 'afeeee',
        palevioletred: 'd87093',
        papayawhip: 'ffefd5',
        peachpuff: 'ffdab9',
        peru: 'cd853f',
        pink: 'ffc0cb',
        plum: 'dda0dd',
        powderblue: 'b0e0e6',
        purple: '800080',
        red: 'ff0000',
        rosybrown: 'bc8f8f',
        royalblue: '4169e1',
        saddlebrown: '8b4513',
        salmon: 'fa8072',
        sandybrown: 'f4a460',
        seagreen: '2e8b57',
        seashell: 'fff5ee',
        sienna: 'a0522d',
        silver: 'c0c0c0',
        skyblue: '87ceeb',
        slateblue: '6a5acd',
        slategray: '708090',
        snow: 'fffafa',
        springgreen: '00ff7f',
        steelblue: '4682b4',
        tan: 'd2b48c',
        teal: '008080',
        thistle: 'd8bfd8',
        tomato: 'ff6347',
        transparent: 'rgba(0,0,0,0)',
        turquoise: '40e0d0',
        violet: 'ee82ee',
        violetred: 'd02090',
        wheat: 'f5deb3',
        white: 'ffffff',
        whitesmoke: 'f5f5f5',
        yellow: 'ffff00',
        yellowgreen: '9acd32'
    };
    // array of color definition objects
    var color_defs = [
      {
        re: /^rgba\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3}),\s*((1(\.0)?)|0?(\.\d*)?)\)$/,
        example: ['rgba(123, 234, 45, 0.5)', 'rgba(255,234,245,1)'],
        process: function (bits){
            return [
                parseInt(bits[1], 10),
                parseInt(bits[2], 10),
                parseInt(bits[3], 10),
                parseFloat(bits[4], 10)
            ];
        }
      },
      {
        re: /^rgb\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3})\)$/,
        example: ['rgb(123, 234, 45)', 'rgb(255,234,245)'],
        process: function (bits){
            return [
                parseInt(bits[1], 10),
                parseInt(bits[2], 10),
                parseInt(bits[3], 10)
            ];
        }
      },
      {
        re: /^(\w{2})(\w{2})(\w{2})$/,
        example: ['#00ff00', '336699'],
        process: function (bits){
            return [
                parseInt(bits[1], 16),
                parseInt(bits[2], 16),
                parseInt(bits[3], 16)
            ];
        }
      },
      {
        re: /^(\w{1})(\w{1})(\w{1})$/,
        example: ['#fb0', 'f0f'],
        process: function (bits){
            return [
                parseInt(bits[1] + bits[1], 16),
                parseInt(bits[2] + bits[2], 16),
                parseInt(bits[3] + bits[3], 16)
            ];
        }
      }
    ];

    var i,
        re,
        processor,
        bits,
        channels,
        key;

    this.ok = false;
    if (typeof color_string !== "string")       // bugfix: crashed if passed a number
    {
      return;
    }
    // strip any leading #
    if (color_string.charAt(0) === '#')
    { // remove # if any
      color_string = color_string.substr(1,6);
    }

    color_string = color_string.replace(/ /g,'');
    color_string = color_string.toLowerCase();

    // before getting into regexps, try simple matches
    // and overwrite the input
    for (key in simple_colors)
    {
      if (color_string === key)
      {
        color_string = simple_colors[key];
      }
    }

    // search through the definitions to find a match
    for (i=0; i&lt;color_defs.length; i++)
    {
      re = color_defs[i].re;
      processor = color_defs[i].process;
      bits = re.exec(color_string);
      if (bits)
      {
        channels = processor(bits);    // bugfix: was global. [ARC 17Jul12]
        this.r = channels[0];
        this.g = channels[1];
        this.b = channels[2];
        if (bits.length&gt;3)
        {
          this.a = channels[3];
        }
        else
        {
          this.a = 1.0;
        }
        this.ok = true;
      }
    }

    // validate/cleanup values
    this.r = (this.r &lt; 0 || isNaN(this.r)) ? 0 : ((this.r &gt; 255) ? 255 : this.r);
    this.g = (this.g &lt; 0 || isNaN(this.g)) ? 0 : ((this.g &gt; 255) ? 255 : this.g);
    this.b = (this.b &lt; 0 || isNaN(this.b)) ? 0 : ((this.b &gt; 255) ? 255 : this.b);
    this.a = (this.a &lt; 0 || isNaN(this.a)) ? 1.0 : ((this.a &gt; 1) ? 1.0 : this.a);

    // some getters
    this.toRGBA = function()
    {
      return 'rgba(' + this.r + ', ' + this.g + ', '  + this.b + ', ' + this.a + ')';
    };
    this.toRGB = function()
    {
      return 'rgb(' + this.r + ', ' + this.g + ', ' + this.b + ')';
    };
    this.toHex = function()
    {
      var r = this.r.toString(16),
          g = this.g.toString(16),
          b = this.b.toString(16);
      if (r.length === 1)
      {
        r = '0' + r;
      }
      if (g.length === 1)
      {
        g = '0' + g;
      }
      if (b.length === 1)
      {
        b = '0' + b;
      }
      return '#' + r + g + b;
    };
  }

  function Drag3D(grabFn, dragFn, dropFn)
  {
    var savThis = this;

    this.cgo = null;      // filled in by render
    this.target = null;   // the Obj3D or Group3D that is to be dragged, filled by enableDrag method
    this.parent = null;   // the Obj3D that got the mouse down event on it, filled in at grab
    this.grabCallback = grabFn || null;
    this.dragCallback = dragFn || null;
    this.dropCallback = dropFn || null;
    this.grabCsrPos = {x:0, y:0, z:0};
    this.dwgOrg = {x:0, y:0, z:0};   // target's drawing origin in world coords
    this.dwgOrgOfs = {x:0, y:0, z:0};// target's dwgOrg offset from its parent Group3D's dwgOrg
    this.grabOfs = {x:0, y:0, z:0};  // csr offset from (relative) target dwgOrg, ie csrPos - dwgOrgOfs

    // these closures are called in the scope of the Drag3D instance so 'this' is valid
    this.grab = function(evt, grabbedObj)
    {
      var event = evt||window.event,
          csrPosWC;
      // this Drag3D may be attached to an Obj3D's Group3D parent
      if (grabbedObj.dragNdrop !== null)
      {
        this.parent = grabbedObj;      // the target is an Obj3D
      }
      else  // cant find the dragNdrop for this grab
      {
        return true;
      }

      this.cgo.cnvs.onmouseup = function(e){savThis.drop(e);};
      this.cgo.cnvs.onmouseout = function(e){savThis.drop(e);};
      csrPosWC = this.cgo.getCursorPosWC(event);  // world coords version of cursor position
      // save the cursor pos its very useful
      this.grabCsrPos.x = csrPosWC.x;
      this.grabCsrPos.y = csrPosWC.y;
      this.grabCsrPos.z = 0;
      // save the targets drawing origin (world coords)
      this.dwgOrg = {x:this.target.dwgOrg.tx,  // absolute coords, gets parent group dwgOrg added at render
                     y:this.target.dwgOrg.ty,
                     z:this.target.dwgOrg.tz};
      // save target's dwgOrg offset from its parent - this is what dragging will change
      // the world coords of the parent group are added back on by render
      if (this.target.parent)
      {
        this.dwgOrgOfs = {x:this.target.dwgOrg.tx - this.target.parent.dwgOrg.tx,
                          y:this.target.dwgOrg.ty - this.target.parent.dwgOrg.ty,
                          z:this.target.dwgOrg.tz - this.target.parent.dwgOrg.tz};
      }
      else
      {
        // no parent, so same as adding 0s
        this.dwgOrgOfs = {x:this.target.dwgOrg.tx,
                          y:this.target.dwgOrg.ty,
                          z:this.target.dwgOrg.tz};
      }

      // save the cursor offset from the target drawing origin (relative to parent) for convenience
      // subtracting this from dragged cursor pos gives the distance the target should be moved
      this.grabOfs = {x:csrPosWC.x - this.dwgOrgOfs.x,
                      y:csrPosWC.y - this.dwgOrgOfs.y,
                      z:csrPosWC.z - this.dwgOrgOfs.z};

      if (this.grabCallback)
      {
        this.grabCallback(csrPosWC);    // call in the scope of dragNdrop object
      }

      this.cgo.cnvs.onmousemove = function(event){savThis.drag(event);};
      if (event.preventDefault)       // prevent default browser action (W3C)
      {
        event.preventDefault();
      }
      else                        // shortcut for stopping the browser action in IE
      {
        window.event.returnValue = false;
      }
      return false;
    };

    this.drag = function(event)
    {
      var csrPosWC = this.cgo.getCursorPosWC(event);
      if (this.dragCallback)
      {
        this.dragCallback(csrPosWC);
      }

      return false;
    };

    this.drop = function(event)
    {
      var csrPosWC = this.cgo.getCursorPosWC(event);
      this.cgo.cnvs.onmouseup = null;
      this.cgo.cnvs.onmousemove = null;
      if (this.dropCallback)
      {
        this.dropCallback(csrPosWC);
      }
    };

    // version of drop that can be called from an app to stop a drag before the mouseup event
    this.cancelDrag = function(mousePos)
    {
      this.cgo.cnvs.onmouseup = null;
      this.cgo.cnvs.onmouseout = null;
      this.cgo.cnvs.onmousemove = null;
      if (this.dropCallback)
      {
        this.dropCallback(mousePos);
      }
    };
  }

  // Generate a 3D translation matrix
  function translateMatrix(tx, ty, tz)
  {
    var x = tx || 0,
        y = ty || 0,
        z = tz || 0;

    return [ [1, 0, 0, 0],
             [0, 1, 0, 0],
             [0, 0, 1, 0],
             [x, y, z, 1] ];
  }

  // Generate a 3D rotate matrix, angle in degrees
  function rotateMatrix(vx, vy, vz, deg)
  {
    var angle = deg || 0,
        t = Math.PI/180.0,
        mag = Math.sqrt(vx*vx + vy*vy + vz*vz),   // calc vector length
        x	= vx/mag,
        y	= vy/mag,
        z	= vz/mag,
        s	= Math.sin(-angle*t),
        c	= Math.cos(-angle*t),
        C	= 1-c;
        // ref: http://en.wikipedia.org/wiki/Quaternions_and_spatial_rotation
    return [[  (x*x*C+c), (y*x*C-z*s), (z*x*C+y*s), 0],
            [(x*y*C+z*s),   (y*y*C+c), (z*y*C-x*s), 0],
            [(x*z*C-y*s), (y*z*C+x*s),   (z*z*C+c), 0],
            [          0,           0,           0, 1]];
  }

  // Generate a 3D scale matrix
  function scaleMatrix(scale)
  {
    var s = scale || 1,
        as = Math.abs(s);


    return [ [as, 0,  0, 0],
             [0, as,  0, 0],
             [0,  0, as, 0],
             [0,  0,  0, 1]];
  }

  /* ===============================================
   * Object holding an array of 4 1x4 arrays,
   * representing a 4x4 matrix
   * -----------------------------------------------
   */
  function TransformMatrix(matrixAry)
  {
    if (isArray(matrixAry))
    {
      this.matrix = matrixAry;
    }
    else
    {
      this.matrix = [ [1, 0, 0, 0],
                      [0, 1, 0, 0],
                      [0, 0, 1, 0],
                      [0, 0, 0, 1] ];
    }
  }

  TransformMatrix.prototype.reset = function()
  {
    this.matrix[0][0] = 1;
    this.matrix[0][1] = 0;
    this.matrix[0][2] = 0;
    this.matrix[0][3] = 0;
    this.matrix[1][0] = 0;
    this.matrix[1][1] = 1;
    this.matrix[1][2] = 0;
    this.matrix[1][3] = 0;
    this.matrix[2][0] = 0;
    this.matrix[2][1] = 0;
    this.matrix[2][2] = 1;
    this.matrix[2][3] = 0;
    this.matrix[3][0] = 0;
    this.matrix[3][1] = 0;
    this.matrix[3][2] = 0;
    this.matrix[3][3] = 1;
  };

  TransformMatrix.prototype.applyTransform = function(m)
  {
    // apply a transform by multiplying this.matrix by matrix 'm'
    var a11 = this.matrix[0][0],
        a12 = this.matrix[0][1],
        a13 = this.matrix[0][2],
        a14 = this.matrix[0][3],
        a21 = this.matrix[1][0],
        a22 = this.matrix[1][1],
        a23 = this.matrix[1][2],
        a24 = this.matrix[1][3],
        a31 = this.matrix[2][0],
        a32 = this.matrix[2][1],
        a33 = this.matrix[2][2],
        a34 = this.matrix[2][3],
        a41 = this.matrix[3][0],
        a42 = this.matrix[3][1],
        a43 = this.matrix[3][2],
        a44 = this.matrix[3][3],
        b11 = m[0][0],
        b12 = m[0][1],
        b13 = m[0][2],
        b14 = m[0][3],
        b21 = m[1][0],
        b22 = m[1][1],
        b23 = m[1][2],
        b24 = m[1][3],
        b31 = m[2][0],
        b32 = m[2][1],
        b33 = m[2][2],
        b34 = m[2][3],
        b41 = m[3][0],
        b42 = m[3][1],
        b43 = m[3][2],
        b44 = m[3][3];

    this.matrix[0][0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
    this.matrix[0][1] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
    this.matrix[0][2] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
    this.matrix[0][3] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;
    this.matrix[1][0] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
    this.matrix[1][1] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
    this.matrix[1][2] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
    this.matrix[1][3] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;
    this.matrix[2][0] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
    this.matrix[2][1] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
    this.matrix[2][2] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
    this.matrix[2][3] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;
    this.matrix[3][0] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
    this.matrix[3][1] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
    this.matrix[3][2] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
    this.matrix[3][3] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;
  };

  function matrixMult(a, b)
  {
    var a11 = a[0][0],
        a12 = a[0][1],
        a13 = a[0][2],
        a14 = a[0][3],
        a21 = a[1][0],
        a22 = a[1][1],
        a23 = a[1][2],
        a24 = a[1][3],
        a31 = a[2][0],
        a32 = a[2][1],
        a33 = a[2][2],
        a34 = a[2][3],
        a41 = a[3][0],
        a42 = a[3][1],
        a43 = a[3][2],
        a44 = a[3][3],

        b11 = b[0][0],
        b12 = b[0][1],
        b13 = b[0][2],
        b14 = b[0][3],
        b21 = b[1][0],
        b22 = b[1][1],
        b23 = b[1][2],
        b24 = b[1][3],
        b31 = b[2][0],
        b32 = b[2][1],
        b33 = b[2][2],
        b34 = b[2][3],
        b41 = b[3][0],
        b42 = b[3][1],
        b43 = b[3][2],
        b44 = b[3][3];

    return [ [a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41,
              a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42,
              a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43,
              a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44],
             [a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41,
              a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42,
              a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43,
              a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44],
             [a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41,
              a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42,
              a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43,
              a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44],
             [a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41,
              a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42,
              a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43,
              a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44] ];
  }

  function StaticTfm(obj)
  {
    var savThis = this;

    this.parent = obj;
    this.translate = function(x, y, z)
    {
      savThis.parent.ofsTfmAry.push(translateMatrix(x, y, z));
    };
    this.scale = function(scl)
    {
      var s = scl || 1;

      savThis.parent.ofsTfmAry.unshift(scaleMatrix(s));
      // lineWidth is in pixels (not world coords) so it soft scales
      savThis.parent.lineWidth *= s;
    };
    this.rotate = function(vx, vy, vz, deg)
    {
      // put rotate in front of array so there is no move of dwgOrg
      savThis.parent.ofsTfmAry.unshift(rotateMatrix(vx, vy, vz, deg));
    };
    this.revolve = function(vx, vy, vz, deg)
    {
      // revolve matrix is identical to rotate but may be applied after soft translate.
      savThis.parent.ofsTfmAry.push(rotateMatrix(vx, vy, vz, deg));
    };
    this.reset = function()
    {
      savThis.parent.ofsTfmAry = [];  // clear out the pending transforms
      savThis.parent.ofsTfm.reset();  // reset the accumulation matrix
    };
  }

  /* ====================================================================
   * A 3D coordinate (right handed system)
   *
   * X +ve right
   * Y +ve up
   * Z +ve out screen
   * --------------------------------------------------------------------
   */
  function Point(x, y, z)
  {
    this.x = x || 0;
    this.y = y || 0;
    this.z = z || 0;

    // Translated, rotated, scaled
    this.tx = this.x;
    this.ty = this.y;
    this.tz = this.z;

    // tx, ty, tz, projected to 2D as seen from viewpoint
    this.fx = 0;
    this.fy = 0;
  }

  Point.prototype.hardTransform = function(m)
  {
    var a1 = this.x;
    var a2 = this.y;
    var a3 = this.z;
    var a4 = 1;

    var b11 = m[0][0];
    var b12 = m[0][1];
    var b13 = m[0][2];
//    var b14 = m[0][3];
    var b21 = m[1][0];
    var b22 = m[1][1];
    var b23 = m[1][2];
//    var b24 = m[1][3];
    var b31 = m[2][0];
    var b32 = m[2][1];
    var b33 = m[2][2];
//    var b34 = m[2][3];
    var b41 = m[3][0];
    var b42 = m[3][1];
    var b43 = m[3][2];
//    var b44 = m[3][3];

    this.x = this.tx = a1 * b11 + a2 * b21 + a3 * b31 + a4 * b41;
    this.y = this.ty = a1 * b12 + a2 * b22 + a3 * b32 + a4 * b42;
    this.z = this.tz = a1 * b13 + a2 * b23 + a3 * b33 + a4 * b43;
  };

  Point.prototype.softTransform = function(m)
  {
    var a1 = this.x;
    var a2 = this.y;
    var a3 = this.z;
    var a4 = 1;

    var b11 = m[0][0];
    var b12 = m[0][1];
    var b13 = m[0][2];
//    var b14 = m[0][3];
    var b21 = m[1][0];
    var b22 = m[1][1];
    var b23 = m[1][2];
//    var b24 = m[1][3];
    var b31 = m[2][0];
    var b32 = m[2][1];
    var b33 = m[2][2];
//    var b34 = m[2][3];
    var b41 = m[3][0];
    var b42 = m[3][1];
    var b43 = m[3][2];
//    var b44 = m[3][3];

    this.tx = a1 * b11 + a2 * b21 + a3 * b31 + a4 * b41;
    this.ty = a1 * b12 + a2 * b22 + a3 * b32 + a4 * b42;
    this.tz = a1 * b13 + a2 * b23 + a3 * b33 + a4 * b43;
  };

  /* =========================================================
   * Generate the Normal to a plane, given 3 points (3D)
   * which define a plane.
   * The vector returned starts at 0,0,0
   * is 1 unit long in direction perpendicular to the plane.
   * Calculates A X B where p2-p1=A, p3-p1=B
   * --------------------------------------------------------*/
  calcNormal = function (p1, p2, p3)
  {
    var n = new Point(0, 0, 1),  // default if vectors degenerate
        a = new Point(p2.x-p1.x, p2.y-p1.y, p2.z-p1.z),   // vector from p1 to p2
        b = new Point(p3.x-p1.x, p3.y-p1.y, p3.z-p1.z),   // vector from p1 to p3
        // a and b lie in the plane, a x b (cross product) is normal to both ie normal to plane
        // left handed coord system use left hand to get X product direction
        nx = a.y*b.z - a.z*b.y,
        ny = a.z*b.x - a.x*b.z,
        nz = a.x*b.y - a.y*b.x,
        mag = Math.sqrt(nx*nx + ny*ny + nz*nz);   // calc vector length

    if (mag)
    {
      n = new Point(nx/mag, ny/mag, nz/mag);      // make unit length in world coords
    }

    return n;
  };

  /* =========================================================
   * Calculate the included angle between 2 vectors
   * a, from base p1 to p2, and b, from p1 to p3.
   * --------------------------------------------------------*/
  calcIncAngle = function(p1, p2, p3)
  {
    var angRads = 0,
        a = new Point(p2.x-p1.x, p2.y-p1.y, p2.z-p1.z),   // vector from p1 to p2
        b = new Point(p3.x-p1.x, p3.y-p1.y, p3.z-p1.z),   // vector from p1 to p3
        numerator = a.x*b.x + a.y*b.y + a.z*b.z,
        denominator	= Math.sqrt(a.x*a.x + a.y*a.y + a.z*a.z)*Math.sqrt(b.x*b.x + b.y*b.y + b.z*b.z);

    if (denominator)
    {
      angRads = Math.acos(numerator/denominator);
    }

    return angRads*180.0/Math.PI;
  };

  Group3D = function()
  {
    this.type = "GROUP";                // enum of type to instruct the render method
    this.parent = null;                 // pointer to parent group if any
    this.children = [];                 // only Group3Ds have children
    this.dwgOrg = new Point(0, 0, 0);   // drawing origin (0,0,0) may get translated
    this.ofsTfmAry = [];
    this.ofsTfm = new TransformMatrix();    // Group's offset from any parent Group's current transform
    this.grpTfm = new TransformMatrix();    // Parent Group's current transform
    this.netTfm = new TransformMatrix();    // product of parent Group netTfm and this.ofsTfm
    this.centroid = new Point();
    // enable obj.transform.rotate etc. API
    this.transform = new StaticTfm(this);
    // add any objects passed by forwarding them to addObj
    this.addObj.apply(this, arguments);
  };

  Group3D.prototype.deleteObj = function(obj)
  {
    // remove from children array
    var idx = this.children.indexOf(obj);
    if (idx !== -1)
    {
      this.children.splice(idx, 1);
    }
  };

  Group3D.prototype.addObj = function()
  {
    var args = Array.prototype.slice.call(arguments), // grab array of arguments
        xSum = 0,
        ySum = 0,
        zSum = 0,
        numPts = 0,    // total point counter for all commands
        i, j;

    for (i=0; i&lt;args.length; i++)
    {
      if (isArray(args[i]))
      {
        // check that only Group3Ds or Obj3Ds are passed
        for (j=0; j&lt;args[i].length; j++)
        {
          if (args[i][j].type)
          {
            if (args[i][j].parent !== null)      // already a member of a Group3D, remove it
            {
              args[i][j].parent.deleteObj(args[i][j]);
            }
            // point the Obj3D or Group3D parent property at this Group3D
            args[i][j].parent = this;           // now its a free agent link it to this group
            this.children.push(args[i][j]);
            // enable drag and drop if this group has drag
            if (!args[i][j].dragNdrop &amp;&amp; this.dragNdrop)
            {
              args[i][j].dragNdrop = this.dragNdrop;
            }
          }
        }
      }
      else
      {
        if (args[i].type)
        {
          if (args[i].parent !== null)       // already a member of a Group2D, remove it
          {
            args[i].parent.deleteObj(args[i]);
          }
          args[i].parent = this;            // now its a free agent link it to this group
          // point the Obj3D or Group3D parent property at this Group3D
          this.children.push(args[i]);
          // enable drag and drop if this group has drag
          if (!args[i].dragNdrop &amp;&amp; this.dragNdrop)
          {
            args[i].dragNdrop = this.dragNdrop;
          }
        }
      }
    }
    for (j=0; j&lt;this.children.length; j++)
    {
        // add the objects centroid to calc group centroid
        xSum += this.children[j].centroid.x;
        ySum += this.children[j].centroid.y;
        zSum += this.children[j].centroid.z;
        numPts++;
    }
    if (numPts)
    {
      this.centroid.x = xSum/numPts;       // get recalculated several times but never if no Obj3Ds
      this.centroid.y = ySum/numPts;
      this.centroid.z = zSum/numPts;
    }
  };

  /*======================================
   * Recursively apply a translation to
   * child Obj3Ds or children of Group3Ds
   * This is a permanent change to
   * do not use for animation, use
   * transform method instead.
   *-------------------------------------*/
  Group3D.prototype.translate = function(tx, ty, tz)
  {
    var x = tx || 0,
        y = ty || 0,
        z = tz || 0,
        transMat = translateMatrix(x, y, z);

    // Apply transform to the hardOfsTfm of all Obj3D children recursively
  	function iterate(grp)
  	{
  		grp.children.forEach(function(childNode){
  			if (childNode.type === "GROUP")
        {
  				iterate(childNode);
        }
        else
        {
          childNode.translate(x, y, z);
        }
  		});
  	}

    iterate(this);
    this.centroid.hardTransform(transMat);    // translate the centroid
  };

  /*======================================
   * Recursively apply the rotation to
   * children or children of children
   * This is a permanent change to
   * do not use for animation, use
   * transform method instead.
   *-------------------------------------*/
  Group3D.prototype.rotate = function(vx, vy, vz, angle)
  {
    var deg = angle || 0,
        rotMat = rotateMatrix(vx, vy, vz, deg);

    // Apply transform to the hardOfsTfm of all Obj3D children recursively
  	function iterate(grp)
  	{
  		grp.children.forEach(function(childNode){
  			if (childNode.type === "GROUP")
        {
  				iterate(childNode);
        }
        else
        {
          childNode.rotate(vx, vy, vz, deg);
        }
  		});
  	}

    iterate(this);
    this.centroid.hardTransform(rotMat);    // rotate the Group3D centroid
  };

  /*======================================
   * Recursively apply the scaling to
   * children or children of children
   * This is a permanent change to
   * do not use for animation, use
   * transform method instead.
   *-------------------------------------*/
  Group3D.prototype.scale = function(scale)
  {
    var s = scale || 1,
        sclMat = scaleMatrix(s);

    // Apply transform to the hardOfsTfm of all Obj3D children recursively
  	function iterate(grp)
  	{
  		grp.children.forEach(function(childNode){
  			if (childNode.type === "GROUP")
        {
  				iterate(childNode);
        }
        else
        {
          childNode.scale(s);
        }
  		});
  	}

    iterate(this);
    this.centroid.hardTransform(sclMat);    // scale the centroid
  };

  /*======================================
   * Recursively add drag object to Obj3D
   * decendants.
   * When rendered all these Obj3D will be
   * added to _draggables to be checked on
   * mousedown
   *-------------------------------------*/
  Group3D.prototype.enableDrag = function(grabFn, dragFn, dropFn)
  {
    var savThis = this;

  	function iterate(grp)
  	{
  		grp.children.forEach(function(childNode){
  			if (childNode.type === "GROUP")
        {
  				iterate(childNode);
        }
        else  // Obj3D
        {
          if (childNode.dragNdrop === null)    // don't over-write if its already assigned a handler
          {
            childNode.enableDrag(grabFn, dragFn, dropFn);
            childNode.dragNdrop.target = savThis;     // the Group2D is the target being dragged
          }
        }
  		});
  	}

    iterate(this);
  };

  /*======================================
   * Disable dragging on Obj3D children
   *-------------------------------------*/
  Group3D.prototype.disableDrag = function()
  {
    // Can't immediately remove from _draggables array (no Cango reference) but no harm
  	function iterate(grp)
  	{
  		grp.children.forEach(function(childNode){
  			if (childNode.type === "GROUP")
        {
  				iterate(childNode);
        }
        else
        {
          childNode.disableDrag();
        }
  		});
  	}

    iterate(this);
  };

  /* =============================================================
   * DrawCmd3D
   * - drawFn: String, the canvas draw command name
   * - cPts: Array, [Point, Point ...] Bezier curve control points
   * - ep: Point, end point of the drawFn
   *-------------------------------------------------------------*/
  function DrawCmd3D(cmdStr, controlPoints, endPoint)
  {
    this.drawFn = cmdStr;             // String version of the canvas command to call
    this.cPts = controlPoints || [];  // [Point, Point ...] Bezier curve control points
    this.ep = endPoint;               // Point will  be undefined for 'closePath' drawFn
    this.parms = [];                  // 2D world coordinate version of cPts and ep
    this.parmsPx = [];                // 2D pixel coordinate version of cPts and ep
  }

  Obj3D = function(commands, objtype, options)
  {
    var opt, prop,
        xSum = 0,
        ySum = 0,
        zSum = 0,
        numPts = 0;    // total point counter for all commands

    this.type = "SHAPE";                // PATH, SHAPE, TEXT
    this.parent = null;                 // parent Group3D
    this.drawCmds = [];                 // array of DrawCmd3D objects
    this.bBoxCmds = [];                 // DrawCmd3D array for the text bounding box
    this.dwgOrg = new Point(0, 0, 0);   // drawing origin (0,0,0) may get translated
    this.centroid = new Point(0, 0, 0); // average of x, y, z coords
    this.normal = new Point(0, 0, 0);   // from centroid, normal to object plane
    this.dragNdrop = null;
    // properties handling transform inheritance
    this.hardOfsTfm = new TransformMatrix();// permanent, immediate, construction transform
    this.ofsTfmAry = [];                // accumulate transform matrices to be applied at render
    this.ofsTfm = new TransformMatrix();    // Obj3D's offset from any parent Group's current transform
    this.grpTfm = new TransformMatrix();    // Parent Group's current transform
    this.netTfm = new TransformMatrix();    // product of parent Group netTfm applied to this.ofsTfm
    this.lorgTfm = new TransformMatrix();   // text only, used for lorg effects
    // enable obj.transform.rotate etc. API
    this.transform = new StaticTfm(this);
    // properties set by setProperty. If undefined render uses Cango3D default
    this.strokeColor = null;            // used for PATHs and TEXT
    this.fillColor = null;              // used to fill SHAPEs
    this.backColor = null;              //  "    "   "    "
    this.backHidden = false;            // don't draw if normal pointing away
    this.lineWidth = 1;
    this.strokeCap = "butt";
    this.fontSize = null;               // TEXT only
    this.fontWeight = null;             // TEXT only
    this.lorg = 7;                      // TEXT only

    if (typeof objtype === 'string')
    {
      if (['PATH', 'SHAPE', 'TEXT'].indexOf(objtype) !== -1)
      {
        this.type = objtype;
      }
    }
    if (commands)
    {
      // send the Cgo3D (SVG) commands off to the canvas DrawCmd processor
      this.drawCmds = cgo3DtoDrawCmd3D(commands);
    }

    opt = (typeof options === 'object')? options: {};   // avoid undeclared object errors
    // check for all supported options
    for (prop in opt)
    {
      // check that this is opt's own property, not inherited from prototype
      if (opt.hasOwnProperty(prop))
      {
        this.setProperty(prop, opt[prop]);
      }
    }
    if (this.type === "SHAPE")
    {
      this.strokeCol = this.fillCol;  // shapes default to stroke and fill the same
    }
    if (this.type === "TEXT")
    {
      this.strokeCap = "round";
    }

    if (this.drawCmds.length)
    {
      this.drawCmds.forEach(function(dCmd){
        if (dCmd.ep !== undefined)  // check for Z command, has no coords
        {
          xSum += dCmd.ep.x;
          ySum += dCmd.ep.y;
          zSum += dCmd.ep.z;
          numPts++;
        }
      });
      this.centroid.x = xSum/numPts;
      this.centroid.y = ySum/numPts;
      this.centroid.z = zSum/numPts;

      if (this.drawCmds.length &gt; 2)
      {
        // make the normal(o, a, b)  = aXb, = vector from centroid to data[0], b = centroid to data[1]
        this.normal = calcNormal(this.centroid, this.drawCmds[1].ep, this.drawCmds[2].ep);
        // NOTE: traverse CCW, normal is out of screen (+z), traverse path CW, normal is into screen (-z)
      }
      else
      {
        if (this.drawCmds.length === 2)    // if Bezier it will need a normal
        {
          if (this.drawCmds[1].cPts.length)
          {
            this.normal = calcNormal(this.centroid, this.drawCmds[1].ep, this.drawCmds[1].cPts[0]);
          }
          else
          {
            // straight line but make a normal for completeness
            this.normal.z = 1;
          }
        }
        else
        {
          return;
        }
      }
      // move normal to start from the centroid
      this.normal.x += this.centroid.x;
      this.normal.y += this.centroid.y;
      this.normal.z += this.centroid.z;
    }
  };

  /*=========================================================
   * Obj3D.translate
   * Generate a transform matrix to translate a 3D point
   * away to a position x,y,z from 0,0,0 the drawing origin.
   * If TEXT apply to hardTfmOfs for use at render, for
   * PATH or SHAPE multiply every point in outline path,
   * along with the centroid and normal, by this matrix.
   * The transformed x,y,z values overwrite the current
   * values.
   *
   * This function should be used in shape
   * construction not animation. Animation doesn't change
   * x,y,z, it uses them to get tx,ty,tz.
   *---------------------------------------------------------
   */
  Obj3D.prototype.translate = function(x, y, z)
  {
    var transMat = translateMatrix(x, y, z),
        k;

    if (this.type === "TEXT")
    {
      this.hardOfsTfm.applyTransform(transMat);
    }
    else
    {
      this.drawCmds.forEach(function(cmd){
        for (k=0; k&lt;cmd.cPts.length; k++)   // transform each 3D Point
        {
          cmd.cPts[k].hardTransform(transMat);
        }
        // add the end point (check it exists since 'closePath' has no end point)
        if (cmd.ep !== undefined)
        {
          cmd.ep.hardTransform(transMat);
        }
      });
    }
    this.centroid.hardTransform(transMat);  // translate the centroid
    this.normal.hardTransform(transMat);    // translate the normal
  };

  /*=========================================================
   * Obj3D.rotate
   * Generate a transformation matrix to rotate a 3D point
   * around the axis defined by vector vx,vy,vz by angle degs.
   * If TEXT apply to hardTfmOfs for use at render, for
   * PATH or SHAPE multiply every point in outline path,
   * along with the centroid and normal, by this matrix.
   * The transformed x,y,z values overwrite the current
   * values.
   *
   * This function should be used in shape
   * construction not animation. Animation doesn't change
   * x,y,z, it uses them to get tx,ty,tz.
   *---------------------------------------------------------
   */
  Obj3D.prototype.rotate = function(vx, vy, vz, deg)
  {
    var rotMat = rotateMatrix(vx, vy, vz, deg),
        k;

    if (this.type === "TEXT")
    {
      this.hardOfsTfm.applyTransform(rotMat);
    }
    else
    {
      this.drawCmds.forEach(function(cmd){
        for (k=0; k&lt;cmd.cPts.length; k++)   // transform each 3D Point
        {
          cmd.cPts[k].hardTransform(rotMat);
        }
        // add the end point (check it exists since 'closePath' has no end point)
        if (cmd.ep !== undefined)
        {
          cmd.ep.hardTransform(rotMat);
        }
      });
    }
    this.centroid.hardTransform(rotMat);    // rotate the centroid
    this.normal.hardTransform(rotMat);    // rotate the normal
  };

  /*=========================================================
   * Obj3D.scale
   * Generate a transformation matrix to scale a 3D point
   * relative to its drawing origin.
   * If TEXT apply to hardTfmOfs for use at render, for
   * PATH or SHAPE multiply every point in outline path,
   * along with the centroid and normal, by this matrix.
   * The transformed x,y,z values overwrite the current
   * values.
   *
   * This function should be used in shape
   * construction not animation. Animation doesn't change
   * x,y,z, it uses them to get tx,ty,tz.
   *---------------------------------------------------------
   */
  Obj3D.prototype.scale = function(scale)
  {
    var sclMat = scaleMatrix(scale),
        k;

    if (this.type === "TEXT")
    {
      this.hardOfsTfm.applyTransform(sclMat);
    }
    else
    {
      this.drawCmds.forEach(function(cmd){
        for (k=0; k&lt;cmd.cPts.length; k++)   // transform each 3D Point
        {
          cmd.cPts[k].hardTransform(sclMat);
        }
        // add the end point (check it exists since 'closePath' has no end point)
        if (cmd.ep !== undefined)
        {
          cmd.ep.hardTransform(sclMat);
        }
      });
    }
    this.centroid.hardTransform(sclMat);    // scale the centroid
    this.normal.hardTransform(sclMat);    // translate the normal
  };

  /*======================================
   * Flips the normal to point in opposite
   * direction. Useful if object coordinates
   * track CW. The normal is into screen if
   * outline is traversed CW (RH rule).
   *-------------------------------------*/
  Obj3D.prototype.flipNormal = function()
  {
    var nx = this.normal.x,
        ny = this.normal.y,
        nz = this.normal.z;

    this.normal.x = 2*this.centroid.x - nx;
    this.normal.y = 2*this.centroid.y - ny;
    this.normal.z = 2*this.centroid.z - nz;
  };

  Obj3D.prototype.enableDrag = function(grabFn, dragFn, dropFn)
  {
    this.dragNdrop = new Drag3D(grabFn, dragFn, dropFn);
    // fill in the Drag2D properties for use by callBacks
    this.dragNdrop.target = this;
  };

  Obj3D.prototype.disableDrag = function()
  {
    var aidx;

    if ((!this.dragNdrop)||(!this.dragNdrop.cgo))
    {
      return;
    }
    // remove this object from array to be checked on mousedown
    // remove this object from array to be checked on mousedown
    aidx = this.dragNdrop.cgo.dragObjects.indexOf(this);
    this.dragNdrop.cgo.dragObjects.splice(aidx, 1);
    this.dragNdrop = null;
  };

  Obj3D.prototype.setProperty = function(propertyName, value)
  {
    var color;

    if ((typeof propertyName !== "string")||(value === undefined)||(value === null))
    {
      return;
    }

    switch (propertyName.toLowerCase())
    {
      case "fillcolor":
        color = new RGBAColor(value);
        if (color.ok)
        {
          this.fillColor = color;
        }
        break;
      case "backcolor":
        color = new RGBAColor(value);
        if (color.ok)
        {
          this.backColor = color;
        }
        break;
      case "strokecolor":
        color = new RGBAColor(value);
        if (color.ok)
        {
          this.strokeColor = color;
        }
        break;
      case "linewidth":
      case "strokewidth":                 // for backward compatability
        this.lineWidth = value;
        break;
      case "linecap":
      case "strokecap":
        if (typeof value !== "string")
        {
          return;
        }
        if ((value === "butt")||(value === "round")||(value === "square"))
        {
          this.strokeCap = value;
        }
        break;
      case "fontsize":
        this.fontSize = value;
        break;
      case "fontweight":
        if ((typeof value === "string")||((typeof value === "number")&amp;&amp;(value&gt;=100)&amp;&amp;(value&lt;=900)))
        {
          this.fontWeight = value;
        }
        break;
      case "lorg":
        if ([1, 2, 3, 4, 5, 6, 7, 8, 9].indexOf(value) !== -1)
        {
          this.lorg = value;
        }
        break;
      case "width":             // for internal use compiling TEXT obj
        this.width = value;
        break;
      case "height":
        this.height = value;
        break;
      default:
        return;
    }
  };

  Obj3D.prototype.dup = function()
  {
    var newObj = new Obj3D();

    /* create a copy (not just a reference) of an object */
    function clone(obj)
    {
      var nObj = (isArray(obj)) ? [] : {},
          i;
      for (i in obj)
      {
        if (obj[i] &amp;&amp; typeof obj[i] === "object")
        {
          nObj[i] = clone(obj[i]);
        }
        else
        {
          nObj[i] = obj[i];
        }
      }
      return nObj;
    }

    newObj.parent = this.parent;
    newObj.type = this.type;
    newObj.drawCmds = clone(this.drawCmds);
    newObj.bBoxCmds = clone(this.bBoxCmds);
    newObj.dwgOrg = clone(this.dwgOrg);
    newObj.centroid = clone(this.centroid);
    newObj.normal = clone(this.normal);
    newObj.hardOfsTfm = clone(this.hardOfsTfm);
    newObj.strokeColor = clone(this.strokeColor);
    newObj.fillColor = clone(this.fillColor);
    newObj.backColor = clone(this.backColor);
    newObj.backHidden = this.backHidden;
    newObj.lineWidth = this.lineWidth;
    newObj.strokeCap = this.strokeCap;
    newObj.fontSize = this.fontSize;
    newObj.fontWeight = this.fontWeight;
    newObj.lorg = this.lorg;
    newObj.width = this.width;
    newObj.height = this.height;

    return newObj;
  };

  /*-------------------------------------------------------------
   This text code is based on Jim Studt, CanvasTextFunctions
   see http://jim.studt.net/canvastext/
   It has been adapted to output Cgo3D format and has had Greek
   letters and a few symbols added from Hershey's original font
   -------------------------------------------------------------*/

  hersheyFont.letters = {
/*   */ ' ': {width:16, cdata:[]},
/* ! */ '!': {width:10, cdata:['M',5,21,0,'L',5,7,0,'M',5,2,0,'L',4,1,0,5,0,0,6,1,0,5,2,0]},
/* " */ '"': {width:16, cdata:['M',4,21,0,'L',4,14,0,'M',12,21,0,'L',12,14,0]},
/* # */ '#': {width:21, cdata:['M',11,25,0,'L',4,-7,0,'M',17,25,0,'L',10,-7,0,'M',4,12,0,'L',18,12,0,'M',3,6,0,'L',17,6,0]},
/* $ */ '$': {width:20, cdata:['M',8,25,0,'L',8,-4,0,'M',12,25,0,'L',12,-4,0,'M',17,18,0,'L',15,20,0,12,21,0,8,21,0,5,20,0,3,18,0,3,16,0,4,14,0,5,13,0,7,12,0,13,10,0,15,9,0,16,8,0,17,6,0,17,3,0,15,1,0,12,0,0,8,0,0,5,1,0,3,3,0]},
/* % */ '%': {width:24, cdata:['M',21,21,0,'L',3,0,0,'M',8,21,0,'L',10,19,0,10,17,0,9,15,0,7,14,0,5,14,0,3,16,0,3,18,0,4,20,0,6,21,0,8,21,0,10,20,0,13,19,0,16,19,0,19,20,0,21,21,0,'M',17,7,0,'L',15,6,0,14,4,0,14,2,0,16,0,0,18,0,0,20,1,0,21,3,0,21,5,0,19,7,0,17,7,0]},
/* &amp; */ '&amp;': {width:26, cdata:['M',23,12,0,'L',23,13,0,22,14,0,21,14,0,20,13,0,19,11,0,17,6,0,15,3,0,13,1,0,11,0,0,7,0,0,5,1,0,4,2,0,3,4,0,3,6,0,4,8,0,5,9,0,12,13,0,13,14,0,14,16,0,14,18,0,13,20,0,11,21,0,9,20,0,8,18,0,8,16,0,9,13,0,11,10,0,16,3,0,18,1,0,20,0,0,22,0,0,23,1,0,23,2,0]},
/* ' */ '\'': {width:10, cdata:['M',5,19,0,'L',4,20,0,5,21,0,6,20,0,6,18,0,5,16,0,4,15,0]},
/* ( */ '(': {width:14, cdata:['M',11,25,0,'L',9,23,0,7,20,0,5,16,0,4,11,0,4,7,0,5,2,0,7,-2,0,9,-5,0,11,-7,0]},
/* ) */ ')': {width:14, cdata:['M',3,25,0,'L',5,23,0,7,20,0,9,16,0,10,11,0,10,7,0,9,2,0,7,-2,0,5,-5,0,3,-7,0]},
/* * */ '*': {width:16, cdata:['M',8,15,0,'L',8,3,0,'M',3,12,0,'L',13,6,0,'M',13,12,0,'L',3,6,0]},
/* + */ '+': {width:26, cdata:['M',13,18,0,'L',13,0,0,'M',4,9,0,'L',22,9,0]},
/* , */ ',': {width:8, cdata:['M',5,4,0,'L',4,3,0,3,4,0,4,5,0,5,4,0,5,2,0,3,0,0]},
/* - */ '-': {width:26, cdata:['M',4,9,0,'L',22,9,0]},
/* . */ '.': {width:8, cdata:['M',4,5,0,'L',3,4,0,4,3,0,5,4,0,4,5,0]},
/* / */ '/': {width:22, cdata:['M',20,25,0,'L',2,-7,0]},
/* 0 */ '0': {width:20, cdata:['M',9,21,0,'L',6,20,0,4,17,0,3,12,0,3,9,0,4,4,0,6,1,0,9,0,0,11,0,0,14,1,0,16,4,0,17,9,0,17,12,0,16,17,0,14,20,0,11,21,0,9,21,0]},
/* 1 */ '1': {width:20, cdata:['M',6,17,0,'L',8,18,0,11,21,0,11,0,0]},
/* 2 */ '2': {width:20, cdata:['M',4,16,0,'L',4,17,0,5,19,0,6,20,0,8,21,0,12,21,0,14,20,0,15,19,0,16,17,0,16,15,0,15,13,0,13,10,0,3,0,0,17,0,0]},
/* 3 */ '3': {width:20, cdata:['M',5,21,0,'L',16,21,0,10,13,0,13,13,0,15,12,0,16,11,0,17,8,0,17,6,0,16,3,0,14,1,0,11,0,0,8,0,0,5,1,0,4,2,0,3,4,0]},
/* 4 */ '4': {width:20, cdata:['M',13,21,0,'L',3,7,0,18,7,0,'M',13,21,0,'L',13,0,0]},
/* 5 */ '5': {width:20, cdata:['M',15,21,0,'L',5,21,0,4,12,0,5,13,0,8,14,0,11,14,0,14,13,0,16,11,0,17,8,0,17,6,0,16,3,0,14,1,0,11,0,0,8,0,0,5,1,0,4,2,0,3,4,0]},
/* 6 */ '6': {width:20, cdata:['M',16,18,0,'L',15,20,0,12,21,0,10,21,0,7,20,0,5,17,0,4,12,0,4,7,0,5,3,0,7,1,0,10,0,0,11,0,0,14,1,0,16,3,0,17,6,0,17,7,0,16,10,0,14,12,0,11,13,0,10,13,0,7,12,0,5,10,0,4,7,0]},
/* 7 */ '7': {width:20, cdata:['M',17,21,0,'L',7,0,0,'M',3,21,0,'L',17,21,0]},
/* 8 */ '8': {width:20, cdata:['M',8,21,0,'L',5,20,0,4,18,0,4,16,0,5,14,0,7,13,0,11,12,0,14,11,0,16,9,0,17,7,0,17,4,0,16,2,0,15,1,0,12,0,0,8,0,0,5,1,0,4,2,0,3,4,0,3,7,0,4,9,0,6,11,0,9,12,0,13,13,0,15,14,0,16,16,0,16,18,0,15,20,0,12,21,0,8,21,0]},
/* 9 */ '9': {width:20, cdata:['M',16,14,0,'L',15,11,0,13,9,0,10,8,0,9,8,0,6,9,0,4,11,0,3,14,0,3,15,0,4,18,0,6,20,0,9,21,0,10,21,0,13,20,0,15,18,0,16,14,0,16,9,0,15,4,0,13,1,0,10,0,0,8,0,0,5,1,0,4,3,0]},
/* : */ ':': {width:8, cdata:['M',4,12,0,'L',3,11,0,4,10,0,5,11,0,4,12,0,'M',4,5,0,'L',3,4,0,4,3,0,5,4,0,4,5,0]},
/* ; */ ';': {width:8, cdata:['M',4,12,0,'L',3,11,0,4,10,0,5,11,0,4,12,0,'M',5,4,0,'L',4,3,0,3,4,0,4,5,0,5,4,0,5,2,0,3,0,0]},
/* &lt; */ '&lt;': {width:24, cdata:['M',20,18,0,'L',4,9,0,20,0,0]},
/* = */ '=': {width:26, cdata:['M',4,12,0,'L',22,12,0,'M',4,6,0,'L',22,6,0]},
/* &gt; */ '&gt;': {width:24, cdata:['M',4,18,0,'L',20,9,0,4,0,0]},
/* ? */ '?': {width:18, cdata:['M',3,16,0,'L',3,17,0,4,19,0,5,20,0,7,21,0,11,21,0,13,20,0,14,19,0,15,17,0,15,15,0,14,13,0,13,12,0,9,10,0,9,7,0,'M',9,2,0,'L',8,1,0,9,0,0,10,1,0,9,2,0]},
/* @ */ '@': {width:27, cdata:['M',18,13,0,'L',17,15,0,15,16,0,12,16,0,10,15,0,9,14,0,8,11,0,8,8,0,9,6,0,11,5,0,14,5,0,16,6,0,17,8,0,'M',12,16,0,'L',10,14,0,9,11,0,9,8,0,10,6,0,11,5,0,'M',18,16,0,'L',17,8,0,17,6,0,19,5,0,21,5,0,23,7,0,24,10,0,24,12,0,23,15,0,22,17,0,20,19,0,18,20,0,15,21,0,12,21,0,9,20,0,7,19,0,5,17,0,4,15,0,3,12,0,3,9,0,4,6,0,5,4,0,7,2,0,9,1,0,12,0,0,15,0,0,18,1,0,20,2,0,21,3,0,'M',19,16,0,'L',18,8,0,18,6,0,19,5,0]},
/* A */ 'A': {width:18, cdata:['M',9,21,0,'L',1,0,0,'M',9,21,0,'L',17,0,0,'M',4,7,0,'L',14,7,0]},
/* B */ 'B': {width:21, cdata:['M',4,21,0,'L',4,0,0,'M',4,21,0,'L',13,21,0,16,20,0,17,19,0,18,17,0,18,15,0,17,13,0,16,12,0,13,11,0,'M',4,11,0,'L',13,11,0,16,10,0,17,9,0,18,7,0,18,4,0,17,2,0,16,1,0,13,0,0,4,0,0]},
/* C */ 'C': {width:21, cdata:['M',18,16,0,'L',17,18,0,15,20,0,13,21,0,9,21,0,7,20,0,5,18,0,4,16,0,3,13,0,3,8,0,4,5,0,5,3,0,7,1,0,9,0,0,13,0,0,15,1,0,17,3,0,18,5,0]},
/* D */ 'D': {width:21, cdata:['M',4,21,0,'L',4,0,0,'M',4,21,0,'L',11,21,0,14,20,0,16,18,0,17,16,0,18,13,0,18,8,0,17,5,0,16,3,0,14,1,0,11,0,0,4,0,0]},
/* E */ 'E': {width:19, cdata:['M',4,21,0,'L',4,0,0,'M',4,21,0,'L',17,21,0,'M',4,11,0,'L',12,11,0,'M',4,0,0,'L',17,0,0]},
/* F */ 'F': {width:18, cdata:['M',4,21,0,'L',4,0,0,'M',4,21,0,'L',17,21,0,'M',4,11,0,'L',12,11,0]},
/* G */ 'G': {width:21, cdata:['M',18,16,0,'L',17,18,0,15,20,0,13,21,0,9,21,0,7,20,0,5,18,0,4,16,0,3,13,0,3,8,0,4,5,0,5,3,0,7,1,0,9,0,0,13,0,0,15,1,0,17,3,0,18,5,0,18,8,0,'M',13,8,0,'L',18,8,0]},
/* H */ 'H': {width:22, cdata:['M',4,21,0,'L',4,0,0,'M',18,21,0,'L',18,0,0,'M',4,11,0,'L',18,11,0]},
/* I */ 'I': {width:8, cdata:['M',4,21,0,'L',4,0,0]},
/* J */ 'J': {width:16, cdata:['M',12,21,0,'L',12,5,0,11,2,0,10,1,0,8,0,0,6,0,0,4,1,0,3,2,0,2,5,0,2,7,0]},
/* K */ 'K': {width:21, cdata:['M',4,21,0,'L',4,0,0,'M',18,21,0,'L',4,7,0,'M',9,12,0,'L',18,0,0]},
/* L */ 'L': {width:17, cdata:['M',4,21,0,'L',4,0,0,'M',4,0,0,'L',16,0,0]},
/* M */ 'M': {width:24, cdata:['M',4,21,0,'L',4,0,0,'M',4,21,0,'L',12,0,0,'M',20,21,0,'L',12,0,0,'M',20,21,0,'L',20,0,0]},
/* N */ 'N': {width:22, cdata:['M',4,21,0,'L',4,0,0,'M',4,21,0,'L',18,0,0,'M',18,21,0,'L',18,0,0]},
/* O */ 'O': {width:22, cdata:['M',9,21,0,'L',7,20,0,5,18,0,4,16,0,3,13,0,3,8,0,4,5,0,5,3,0,7,1,0,9,0,0,13,0,0,15,1,0,17,3,0,18,5,0,19,8,0,19,13,0,18,16,0,17,18,0,15,20,0,13,21,0,9,21,0]},
/* P */ 'P': {width:21, cdata:['M',4,21,0,'L',4,0,0,'M',4,21,0,'L',13,21,0,16,20,0,17,19,0,18,17,0,18,14,0,17,12,0,16,11,0,13,10,0,4,10,0]},
/* Q */ 'Q': {width:22, cdata:['M',9,21,0,'L',7,20,0,5,18,0,4,16,0,3,13,0,3,8,0,4,5,0,5,3,0,7,1,0,9,0,0,13,0,0,15,1,0,17,3,0,18,5,0,19,8,0,19,13,0,18,16,0,17,18,0,15,20,0,13,21,0,9,21,0,'M',12,4,0,'L',18,-2,0]},
/* R */ 'R': {width:21, cdata:['M',4,21,0,'L',4,0,0,'M',4,21,0,'L',13,21,0,16,20,0,17,19,0,18,17,0,18,15,0,17,13,0,16,12,0,13,11,0,4,11,0,'M',11,11,0,'L',18,0,0]},
/* S */ 'S': {width:20, cdata:['M',17,18,0,'L',15,20,0,12,21,0,8,21,0,5,20,0,3,18,0,3,16,0,4,14,0,5,13,0,7,12,0,13,10,0,15,9,0,16,8,0,17,6,0,17,3,0,15,1,0,12,0,0,8,0,0,5,1,0,3,3,0]},
/* T */ 'T': {width:16, cdata:['M',8,21,0,'L',8,0,0,'M',1,21,0,'L',15,21,0]},
/* U */ 'U': {width:22, cdata:['M',4,21,0,'L',4,6,0,5,3,0,7,1,0,10,0,0,12,0,0,15,1,0,17,3,0,18,6,0,18,21,0]},
/* V */ 'V': {width:18, cdata:['M',1,21,0,'L',9,0,0,'M',17,21,0,'L',9,0,0]},
/* W */ 'W': {width:24, cdata:['M',2,21,0,'L',7,0,0,'M',12,21,0,'L',7,0,0,'M',12,21,0,'L',17,0,0,'M',22,21,0,'L',17,0,0]},
/* X */ 'X': {width:20, cdata:['M',3,21,0,'L',17,0,0,'M',17,21,0,'L',3,0,0]},
/* Y */ 'Y': {width:18, cdata:['M',1,21,0,'L',9,11,0,9,0,0,'M',17,21,0,'L',9,11,0]},
/* Z */ 'Z': {width:20, cdata:['M',17,21,0,'L',3,0,0,'M',3,21,0,'L',17,21,0,'M',3,0,0,'L',17,0,0]},
/* [ */ '[': {width:14, cdata:['M',4,25,0,'L',4,-7,0,'M',5,25,0,'L',5,-7,0,'M',4,25,0,'L',11,25,0,'M',4,-7,0,'L',11,-7,0]},
/* \ */ '\\': {width:14, cdata:['M',0,21,0,'L',14,-3,0]},
/* ] */ ']': {width:14, cdata:['M',9,25,0,'L',9,-7,0,'M',10,25,0,'L',10,-7,0,'M',3,25,0,'L',10,25,0,'M',3,-7,0,'L',10,-7,0]},
/* ^ */ '^': {width:16, cdata:['M',8,23,0,'L',0,9,0,'M',8,23,0,'L',16,9,0]},
/* _ */ '_': {width:18, cdata:['M',0,-7,0,'L',18,-7,0]},
/* ` */ '`': {width:8, cdata:['M',5,16,0,'L',3,14,0,3,12,0,4,11,0,5,12,0,4,13,0,3,12,0]},
/* a */ 'a': {width:19, cdata:['M',15,14,0,'L',15,0,0,'M',15,11,0,'L',13,13,0,11,14,0,8,14,0,6,13,0,4,11,0,3,8,0,3,6,0,4,3,0,6,1,0,8,0,0,11,0,0,13,1,0,15,3,0]},
/* b */ 'b': {width:19, cdata:['M',4,21,0,'L',4,0,0,'M',4,11,0,'L',6,13,0,8,14,0,11,14,0,13,13,0,15,11,0,16,8,0,16,6,0,15,3,0,13,1,0,11,0,0,8,0,0,6,1,0,4,3,0]},
/* c */ 'c': {width:18, cdata:['M',15,11,0,'L',13,13,0,11,14,0,8,14,0,6,13,0,4,11,0,3,8,0,3,6,0,4,3,0,6,1,0,8,0,0,11,0,0,13,1,0,15,3,0]},
/* d */ 'd': {width:19, cdata:['M',15,21,0,'L',15,0,0,'M',15,11,0,'L',13,13,0,11,14,0,8,14,0,6,13,0,4,11,0,3,8,0,3,6,0,4,3,0,6,1,0,8,0,0,11,0,0,13,1,0,15,3,0]},
/* e */ 'e': {width:18, cdata:['M',3,8,0,'L',15,8,0,15,10,0,14,12,0,13,13,0,11,14,0,8,14,0,6,13,0,4,11,0,3,8,0,3,6,0,4,3,0,6,1,0,8,0,0,11,0,0,13,1,0,15,3,0]},
/* f */ 'f': {width:12, cdata:['M',10,21,0,'L',8,21,0,6,20,0,5,17,0,5,0,0,'M',2,14,0,'L',9,14,0]},
/* g */ 'g': {width:19, cdata:['M',15,14,0,'L',15,-2,0,14,-5,0,13,-6,0,11,-7,0,8,-7,0,6,-6,0,'M',15,11,0,'L',13,13,0,11,14,0,8,14,0,6,13,0,4,11,0,3,8,0,3,6,0,4,3,0,6,1,0,8,0,0,11,0,0,13,1,0,15,3,0]},
/* h */ 'h': {width:19, cdata:['M',4,21,0,'L',4,0,0,'M',4,10,0,'L',7,13,0,9,14,0,12,14,0,14,13,0,15,10,0,15,0,0]},
/* i */ 'i': {width:8, cdata:['M',3,21,0,'L',4,20,0,5,21,0,4,22,0,3,21,0,'M',4,14,0,'L',4,0,0]},
/* j */ 'j': {width:10, cdata:['M',5,21,0,'L',6,20,0,7,21,0,6,22,0,5,21,0,'M',6,14,0,'L',6,-3,0,5,-6,0,3,-7,0,1,-7,0]},
/* k */ 'k': {width:17, cdata:['M',4,21,0,'L',4,0,0,'M',14,14,0,'L',4,4,0,'M',8,8,0,'L',15,0,0]},
/* l */ 'l': {width:8, cdata:['M',4,21,0,'L',4,0,0]},
/* m */ 'm': {width:30, cdata:['M',4,14,0,'L',4,0,0,'M',4,10,0,'L',7,13,0,9,14,0,12,14,0,14,13,0,15,10,0,15,0,0,'M',15,10,0,'L',18,13,0,20,14,0,23,14,0,25,13,0,26,10,0,26,0,0]},
/* n */ 'n': {width:19, cdata:['M',4,14,0,'L',4,0,0,'M',4,10,0,'L',7,13,0,9,14,0,12,14,0,14,13,0,15,10,0,15,0,0]},
/* o */ 'o': {width:19, cdata:['M',8,14,0,'L',6,13,0,4,11,0,3,8,0,3,6,0,4,3,0,6,1,0,8,0,0,11,0,0,13,1,0,15,3,0,16,6,0,16,8,0,15,11,0,13,13,0,11,14,0,8,14,0]},
/* p */ 'p': {width:19, cdata:['M',4,14,0,'L',4,-7,0,'M',4,11,0,'L',6,13,0,8,14,0,11,14,0,13,13,0,15,11,0,16,8,0,16,6,0,15,3,0,13,1,0,11,0,0,8,0,0,6,1,0,4,3,0]},
/* q */ 'q': {width:19, cdata:['M',15,14,0,'L',15,-7,0,'M',15,11,0,'L',13,13,0,11,14,0,8,14,0,6,13,0,4,11,0,3,8,0,3,6,0,4,3,0,6,1,0,8,0,0,11,0,0,13,1,0,15,3,0]},
/* r */ 'r': {width:13, cdata:['M',4,14,0,'L',4,0,0,'M',4,8,0,'L',5,11,0,7,13,0,9,14,0,12,14,0]},
/* s */ 's': {width:17, cdata:['M',14,11,0,'L',13,13,0,10,14,0,7,14,0,4,13,0,3,11,0,4,9,0,6,8,0,11,7,0,13,6,0,14,4,0,14,3,0,13,1,0,10,0,0,7,0,0,4,1,0,3,3,0]},
/* t */ 't': {width:12, cdata:['M',5,21,0,'L',5,4,0,6,1,0,8,0,0,10,0,0,'M',2,14,0,'L',9,14,0]},
/* u */ 'u': {width:19, cdata:['M',4,14,0,'L',4,4,0,5,1,0,7,0,0,10,0,0,12,1,0,15,4,0,'M',15,14,0,'L',15,0,0]},
/* v */ 'v': {width:16, cdata:['M',2,14,0,'L',8,0,0,'M',14,14,0,'L',8,0,0]},
/* w */ 'w': {width:22, cdata:['M',3,14,0,'L',7,0,0,'M',11,14,0,'L',7,0,0,'M',11,14,0,'L',15,0,0,'M',19,14,0,'L',15,0,0]},
/* x */ 'x': {width:17, cdata:['M',3,14,0,'L',14,0,0,'M',14,14,0,'L',3,0,0]},
/* y */ 'y': {width:16, cdata:['M',2,14,0,'L',8,0,0,'M',14,14,0,'L',8,0,0,6,-4,0,4,-6,0,2,-7,0,1,-7,0]},
/* z */ 'z': {width:17, cdata:['M',14,14,0,'L',3,0,0,'M',3,14,0,'L',14,14,0,'M',3,0,0,'L',14,0,0]},
/* { */ '{': {width:14, cdata:['M',9,25,0,'L',7,24,0,6,23,0,5,21,0,5,19,0,6,17,0,7,16,0,8,14,0,8,12,0,6,10,0,'M',7,24,0,'L',6,22,0,6,20,0,7,18,0,8,17,0,9,15,0,9,13,0,8,11,0,4,9,0,8,7,0,9,5,0,9,3,0,8,1,0,7,0,0,6,-2,0,6,-4,0,7,-6,0,'M',6,8,0,'L',8,6,0,8,4,0,7,2,0,6,1,0,5,-1,0,5,-3,0,6,-5,0,7,-6,0,9,-7,0]},
/* | */ '|': {width:8, cdata:['M',4,25,0,'L',4,-7,0]},
/* } */ '}': {width:14, cdata:['M',5,25,0,'L',7,24,0,8,23,0,9,21,0,9,19,0,8,17,0,7,16,0,6,14,0,6,12,0,8,10,0,'M',7,24,0,'L',8,22,0,8,20,0,7,18,0,6,17,0,5,15,0,5,13,0,6,11,0,10,9,0,6,7,0,5,5,0,5,3,0,6,1,0,7,0,0,8,-2,0,8,-4,0,7,-6,0,'M',8,8,0,'L',6,6,0,6,4,0,7,2,0,8,1,0,9,-1,0,9,-3,0,8,-5,0,7,-6,0,5,-7,0]},
/* ~ */ '~': {width:24, cdata:['M',3,6,0,'L',3,8,0,4,11,0,6,12,0,8,12,0,10,11,0,14,8,0,16,7,0,18,7,0,20,8,0,21,10,0,'M',3,8,0,'L',4,10,0,6,11,0,8,11,0,10,10,0,14,7,0,16,6,0,18,6,0,20,7,0,21,10,0,21,12,0]},
/* &amp;Alpha; */   '\u0391': {width:18, cdata:['M',9,21,0,'L',1,0,0,'M',9,21,0,'L',17,0,0,'M',4,7,0,'L',14,7,0]},
/* &amp;Beta; */    '\u0392': {width:21, cdata:['M',4,21,0,'L',4,0,0,'M',4,21,0,'L',13,21,0,16,20,0,17,19,0,18,17,0,18,15,0,17,13,0,16,12,0,13,11,0,'M',4,11,0,'L',13,11,0,16,10,0,17,9,0,18,7,0,18,4,0,17,2,0,16,1,0,13,0,0,4,0,0]},
/* &amp;Chi; */     '\u03A7': {width:20, cdata:['M',3,21,0,'L',17,0,0,'M',3,0,0,'L',17,21,0]},
/* &amp;Delta; */   '\u0394': {width:18, cdata:['M',9,21,0,'L',1,0,0,'M',9,21,0,'L',17,0,0,'M',1,0,0,'L',17,0,0]},
/* &amp;Epsilon; */ '\u0395': {width:19, cdata:['M',4,21,0,'L',4,0,0,'M',4,21,0,'L',17,21,0,'M',4,11,0,'L',12,11,0,'M',4,0,0,'L',17,0,0]},
/* &amp;Phi; */     '\u03A6': {width:20, cdata:['M',10,21,0,'L',10,0,0,'M',8,16,0,'L',5,15,0,4,14,0,3,12,0,3,9,0,4,7,0,5,6,0,8,5,0,12,5,0,15,6,0,16,7,0,17,9,0,17,12,0,16,14,0,15,15,0,12,16,0,8,16,0]},
/* &amp;Gamma; */   '\u0393': {width:17, cdata:['M',4,21,0,'L',4,0,0,'M',4,21,0,'L',16,21,0]},
/* &amp;Eta; */     '\u0397': {width:22, cdata:['M',4,21,0,'L',4,0,0,'M',18,21,0,'L',18,0,0,'M',4,11,0,'L',18,11,0]},
/* &amp;Iota; */    '\u0399': {width:8, cdata:['M',4,21,0,'L',4,0,0]},
/* &amp;middot; */  '\u00B7': {width:5, cdata:['M',2,10,0,'L',2,9,0,3,9,0,3,10,0,2,10,0]},
/* &amp;Kappa; */   '\u039A': {width:21, cdata:['M',4,21,0,'L',4,0,0,'M',18,21,0,'L',4,7,0,'M',9,12,0,'L',18,0,0]},
/* &amp;Lambda; */  '\u039B': {width:18, cdata:['M',9,21,0,'L',1,0,0,'M',9,21,0,'L',17,0,0]},
/* &amp;Mu; */      '\u039C': {width:24, cdata:['M',4,21,0,'L',4,0,0,'M',4,21,0,'L',12,0,0,'M',20,21,0,'L',12,0,0,'M',20,21,0,'L',20,0,0]},
/* &amp;Nu; */      '\u039D': {width:22, cdata:['M',4,21,0,'L',4,0,0,'M',4,21,0,'L',18,0,0,'M',18,21,0,'L',18,0,0]},
/* &amp;Omicron; */ '\u039F': {width:22, cdata:['M',9,21,0,'L',7,20,0,5,18,0,4,16,0,3,13,0,3,8,0,4,5,0,5,3,0,7,1,0,9,0,0,13,0,0,15,1,0,17,3,0,18,5,0,19,8,0,19,13,0,18,16,0,17,18,0,15,20,0,13,21,0,9,21,0]},
/* &amp;Pi; */      '\u03A0': {width:22, cdata:['M',4,21,0,'L',4,0,0,'M',18,21,0,'L',18,0,0,'M',4,21,0,'L',18,21,0]},
/* &amp;Theta; */   '\u0398': {width:22, cdata:['M',9,21,0,'L',7,20,0,5,18,0,4,16,0,3,13,0,3,8,0,4,5,0,5,3,0,7,1,0,9,0,0,13,0,0,15,1,0,17,3,0,18,5,0,19,8,0,19,13,0,18,16,0,17,18,0,15,20,0,13,21,0,9,21,0,'M',8,11,0,'L',14,11,0]},
/* &amp;Rho; */     '\u03A1': {width:21, cdata:['M',4,21,0,'L',4,0,0,'M',4,21,0,'L',13,21,0,16,20,0,17,19,0,18,17,0,18,14,0,17,12,0,16,11,0,13,10,0,4,10,0]},
/* &amp;Sigma; */   '\u03A3': {width:18, cdata:['M',2,21,0,'L',9,11,0,2,0,0,'M',2,21,0,'L',16,21,0,'M',2,0,0,'L',16,0,0]},
/* &amp;Tau; */     '\u03A4': {width:16, cdata:['M',8,21,0,'L',8,0,0,'M',1,21,0,'L',15,21,0]},
/* &amp;upsih; */   '\u03A5': {width:18, cdata:['M',2,16,0,'L',2,18,0,3,20,0,4,21,0,6,21,0,7,20,0,8,18,0,9,14,0,9,0,0,'M',16,16,0,'L',16,18,0,15,20,0,14,21,0,12,21,0,11,20,0,10,18,0,9,14,0]},
/* &amp;deg; */     '\u00B0': {width:14, cdata:['M',6,21,0,'L',4,20,0,3,18,0,3,16,0,4,14,0,6,13,0,8,13,0,10,14,0,11,16,0,11,18,0,10,20,0,8,21,0,6,21,0]},
/* &amp;Omega; */   '\u03A9': {width:20, cdata:['M',3,0,0,'L',7,0,0,4,7,0,3,11,0,3,15,0,4,18,0,6,20,0,9,21,0,11,21,0,14,20,0,16,18,0,17,15,0,17,11,0,16,7,0,13,0,0,17,0,0]},
/* &amp;Xi; */      '\u039E': {width:18, cdata:['M',2,21,0,'L',16,21,0,'M',6,11,0,'L',12,11,0,'M',2,0,0,'L',16,0,0]},
/* &amp;Psi; */     '\u03A8': {width:22, cdata:['M',11,21,0,'L',11,0,0,'M',2,15,0,'L',3,15,0,4,14,0,5,10,0,6,8,0,7,7,0,10,6,0,12,6,0,15,7,0,16,8,0,17,10,0,18,14,0,19,15,0,20,15,0]},
/* &amp;Zeta; */    '\u0396': {width:20, cdata:['M',17,21,0,'L',3,0,0,'M',3,21,0,'L',17,21,0,'M',3,0,0,'L',17,0,0]},
/* &amp;alpha; */   '\u03B1': {width:21, cdata:['M',9,14,0,'L',7,13,0,5,11,0,4,9,0,3,6,0,3,3,0,4,1,0,6,0,0,8,0,0,10,1,0,13,4,0,15,7,0,17,11,0,18,14,0,'M',9,14,0,'L',11,14,0,12,13,0,13,11,0,15,3,0,16,1,0,17,0,0,18,0,0]},
/* &amp;beta; */    '\u03B2': {width:19, cdata:['M',12,21,0,'L',10,20,0,8,18,0,6,14,0,5,11,0,4,7,0,3,1,0,2,-7,0,'M',12,21,0,'L',14,21,0,16,19,0,16,16,0,15,14,0,14,13,0,12,12,0,9,12,0,'M',9,12,0,'L',11,11,0,13,9,0,14,7,0,14,4,0,13,2,0,12,1,0,10,0,0,8,0,0,6,1,0,5,2,0,4,5,0]},
/* &amp;chi; */     '\u03C7': {width:18, cdata:['M',2,14,0,'L',4,14,0,6,12,0,12,-5,0,14,-7,0,16,-7,0,'M',17,14,0,'L',16,12,0,14,9,0,4,-2,0,2,-5,0,1,-7,0]},
/* &amp;delta; */   '\u03B4': {width:18, cdata:['M',11,14,0,'L',8,14,0,6,13,0,4,11,0,3,8,0,3,5,0,4,2,0,5,1,0,7,0,0,9,0,0,11,1,0,13,3,0,14,6,0,14,9,0,13,12,0,11,14,0,9,16,0,8,18,0,8,20,0,9,21,0,11,21,0,13,20,0,15,18,0]},
/* &amp;epsilon; */ '\u03B5': {width:16, cdata:['M',13,12,0,'L',12,13,0,10,14,0,7,14,0,5,13,0,5,11,0,6,9,0,9,8,0,'M',9,8,0,'L',5,7,0,3,5,0,3,3,0,4,1,0,6,0,0,9,0,0,11,1,0,13,3,0]},
/* &amp;phi; */     '\u03C6': {width:22, cdata:['M',8,13,0,'L',6,12,0,4,10,0,3,7,0,3,4,0,4,2,0,5,1,0,7,0,0,10,0,0,13,1,0,16,3,0,18,6,0,19,9,0,19,12,0,17,14,0,15,14,0,13,12,0,11,8,0,9,3,0,6,-7,0]},
/* &amp;gamma; */   '\u03B3': {width:19, cdata:['M',1,11,0,'L',3,13,0,5,14,0,6,14,0,8,13,0,9,12,0,10,9,0,10,5,0,9,0,0,'M',17,14,0,'L',16,11,0,15,9,0,9,0,0,7,-4,0,6,-7,0]},
/* &amp;eta; */     '\u03B7': {width:20, cdata:['M',1,10,0,'L',2,12,0,4,14,0,6,14,0,7,13,0,7,11,0,6,7,0,4,0,0,'M',6,7,0,'L',8,11,0,10,13,0,12,14,0,14,14,0,16,12,0,16,9,0,15,4,0,12,-7,0]},
/* &amp;iota; */    '\u03B9': {width:11, cdata:['M',6,14,0,'L',4,7,0,3,3,0,3,1,0,4,0,0,6,0,0,8,2,0,9,4,0]},
/* &amp;times; */   '\u00D7': {width:22, cdata:['M',4,16,0,'L',18,2,0,'M',18,16,0,'L',4,2,0]},
/* &amp;kappa; */   '\u03BA': {width:18, cdata:['M',6,14,0,'L',2,0,0,'M',16,13,0,'L',15,14,0,14,14,0,12,13,0,8,9,0,6,8,0,5,8,0,'M',5,8,0,'L',7,7,0,8,6,0,10,1,0,11,0,0,12,0,0,13,1,0]},
/* &amp;lambda; */  '\u03BB': {width:16, cdata:['M',1,21,0,'L',3,21,0,5,20,0,6,19,0,14,0,0,'M',8,14,0,'L',2,0,0]},
/* &amp;mu; */      '\u03BC': {width:21, cdata:['M',7,14,0,'L',1,-7,0,'M',6,10,0,'L',5,5,0,5,2,0,7,0,0,9,0,0,11,1,0,13,3,0,15,7,0,'M',17,14,0,'L',15,7,0,14,3,0,14,1,0,15,0,0,17,0,0,19,2,0,20,4,0]},
/* &amp;nu; */      '\u03BD': {width:18, cdata:['M',3,14,0,'L',6,14,0,5,8,0,4,3,0,3,0,0,'M',16,14,0,'L',15,11,0,14,9,0,12,6,0,9,3,0,6,1,0,3,0,0]},
/* &amp;omicron; */ '\u03BF': {width:17, cdata:['M',8,14,0,'L',6,13,0,4,11,0,3,8,0,3,5,0,4,2,0,5,1,0,7,0,0,9,0,0,11,1,0,13,3,0,14,6,0,14,9,0,13,12,0,12,13,0,10,14,0,8,14,0]},
/* &amp;pi; */      '\u03C0': {width:22, cdata:['M',9,14,0,'L',5,0,0,'M',14,14,0,'L',15,8,0,16,3,0,17,0,0,'M',2,11,0,'L',4,13,0,7,14,0,20,14,0]},
/* &amp;thetasym; */'\u03D1': {width:21, cdata:['M',1,10,0,'L',2,12,0,4,14,0,6,14,0,7,13,0,7,11,0,6,6,0,6,3,0,7,1,0,8,0,0,10,0,0,12,1,0,14,4,0,15,6,0,16,9,0,17,14,0,17,17,0,16,20,0,14,21,0,12,21,0,11,19,0,11,17,0,12,14,0,14,11,0,16,9,0,19,7,0]},
/* &amp;rho; */     '\u03C1': {width:18, cdata:['M',4,8,0,'L',4,5,0,5,2,0,6,1,0,8,0,0,10,0,0,12,1,0,14,3,0,15,6,0,15,9,0,14,12,0,13,13,0,11,14,0,9,14,0,7,13,0,5,11,0,4,8,0,0,-7,0]},
/* &amp;sigma; */   '\u03C3': {width:20, cdata:['M',18,14,0,'L',8,14,0,6,13,0,4,11,0,3,8,0,3,5,0,4,2,0,5,1,0,7,0,0,9,0,0,11,1,0,13,3,0,14,6,0,14,9,0,13,12,0,12,13,0,10,14,0]},
/* &amp;tau; */     '\u03C4': {width:20, cdata:['M',11,14,0,'L',8,0,0,'M',2,11,0,'L',4,13,0,7,14,0,18,14,0]},
/* &amp;upsilon; */ '\u03C5': {width:20, cdata:['M',1,10,0,'L',2,12,0,4,14,0,6,14,0,7,13,0,7,11,0,5,5,0,5,2,0,7,0,0,9,0,0,12,1,0,14,3,0,16,7,0,17,11,0,17,14,0]},
/* &amp;divide; */  '\u00F7': {width:26, cdata:['M',13,18,0,'L',12,17,0,13,16,0,14,17,0,13,18,0,'M',4,9,0,'L',22,9,0,'M',13,2,0,'L',12,1,0,13,0,0,14,1,0,13,2,0]},
/* &amp;omega; */   '\u03C9': {width:23, cdata:['M',8,14,0,'L',6,13,0,4,10,0,3,7,0,3,4,0,4,1,0,5,0,0,7,0,0,9,1,0,11,4,0,'M',12,8,0,'L',11,4,0,12,1,0,13,0,0,15,0,0,17,1,0,19,4,0,20,7,0,20,10,0,19,13,0,18,14,0]},
/* &amp;xi; */      '\u03BE': {width:16, cdata:['M',10,21,0,'L',8,20,0,7,19,0,7,18,0,8,17,0,11,16,0,14,16,0,'M',11,16,0,'L',8,15,0,6,14,0,5,12,0,5,10,0,7,8,0,10,7,0,12,7,0,'M',10,7,0,'L',6,6,0,4,5,0,3,3,0,3,1,0,5,-1,0,9,-3,0,10,-4,0,10,-6,0,8,-7,0,6,-7,0]},
/* &amp;psi; */     '\u03C8': {width:23, cdata:['M',16,21,0,'L',8,-7,0,'M',1,10,0,'L',2,12,0,4,14,0,6,14,0,7,13,0,7,11,0,6,6,0,6,3,0,7,1,0,9,0,0,11,0,0,14,1,0,16,3,0,18,6,0,20,11,0,21,14,0]},
/* &amp;zeta; */    '\u03B6': {width:15, cdata:['M',10,21,0,'L',8,20,0,7,19,0,7,18,0,8,17,0,11,16,0,14,16,0,'M',14,16,0,'L',10,14,0,7,12,0,4,9,0,3,6,0,3,4,0,4,2,0,6,0,0,9,-2,0,10,-4,0,10,-6,0,9,-7,0,7,-7,0,6,-5,0]},
/* &amp;theta; */   '\u03B8': {width:21, cdata:['M',12,21,0,'L',9,20,0,7,18,0,5,15,0,4,13,0,3,9,0,3,5,0,4,2,0,5,1,0,7,0,0,9,0,0,12,1,0,14,3,0,16,6,0,17,8,0,18,12,0,18,16,0,17,19,0,16,20,0,14,21,0,12,21,0,'M',4,11,0,'L',18,11,0]}
  };

  hersheyFont.strWidth = function(fontSize, str)
  {
    var total = 0,
        i, c;

    for (i=0; i&lt;str.length; i++)
    {
    	c = hersheyFont.letters[str.charAt(i)];
    	if (c)
      {
        total += c.width * fontSize / 25.0;
      }
    }

    return total;
  };

  hersheyFont.stringToCgo3D = function(str)
  {
    var i, c,
        wid = 0,
        hgt = 0,
        charData, cgoData = [];

    function shiftChar(cAry, d)    // cAry = Hershey Cgo3D array, d = shift required
    {
      var newAry = [],
          x, y, z,
          j = 0;
      while (j&lt;cAry.length)
      {
        if (typeof cAry[j] === "string")
        {
          newAry.push(cAry[j++]);      // push the command letter
        }
        x = cAry[j++] + d;   // j now index of x coord in x,y,z triplet
        y = cAry[j++];
        z = cAry[j++];
        newAry.push(x, y, z);
      }
      return newAry;
    }

    for (i=0; i&lt;str.length; i++)
    {
      c = hersheyFont.letters[str.charAt(i)];
      if (c)
      {
        charData = shiftChar(c.cdata, wid);
        wid += c.width;               // add character width to total
        cgoData = cgoData.concat(charData);   // make a single array of drawCmds3D for the whole string
      }
    }
    /* Note: char cell is 33 pixels high, char size is 22 pixels (0 to 21), descenders go to -7 to 21.
       passing 'size' to a draw text function scales char height by size/33.
       Reference height for vertically alignment is charHeight = 29 of the fontSize in pixels. */
    hgt = 29;       // current font size in pixels
    // wid = string width in pixels

    return {"cgoData": cgoData, "width": wid, "height": hgt};
  };

  function initDragAndDrop(savThis)
  {
    function dragHandler(evt)
    {
      var event = evt || window.event,
          csrPos, testObj, len, j;

      function getCursorPos(e)
      {
        // pass in any mouse event, returns the position of the cursor in raw pixel coords
        var rect = savThis.cnvs.getBoundingClientRect();

        return {x: e.clientX - rect.left, y: e.clientY - rect.top};
      }

      function hitTest(pathObj, csrX, csrY)
      {
        var i;
        // create the path (don't stroke it - no-one will see) to test for hit
        savThis.ctx.beginPath();
        if (pathObj.type === 'TEXT')   // use bounding box not drawCmds
        {
          for (i=0; i&lt;pathObj.bBoxCmds.length; i++)
          {
            savThis.ctx[pathObj.bBoxCmds[i].drawFn].apply(savThis.ctx, pathObj.bBoxCmds[i].parmsPx);
          }
        }
        else
        {
          for (i=0; i&lt;pathObj.drawCmds.length; i++)
          {
            savThis.ctx[pathObj.drawCmds[i].drawFn].apply(savThis.ctx, pathObj.drawCmds[i].parmsPx);
          }
        }
/*
    // for diagnostics on hit region, uncomment
    savThis.ctx.strokeStyle = 'red';
    savThis.ctx.lineWidth = 4;
    savThis.ctx.stroke();
*/
        return savThis.ctx.isPointInPath(csrX, csrY);
      }

      csrPos = getCursorPos(event);  // savThis is any Cango ctx on the canvas
      // run through all the registered objects and test if cursor pos is in their path
      len = savThis.cnvs.dragObjects.length;
      for (j = savThis.cnvs.dragObjects.length-1; j &gt;= 0; j--)  // search from last drawn to first (underneath)
      {
        testObj = savThis.cnvs.dragObjects[j];
        if (hitTest(testObj, csrPos.x, csrPos.y))
        {
          // call the grab handler for this object (check it is still enabled)
          if (testObj.dragNdrop)
          {
            testObj.dragNdrop.grab(event, testObj);
            break;
          }
        }
      }

    }

    // =========== Start Here ===========

    savThis.cnvs.onmousedown = dragHandler;
  }

  Cango3D = function(canvasId)
  {
    this.cId = canvasId;
    this.cnvs = document.getElementById(canvasId);
    if (this.cnvs === null)
    {
      alert("can't find canvas "+canvasId);
      return;
    }
    this.rawWidth = this.cnvs.offsetWidth;
    this.rawHeight = this.cnvs.offsetHeight;
    this.aRatio = this.rawWidth/this.rawHeight;
    if (!this.cnvs.hasOwnProperty('dragObjects'))  // only 1st Cango instance makes the array
    {
      // create an array to hold all the draggable objects for this canvas
      this.cnvs.dragObjects = [];
    }
    if (!this.cnvs.hasOwnProperty('resized'))
    {
      // make canvas native aspect ratio equal style box aspect ratio.
      // Note: rawWidth and rawHeight are floats, assignment to ints will truncate
      this.cnvs.setAttribute('width', this.rawWidth);    // reset canvas pixels width
      this.cnvs.setAttribute('height', this.rawHeight);  // don't use style for this
      this.cnvs.resized = true;
    }
    this.ctx = this.cnvs.getContext('2d');    // draw direct to screen canvas
    this.vpW = this.rawWidth;         // vp width in pixels (no more viewport so use full canvas)
    this.vpH = this.rawHeight;        // vp height in pixels, canvas height = width/aspect ratio
    this.vpLLx = 0;                   // vp lower left of viewport (not used) from canvas left, in pixels
    this.vpLLy = this.rawHeight;      // vp lower left of viewport from canvas top
    this.xscl = 1;                    // world x axis scale factor, default: pixels
    this.yscl = -1;                   // world y axis scale factor, +ve up (always -xscl since isotropic)
    this.xoffset = 0;                 // world x origin offset from viewport left in pixels
    this.yoffset = 0;                 // world y origin offset from viewport bottom in pixels
    this.ctx.textAlign = "left";      // all offsets are handled by lorg facility
    this.ctx.textBaseline = "top";
    this.penCol = new RGBAColor("black");
    this.penWid = 1;            // pixels
    this.lineCap = "butt";
    this.paintCol = new RGBAColor("steelblue");
    this.backCol = new RGBAColor("gray");
    this.fontSize = 10;         // 10pt
    this.fontWeight = 400;      // 100 .. 900 (400 normal, 700 bold)
    this.fov = 45;              // 45 deg looks better. 60 is absolute max for good perspective effect
    this.viewpointDistance = this.rawWidth/(this.xscl*Math.tan(this.fov*Math.PI/360)); // world coords
    this.lightSource = {x:0, y:100, z:500};     // world coords
    this.plotNormals = false;   // diagnostic, if true green (toward) or red (away) normals are drawn

    initDragAndDrop(this);
  };

  Cango3D.prototype.toPixelCoords3D = function(x, y, z)
  {
    // transform x,y,z in world coords to canvas pixel coords (top left is 0,0,0 y axis +ve down)
    var xPx = this.vpLLx+this.xoffset+x*this.xscl,
        yPx = this.vpLLy+this.yoffset+y*this.yscl,
        zPx = z*this.xscl;

    return {x: xPx, y: yPx, z:zPx};
  };

  Cango3D.prototype.toWorldCoords3D = function(xPx, yPx, zPx)
  {
    // transform xPx,yPx,zPx in raw canvas pixels to world coords (lower left is 0,0 +ve up)
    var xW = (xPx - this.vpLLx - this.xoffset)/this.xscl,
        yW = (yPx - this.vpLLy - this.yoffset)/this.yscl,
        zW = zPx/this.xscl;

    return {x: xW, y: yW, z:zW};
  };

  Cango3D.prototype.getCursorPos = function(evt)
  {
    // pass in any mouse event, returns the position of the cursor in raw pixel coords
    var e = evt||window.event,
        rect = this.cnvs.getBoundingClientRect();

    return {x: e.clientX - rect.left, y: e.clientY - rect.top, z:0};
  };

  Cango3D.prototype.getCursorPosWC = function(evt)
  {
    // pass in any mouse event, returns the position of the cursor in raw pixel coords
    var e = evt||window.event,
        rect = this.cnvs.getBoundingClientRect(),
        xW = (e.clientX - rect.left - this.vpLLx - this.xoffset)/this.xscl,
        yW = (e.clientY - rect.top - this.vpLLy - this.yoffset)/this.yscl;

    return {x: xW, y: yW, z: 0};
  };

  Cango3D.prototype.clearCanvas = function(fillColor)
  {
    if (fillColor !== undefined)
    {
      this.ctx.save();            // going to change fillStyle, save current
      this.ctx.fillStyle = fillColor;
      this.ctx.fillRect(0, 0, this.rawWidth, this.rawHeight);
      this.ctx.restore();
    }
    else
    {
      this.ctx.clearRect(0, 0, this.rawWidth, this.rawHeight);
    }
    // all drawing erased, but graphics contexts remain intact
    // clear the dragObjects array, draggables put back when rendered
    this.cnvs.dragObjects.length = 0;
  };

  Cango3D.prototype.setWorldCoords3D = function(leftX, lowerY, spanX)
  {
    if (spanX &gt;0)
    {
      this.xscl = this.vpW/spanX;
      this.yscl = -this.xscl;
      this.xoffset = -leftX*this.xscl;
      this.yoffset = -lowerY*this.yscl;
    }
    else
    {
      this.xscl = this.rawWidth/100;    // makes xaxis = 100 native units
      this.yscl = -this.rawWidth/100;   // makes yaxis = 100*aspect ratio ie. square pixels
      this.xoffset = 0;
      this.yoffset = 0;
    }
    this.setFOV(this.fov);              // reset the viewpoint distance in world coords
  };

  Cango3D.prototype.setPropertyDefault = function(propertyName, value)
  {
    var newCol;

    if ((typeof propertyName !== "string")||(value === undefined)||(value === null))
    {
      return;
    }
    switch (propertyName.toLowerCase())
    {
      case "backgroundcolor":
        newCol = new RGBAColor(value);
        if (newCol.ok)
        {
          this.cnvs.style.backgroundColor = newCol.toRGBA();
        }
        break;
      case "fillcolor":
        newCol = new RGBAColor(value);
        if (newCol.ok)
        {
          this.paintCol = newCol;
        }
        break;
      case "backcolor":
        newCol = new RGBAColor(value);
        if (newCol.ok)
        {
          this.backCol = newCol;
        }
        break;
      case "strokecolor":
        newCol = new RGBAColor(value);
        if (newCol.ok)
        {
          this.penCol = newCol;
        }
        break;
      case "strokewidth":
      case "linewidth":
        this.penWid = value;
        this.ctx.lineWidth = this.penWid;
        break;
      case "linecap":
        if (typeof value !== "string")
        {
          return;
        }
        if ((value === "butt")||(value === "round")||(value === "square"))
        {
          this.lineCap = value;
        }
        this.ctx.lineCap = this.lineCap;
        break;
      case "fontsize":
        if (isNumber(value) &amp;&amp; (value &gt;= 6)&amp;&amp;(value &lt;= 60))
        {
          this.fontSize = value;
        }
        break;
      case "fontweight":
        if (isNumber(value) &amp;&amp; (value &gt;= 100)&amp;&amp;(value &lt;= 900))
        {
          this.fontWeight = value;
        }
        break;
      default:
        return;
    }
  };

  Cango3D.prototype.setFOV = function(deg)  // viewpoint distance in world coords
  {
    var savThis = this;

    function fovToVPdist(fov)
    {
      var w = savThis.rawWidth;
      var ll = savThis.xoffset;
      var x, fon2;

      if (ll&lt;0)
      {
        ll = 0;
      }
      if  (ll&gt;w)
      {
        ll = w;
      }

      x = Math.abs(w/2 - ll) + w/2;
      x /= savThis.xscl;

      fon2 = Math.PI*fov/(360);

      return x/Math.tan(fon2);
    }

    // set field of view &lt;60deg for good perspective
    if ((deg &lt;= 60)&amp;&amp;(deg&gt;=20))
    {
      this.fov = deg;
      this.viewpointDistance = fovToVPdist(this.fov);
    }
  };

  Cango3D.prototype.setLightSource = function(x, y, z)    // x, y, z in world coords
  {
    if ((x !== undefined)&amp;&amp;(y !== undefined)&amp;&amp;(z !== undefined))
    {
      this.lightSource.x = x;
      this.lightSource.y = y;
      this.lightSource.z = z;
    }
  };

  // this method allows the Object Group3D to be passed the Cango3D environment
  Cango3D.prototype.createGroup3D = function()
  {
    var grp = new Group3D();
    grp.addObj.apply(grp, arguments);

    return grp;
  };

  Cango3D.prototype.compilePath3D = function(path, color, lineWidth)
  {
    var lineWd = lineWidth || this.penWid,
        obj = new Obj3D(path, "PATH", {"strokeColor":color, "lineWidth":lineWd});

    return obj;   // object of type Obj3D
  };

  Cango3D.prototype.compileShape3D = function(path, fillColor, bkCol)
  {
    var obj = new Obj3D(path, "SHAPE", {"fillColor":fillColor, "backColor":bkCol});

    return obj;   // object of type Obj3D
  };

  Cango3D.prototype.compileText3D = function(str, color, pxlSize, fontWt, lorigin)
  {
    var strData, obj,
        size = this.fontSize,
        weight = this.fontWeight,
        ll, ul, lr, ur,
        dy;

    if (isNumber(pxlSize) &amp;&amp; (pxlSize &gt;= 6) &amp;&amp; (pxlSize &lt;= 60))
    {
      size = pxlSize;
    }
    if (isNumber(fontWt) &amp;&amp; (fontWt &gt; 99) &amp;&amp; (fontWt &lt; 901))
    {
      weight = fontWt;
    }

    strData = hersheyFont.stringToCgo3D(str);
    obj = new Obj3D(strData.cgoData, "TEXT", {"strokeColor":color, "fontSize":size,
                                       "fontWeight":weight, "lorg":lorigin,
                                       "width":strData.width, "height":strData.height,
                                       "lineWidth": 1});
    // construct the DrawCmds for the text bounding box
    dy = 0.25*obj.height;   // correct for alphabetic baseline, its offset about 0.25*char height
    ll = new Point(0, -dy, 0);
    lr = new Point(obj.width, -dy, 0);
    ul = new Point(0, obj.height-dy, 0);
    ur = new Point(obj.width, obj.height-dy, 0);
    // construct the DrawCmd3Ds for the text bounding box
    obj.bBoxCmds[0] = new DrawCmd3D("moveTo", [], ul);
    obj.bBoxCmds[1] = new DrawCmd3D("lineTo", [], ll);
    obj.bBoxCmds[2] = new DrawCmd3D("lineTo", [], lr);
    obj.bBoxCmds[3] = new DrawCmd3D("lineTo", [], ur);
    obj.bBoxCmds[4] = new DrawCmd3D("closePath", []);

    return obj;
  };

  Cango3D.prototype.tagShape3D = function(shpObj, txtObj, xOfs, yOfs)
  {
    var dx = xOfs || 0,
        dy = yOfs || 0;

    if (shpObj.type !== 'SHAPE')
    {
      return null;
    }
    txtObj.translate(dx, dy, 0);
    txtObj.backHidden = true;
    txtObj.centroid.x = shpObj.centroid.x;    // so sorting doesn't put shape in front
    txtObj.centroid.y = shpObj.centroid.y;
    txtObj.centroid.z = shpObj.centroid.z;
    txtObj.normal.x = shpObj.normal.x;
    txtObj.normal.y = shpObj.normal.y;
    txtObj.normal.z = shpObj.normal.z;

    return new Group3D(shpObj, txtObj);  // shape always drawn first since centroids equal
  };

  Cango3D.prototype.appendTag = function(grp, txtObj, xOfs, yOfs)
  {
    var shpObj = grp.children[0],
        dx = xOfs || 0,
        dy = yOfs || 0;

    if (shpObj.type !== 'SHAPE')
    {
      return;
    }
    txtObj.translate(dx, dy, 0);
    txtObj.backHidden = true;
    txtObj.centroid.x = shpObj.centroid.x;    // so sorted doesn't put shape in front
    txtObj.centroid.y = shpObj.centroid.y;
    txtObj.centroid.z = shpObj.centroid.z;
    txtObj.normal.x = shpObj.normal.x;
    txtObj.normal.y = shpObj.normal.y;
    txtObj.normal.z = shpObj.normal.z;

    grp.addObj(txtObj);
  };

  /*=========================================================
   * JSONtoObj3D
   * Convert the JS object parsed from JSON string into
   * an Obj3D or Group3D of Obj3D.
   * usage:
   * (load a file as a string into 'var jsonStr')
   * var jsonData = JSON.parse(jsonStr);
   * obj = cgo.JSONtoObj3D(jsonData);
   *---------------------------------------------------------
   */
  Cango3D.prototype.JSONtoObj3D = function(jsonData)
  {
    var output, data;

    function makeObj(data)
    {
      var obj,
          fillCol = (data.fillColor)? new RGBAColor(data.fillColor) : null,
          strokeCol = (data.strokeColor)? new RGBAColor(data.strokeColor) : null,
          backCol = (data.backColor)? new RGBAColor(data.backColor) : null,
          lineWid = data.lineWidth || 1;

      if (data.type === "GROUP")
      {
        obj = new Group3D();
      }
      else if (data.type === "PATH")
      {
        obj = new Obj3D(data.pathData, "PATH");
      }
      else if (data.type === "SHAPE")
      {
        obj = new Obj3D(data.pathData, "SHAPE");
      }
      else if (data.type === "TEXT")
      {
        obj = new Obj3D(data.pathData, "TEXT");
        // convert the text bounding box back into DrawCmd3Ds
        obj.bBoxCmds = cgo3DtoDrawCmd3D(data.textBoxData);
      }
      if (data.hardOfsTfm)
      {
        obj.hardOfsTfm = data.hardOfsTfm;
      }
      // save the name if any
      if (data.name)
      {
        obj.name = data.name.slice(0);
      }
      //  overwrite the calculated centroid and normal (saved will handle flipNormal)
      if (data.centroid)
      {
        obj.centroid = new Point(data.centroid[0], data.centroid[1], data.centroid[2]);
      }
      if (data.normal)
      {
        obj.normal = new Point(data.normal[0], data.normal[1], data.normal[2]);
      }
      if (obj.type !== "GROUP")      // fill in the other properties of Obj3D
      {
        obj.fillColor = fillCol;
        obj.strokeColor = strokeCol;
        obj.backColor = backCol;
        obj.lineWidth = lineWid;
        obj.backHidden = data.backHidden || false;
        obj.fontSize = data.fontSize || null;
        obj.fontWeight = data.fontWeight || null;
        obj.width = data.width || null;
        obj.height = data.height || null;
        obj.lorg = data.lorg || 7;
        obj.strokeCap = data.strokeCap || 'butt';
      }
      return obj;
    }

  	function iterate(task, node, grp)
  	{
  	  var x, item, childNode;
  		for(x=0; x &lt; node.children.length; x++)
  		{
  			childNode = node.children[x];
  			item = task(childNode);   // if child type is GROUP a new Group3D is returned
        grp.addObj(item);
  			if (childNode.type === "GROUP")
        {
  				iterate(task, childNode, item);     // item will be a Group3D
        }
   		}
  	}

    data = jsonData.ComponentData;    // componentdata is always an object
    if (data.type === "GROUP")
    {
      output = this.createGroup3D();
      iterate(makeObj, data, output);
    }
    else
    {
      output = makeObj(data); // returns SHAPE, PATH or TEXT data
    }

    return output;
  };

  function drawCmd3DToCgo3D(dCmds)
  {
    var ary = [];

    function rnd(val)
    {
      return Math.round(val*1000)/1000;
    }

    function drawCmdtoCgo3D(drawCmd)
    {
      switch (drawCmd.drawFn)
      {
        case "moveTo":
          ary.push("M");
          ary.push(rnd(drawCmd.ep.x), rnd(drawCmd.ep.y), rnd(drawCmd.ep.z));
        break;
        case "lineTo":
          ary.push("L");
          ary.push(rnd(drawCmd.ep.x), rnd(drawCmd.ep.y), rnd(drawCmd.ep.z));
        break;
        case "bezierCurveTo":
          ary.push("C");
          ary.push(rnd(drawCmd.cPts[0].x), rnd(drawCmd.cPts[0].y), rnd(drawCmd.cPts[0].z));
          ary.push(rnd(drawCmd.cPts[1].x), rnd(drawCmd.cPts[1].y), rnd(drawCmd.cPts[1].z));
          ary.push(rnd(drawCmd.ep.x), rnd(drawCmd.ep.y), rnd(drawCmd.ep.z));
        break;
        case "quadraticCurveTo":
          ary.push("Q");
          ary.push(rnd(drawCmd.cPts[0].x), rnd(drawCmd.cPts[0].y), rnd(drawCmd.cPts[0].z));
          ary.push(rnd(drawCmd.ep.x), rnd(drawCmd.ep.y), rnd(drawCmd.ep.z));
        break;
        case "closePath":
          ary.push("Z");
        break;
      }
    }

    if (isArray(dCmds))
    {
      dCmds.forEach(drawCmdtoCgo3D);
    }
    else
    {
      drawCmdtoCgo3D(dCmds);
    }

    return ary;
  }

  /*=========================================================
   * Obj3DtoJSON
   * Convert the Obj3D data to a JSON string format.
   * The JSON string encoding can be saved to a file for
   * re-use without the neccessity of maintaining and running
   * the object creation code.
   * 'name' and 'id' are optional, saved with the JSON data.
   * The JSON string version must still be compiled back to
   * an Obj3D for drawing but this is a simple process
   * use: obj = this.JSONtoObj3D(jsonData)
   *---------------------------------------------------------
   */
  Cango3D.prototype.Obj3DtoJSON = function(obj, nameStr)
  {
    var output = {
          'type': "Component",
          'name': nameStr || "Object1",
          'ComponentData': {}
        };

    function rnd(val)
    {
      return Math.round(val*1000)/1000;
    }

    function formatObj3DData(obj)
    {
      var data = {};

      if (obj.type === "GROUP")
      {
        data.type = "GROUP";
        data.children = [];
        return data;
      }

      data.type = obj.type;                       // PATH, SHAPE, TEXT
      if (obj.fillColor)
      {
        data.fillColor = obj.fillColor.toRGBA();    // save as 'rgba(r, g, b, a)'
      }
      if (obj.strokeColor)
      {
        data.strokeColor = obj.strokeColor.toRGBA();
      }
      if (obj.backColor)
      {
        data.backColor = obj.backColor.toRGBA();
      }
      data.backHidden = obj.backHidden;    // boolean
      data.hardOfsTfm = obj.hardOfsTfm;    // object
      if (obj.lineWidth)
      {
        data.lineWidth = obj.lineWidth;
      }
      if (obj.strokeCap)
      {
        data.strokeCap = obj.strokeCap.slice(0);
      }
      if (obj.fontSize)
      {
        data.fontSize = obj.fontSize;
      }
      if (obj.fontWeight)
      {
        data.fontWeight = obj.fontWeight;
      }
      if (obj.lorg)
      {
        data.lorg = obj.lorg;
      }
      if (obj.width)
      {
        data.width = obj.width;
      }
      if (obj.height)
      {
        data.height = obj.height;
      }
      if (obj.name)
      {
        data.name = obj.name.slice(0);   // make a string not a reference
      }
      data.pathData = drawCmd3DToCgo3D(obj.drawCmds);
      if (obj.type === "TEXT") // save the Text bounding box for dragNdrop
      {
        data.textBoxData = drawCmd3DToCgo3D(obj.bBoxCmds);
      }
      // save centroid and normal (in case they've been flipped)
      data.centroid = [];
      data.centroid.push(rnd(obj.centroid.x), rnd(obj.centroid.y), rnd(obj.centroid.z));
      data.normal = [];
      data.normal.push(rnd(obj.normal.x), rnd(obj.normal.y), rnd(obj.normal.z));

      return data;
    }

    //task:function, node:object with children
  	function iterate(task, node, outAry)
  	{
  	  var item;
  		node.children.forEach(function(childNode){
  			item = task(childNode);   // if child is a Group3D a new array for its kids is returned
        outAry.push(item);
  			if (childNode.type === "GROUP")
        {
  				iterate(task, childNode, item.children);     // item will be an array
        }
   		});
  	}

    if (obj.type === "GROUP")
    {
      output.ComponentData.type = "GROUP";
      output.ComponentData.children = [];
      iterate(formatObj3DData, obj, output.ComponentData.children);
    }
    else
    {
      output.ComponentData = formatObj3DData(obj); // returns SHAPE, PATH or TEXT data
    }

    return JSON.stringify(output);
  };

  Cango3D.prototype.renderFrame = function(obj)
  {
    var savThis = this;

    function drawObj()
    {
      savThis.render(obj);  // canvas will be clear each frame
    }

    window.requestAnimationFrame(drawObj);
  };

  /*=============================================
   * render will clear the canvas and draw
   * this Group3D or Obj3D, make sure it is only
   * called on the root object of the scene.
   * If an Obj3D is passed, update the netTfm
   * and render it.
   * If a Group3D is passed, recursively update
   * the netTfm of the group's family tree, put
   * all the tree's objects into one array,
   * sort according to z, then render all Obj3Ds.
   *--------------------------------------------*/
  Cango3D.prototype.render = function(rootObj)  // Obj3D or Group3D, 'wireframe', 'noclear' strings accepted
  {
    var savThis = this,
        args,
        clear = true,
        wireframe = false,
        drawableObjs = [],
        i;

    function configTextObj(txtObj)
    {
      var dx = 0, dy = 0,
          transMat, sclMat,
          size, mag,
          wid = txtObj.width,
          hgt = txtObj.height,
          wid2 = wid/2,
          hgt2 = hgt/2,
          lorgWC = [0, [0, hgt],  [wid2, hgt],  [wid, hgt],
                       [0, hgt2], [wid2, hgt2], [wid, hgt2],
                       [0, 0],    [wid2, 0],    [wid, 0]];

      // calc lorg offset
      if (lorgWC[txtObj.lorg] !== undefined)  // check for out of bounds
      {
        dx = -lorgWC[txtObj.lorg][0];
        dy = -lorgWC[txtObj.lorg][1];
      }
      dy += 0.25*hgt;   // correct for alphabetic baseline, its offset about 0.25*char height
      transMat = translateMatrix(dx, dy, 0);
      // scale by fontSize
      size = txtObj.fontSize || savThis.fontSize;     // Cango3D instance current default
      size /= savThis.xscl;     // size is in pixels, dividing by xscl compensates for world coord scaling
      mag = size/33;            // size/3 is scale factor to match Hershey font size to canvas font size
      sclMat = scaleMatrix(mag);
      // now calc net transform (lorgTfm to be applied prior to hardTfmOfs)
      txtObj.lorgTfm.matrix = matrixMult(transMat, sclMat);
    }

    function transformDrawCmds(obj)
    {
      // apply the netTfm matrix to all the drawCmds coordinates
      var j, k;

      if (obj.type === "TEXT")
      {
        // construct matrix that does lorg transform then netTransform
        obj.lorgTfm.applyTransform(obj.netTfm.matrix);
        obj.drawCmds.forEach(function(cmd){
          for (k=0; k &lt; cmd.cPts.length; k++)   // transform each 3D Point
          {
            cmd.cPts[k].softTransform(obj.lorgTfm.matrix);
          }
          // add the end point (check it exists since 'closePath' has no end point)
          if (cmd.ep !== undefined)
          {
            cmd.ep.softTransform(obj.lorgTfm.matrix);
          }
        });
        // now transform the text bounding box (just moveTo and lineTo, no cPts)
        for(j=0; j &lt; obj.bBoxCmds.length; j++)   // step through the draw segments
        {
          // check for ep since 'closePath' has no end point)
          if (obj.bBoxCmds[j].ep !== undefined)
          {
            obj.bBoxCmds[j].ep.softTransform(obj.lorgTfm.matrix);
          }
        }
      }
      else
      {
        obj.drawCmds.forEach(function(cmd){
          for (k=0; k &lt; cmd.cPts.length; k++)   // transform each 3D Point
          {
            cmd.cPts[k].softTransform(obj.netTfm.matrix);
          }
          // add the end point (check it exists since 'closePath' has no end point)
          if (cmd.ep !== undefined)
          {
            cmd.ep.softTransform(obj.netTfm.matrix);
          }
        });
      }
      // new transform the text bounding box
    }

    function applyXfms(obj)
    {
      var grp = obj.parent || null;

      if (grp)  // will be null for the rootObj
      {
        obj.grpTfm = grp.netTfm;  // grpTfm is always netTfm of the parent Group2D
      }
      if (obj.type === "GROUP")
      {
        // now re-calc the group's netTfm which will be passed on to its kids
        obj.ofsTfmAry.forEach(function(oft){
          obj.ofsTfm.applyTransform(oft);    // ofsTfmAry is array of 4x4 matrices
        });
        // obj.ofsTfm now is updated, reset the ofsTfmAry array
        obj.ofsTfmAry.length = 0;
        obj.netTfm.matrix = matrixMult(obj.ofsTfm.matrix, obj.grpTfm.matrix);
        // apply this to the group drawing origin for drag and drop
        obj.dwgOrg = new Point();
        obj.dwgOrg.softTransform(obj.netTfm.matrix);
        // apply the netTfm to the grp centroid
        obj.centroid.softTransform(obj.netTfm.matrix);
      }
      else
      {
        if (obj.type === "TEXT")
        {
          configTextObj(obj);    // apply a translate transform to handle lorg offset
          // this sets lorgTfm translate and scale
        }
        // now calc the offset transforms
        obj.ofsTfm.reset();
        obj.ofsTfmAry.forEach(function(oft){
          obj.ofsTfm.applyTransform(oft);    // ofsTfmAry is array of 4x4 matrices
        });
        // obj.ofsTfm now is updated, reset the ofsTfmAry array
        obj.ofsTfmAry.length = 0;
        // apply group transfroms to the offset transforms (these are net 'soft' transforms)
        obj.ofsTfm.applyTransform(obj.grpTfm.matrix);   // apply grpTfm to result
        // centroid and normal already have hard transforms applied, apply soft transforms
        obj.centroid.softTransform(obj.ofsTfm.matrix);  // transform the centroid
        obj.normal.softTransform(obj.ofsTfm.matrix);    // transform the normal
        // now apply the soft to the hard transforms
        obj.netTfm.matrix = matrixMult(obj.hardOfsTfm.matrix, obj.ofsTfm.matrix);
        // calc the transformed dwgOrg coords, dwgOrg only moved by softTfm and group softTfms
        obj.dwgOrg = new Point();
        if (obj.type === "TEXT")
        {
          obj.dwgOrg.hardTransform(obj.lorgTfm.matrix);  // lorg may move dwgOrg not centroid &amp; normal
        }
        obj.dwgOrg.softTransform(obj.netTfm.matrix);

        transformDrawCmds(obj);
      }
    }

    function recursiveApplyXfms(rootGrp)
    {
      // task:function, grp: group with children
    	function iterate(task, obj)
    	{
     		task(obj);
  			if (obj.type === "GROUP")
        {
      		obj.children.forEach(function(childNode){
      				iterate(task, childNode);
          });
      	}
      }
      // now propagate the current grpTfm through the tree of children
      iterate(applyXfms, rootGrp);
    }

    function obj3Dto2D(obj)
    {
      var j, k;

      function project3D(point)
      {
        // projection is onto screen at z = 0,
        var s = savThis.viewpointDistance/(savThis.viewpointDistance-point.tz);
        // perspective projection
        point.fx = point.tx * s;
        point.fy = point.ty * s;
      }

      // make the 2D parameters for each DrawCmd3D in drawCmds array
      for(j=0; j&lt;obj.drawCmds.length; j++)   // step through the path segments
      {
        for (k=0; k&lt;obj.drawCmds[j].cPts.length; k++)   // extract flattened 2D coords from 3D Points
        {
          project3D(obj.drawCmds[j].cPts[k]);             // apply perspective to nodes
          obj.drawCmds[j].parms[2*k] = obj.drawCmds[j].cPts[k].fx;
          obj.drawCmds[j].parms[2*k+1] = obj.drawCmds[j].cPts[k].fy;
        }
        // add the end point (check it exists since 'closePath' has no end point)
        if (obj.drawCmds[j].ep !== undefined)
        {
          project3D(obj.drawCmds[j].ep);                    // apply perspective to end point
          obj.drawCmds[j].parms[2*k] = obj.drawCmds[j].ep.fx;
          obj.drawCmds[j].parms[2*k+1] = obj.drawCmds[j].ep.fy;
        }
      }
      // new the text bounding box
      if (obj.type === "TEXT")
      {
        // now project the text bounding box path
        for(j=0; j&lt;4; j++)   // step through the draw segments (ignore final 'closePath')
        {
          project3D(obj.bBoxCmds[j].ep);                  // apply perspective to end point
          obj.bBoxCmds[j].parms[0] = obj.bBoxCmds[j].ep.fx;
          obj.bBoxCmds[j].parms[1] = obj.bBoxCmds[j].ep.fy;
        }
      }
      project3D(obj.centroid);  // project in case they are going to be drawn for debugging
      project3D(obj.normal);
      // the object's drawCmds parms arrays now hold world coord 2D projection ready to be drawn
    }

  	function sortDrawableObjs(grp)
  	{
      function paintersSort(p1, p2)
      {
        return p1.centroid.tz - p2.centroid.tz;
      }

      // Depth sorting (painters algorithm, draw from the back to front)
      grp.children.sort(paintersSort);
      // step through the children looking for groups (to sort)
  		grp.children.forEach(function(childNode){
  			if (childNode.type === "GROUP") // skip Obj3D
        {
  				sortDrawableObjs(childNode);  // check if next group has drawables
        }
        else   // child Obj3D ready to paint
        {
          drawableObjs.push(childNode);
        }
  		});
  	}

// ============ Start Here =====================================================

    // check arguments for 'wireframe' or 'noclear'
    args = Array.prototype.slice.call(arguments); // grab array of arguments
    for(i=0; i&lt;arguments.length; i++)
    {
      if ((typeof args[i] === 'string')&amp;&amp;(args[i].toLowerCase() === 'wireframe'))
      {
        wireframe = true;
      }
      if ((typeof args[i] === 'string')&amp;&amp;(args[i].toLowerCase() === 'noclear'))
      {
        clear = false;
      }
    }
    if (clear === true)
    {
      this.clearCanvas();
    }
    if (rootObj.type === "GROUP")
    {
      recursiveApplyXfms(rootObj);   // recursively re-calculate the object transforms and apply them
      // depth sort and paint to the canvas
      sortDrawableObjs(rootObj);  // recursive depth sort group tree into array of Obj3D

      drawableObjs.forEach(function(drwObj){
        obj3Dto2D(drwObj);
        // now render them onto the canvas checking for back is facing and backHidden
        if (!(!wireframe &amp;&amp; !savThis.frontFacing(drwObj) &amp;&amp; drwObj.backHidden))
        {
          savThis.paintObj3D(drwObj, wireframe);
        }
      });
    }
    else  // no sorting needed
    {
      applyXfms(rootObj);
      obj3Dto2D(rootObj);
      if (!(!wireframe &amp;&amp; !savThis.frontFacing(rootObj) &amp;&amp; rootObj.backHidden))
      {
        this.paintObj3D(rootObj, wireframe);
      }
    }
  };

/*========================================================
 * paintObj3D takes an Obj3D which has been transformed
 * and projected to 2D all the canvas commands are
 * formatted but in world coordinates.
 * Convert to canvas pixels and draw them onto the canvas
 *-------------------------------------------------------*/
  Cango3D.prototype.paintObj3D = function(pg, wireframe)
  {
    var j, k,
        ox, oy, nx, ny,
        stkCol;

    this.ctx.save();   // save the current ctx we are going to change bits
    this.ctx.beginPath();
    // step through the Obj3D drawCmds array and draw each one
    for (j=0; j &lt; pg.drawCmds.length; j++)
    {
      // convert all parms to pixel coords
      for (k=0; k&lt;pg.drawCmds[j].parms.length; k+=2)   // step thru the coords in x,y pairs
      {
        pg.drawCmds[j].parmsPx[k] = this.vpLLx+this.xoffset+pg.drawCmds[j].parms[k]*this.xscl;
        pg.drawCmds[j].parmsPx[k+1] = this.vpLLy+this.yoffset+pg.drawCmds[j].parms[k+1]*this.yscl;
      }
      // now actually draw the path onto the canvas
      this.ctx[pg.drawCmds[j].drawFn].apply(this.ctx, pg.drawCmds[j].parmsPx);
    }
    if (pg.type === "TEXT")
    {
      // construct the bounding box pixel coords for drag and drop
      for (j=0; j &lt; pg.bBoxCmds.length; j++)
      {
        // all parms already in pixel coords
        for (k=0; k&lt;pg.bBoxCmds[j].parms.length; k+=2)   // step thru the coords in x,y pairs
        {
          pg.bBoxCmds[j].parmsPx[k] = this.vpLLx+this.xoffset+pg.bBoxCmds[j].parms[k]*this.xscl;
          pg.bBoxCmds[j].parmsPx[k+1] = this.vpLLy+this.yoffset+pg.bBoxCmds[j].parms[k+1]*this.yscl;
        }
      }
    }
    // fill and stroke the path
    if (pg.type === "SHAPE")
    {
      this.ctx.closePath();
      this.ctx.lineWidth = 1;
      if (!wireframe)
      {
        this.ctx.fillStyle = this.calcShapeShade(pg);
        this.ctx.strokeStyle = this.ctx.fillStyle;
        this.ctx.fill();
        if (pg.fillColor.a &gt; 0.9)    // only stroke if solid color (don't stroke see-through panels)
        {
          this.ctx.stroke();    // stroke outline
        }
      }
      else  // wireframe - just stroke outline
      {
        stkCol = pg.strokeColor || this.penCol;
        this.ctx.strokeStyle = stkCol.toRGBA();
        this.ctx.lineCap = this.lineCap;
        this.ctx.stroke();    // stroke outline
      }
    }
    else  // PATH or TEXT
    {
      stkCol = pg.strokeColor || this.penCol;
      this.ctx.strokeStyle = stkCol.toRGBA();
      this.ctx.lineWidth = pg.lineWidth;
      if (pg.type === "TEXT")
      {
        // for TEXT, lineWidth just stores all softTransform scaling, so set lineWidth by fontWeight
        this.ctx.lineWidth *= 0.08*pg.fontSize*pg.fontWeight/400; // normal weight stroke width is saved
      }
      this.ctx.lineCap = pg.strokeCap;
      this.ctx.stroke();    // stroke outline
    }

    if (this.plotNormals)      // draw the normal
    {     // convert the centroid and normal too
      ox = this.vpLLx+this.xoffset+pg.centroid.fx*this.xscl;
      oy = this.vpLLy+this.yoffset+pg.centroid.fy*this.yscl;
      nx = this.vpLLx+this.xoffset+pg.normal.fx*this.xscl;
      ny = this.vpLLy+this.yoffset+pg.normal.fy*this.yscl;

      if (pg.centroid.tz &lt; pg.normal.tz)    // +ve out of screen
      {
        this.ctx.strokeStyle = "green";   // pointing toward viewer
      }
      else
      {
        this.ctx.strokeStyle = "red";     // pointing away from viewer
      }

      this.ctx.beginPath();
      this.ctx.moveTo(ox, oy);
      this.ctx.lineTo(nx, ny);
      this.ctx.stroke();
    }
    this.ctx.restore();  // put things back the way they were

    if (pg.dragNdrop !== null)
    {
      pg.dragNdrop.cgo = this;
      // now push it into Cango.dragObjects array, its checked by canvas mousedown event handler
      if (!this.cnvs.dragObjects.contains(pg))
      {
        this.cnvs.dragObjects.push(pg);
      }
    }
  };

  Cango3D.prototype.frontFacing = function(obj)
  {
        // calc unit vector normal to the panel front
    var normX = obj.normal.tx-obj.centroid.tx,
        normY = obj.normal.ty-obj.centroid.ty,
        normZ = obj.normal.tz-obj.centroid.tz,
        // calc unit vector from centroid to viewpoint
        losX = -obj.centroid.tx,
        losY = -obj.centroid.ty,
        losZ = this.viewpointDistance - obj.centroid.tz;
    /* Now calculate if we are looking at front or back
       if normal dot product with LOS is +ve its the front, -ve its the back */

    return (normX*losX + normY*losY + normZ*losZ &gt; 0);
  };

  Cango3D.prototype.calcShapeShade = function(obj)
  {
    var col, lum,
        sunX, sunY, sunZ, sunMag,
        normX, normY, normZ, normMag,
        cr, cg, cb, ca;

    // work in world coords
    // calculate unit vector in direction of the sun
    sunX = this.lightSource.x;
    sunY = this.lightSource.y;
    sunZ = this.lightSource.z;
    sunMag = Math.sqrt(sunX*sunX + sunY*sunY + sunZ*sunZ);
    sunX /= sunMag;
    sunY /= sunMag;
    sunZ /= sunMag;
    // calc unit vector normal to the panel front
    normX = obj.normal.tx-obj.centroid.tx;
    normY = obj.normal.ty-obj.centroid.ty;
    normZ = obj.normal.tz-obj.centroid.tz;
    normMag = Math.sqrt(normX*normX + normY*normY + normZ*normZ);
    normX /= normMag;
    normY /= normMag;
    normZ /= normMag;
    // luminence is dot product of panel's normal and sun vector
    lum = 0.6*(sunX*normX + sunY*normY + sunZ*normZ); // normalise to range 0..0.7
    lum = Math.abs(lum);   // normal can be up or down (back given same shading)
    lum += 0.4;            // shift range to 0.4..1 (so base level so its not too dark)
    /* Now calculate if we are looking at front or back
       if normal dot product with LOS is +ve its the top, -ve its the bottom
       bottom might get a different colour.
       no need to normalise, just need the sign of dot product */
    if (this.frontFacing(obj))
    {
      col = obj.fillColor || this.paintCol;
      // front will be dark if normal is pointing away from lightSource
      if (normX*sunX + normY*sunY + normZ*sunZ &lt; 0)
      {
        lum = 0.4;
      }
    }
    else
    {
      //  looking at back
      col = obj.backColor || this.backCol;
      // back will be dark if normal (front) is pointing toward the lightSource
      if (normX*sunX + normY*sunY + normZ*sunZ &gt; 0)
      {
        lum = 0.4;
      }
    }
    // calc rgb color based on V5 (component of normal to polygon in direction on POV)
    cr = Math.round(lum*col.r);
    cg = Math.round(lum*col.g);
    cb = Math.round(lum*col.b);
    ca = col.a;

    return "rgba("+cr+","+cg+","+cb+","+ca+")";     // string format 'rgba(r,g,b,a)'
  };

  /* =======================================================================
   * objectOfRevolution3D
   * The profile described by 'path' array of Cgo3D commands will form
   * the profile of an object of revolution. 'path' coordinates will be in
   * world cordinates. An Obj3D of type PATH is made of this profile and rotated
   * by the segment angle about the Y axis, the segment end points are joined
   * to the original profile by circular arcs top and bottom defining a curved
   * panel. These panels form one segment of the shape like a segment of an
   * orange. To get color filling to work, path sections must traversed in a
   * consistant direction, CCW to get the normal pointing out of screen.
   * So one side of the panel must be tranversd backwards. This is OK, as only
   * Bezier curves and straight lines are used in Cgo3D format data.
   * Parameters:
   * path: Array of Cgo3D format commands defining the profile in the X,Y plane
   * xOfs: an offset added to profile x coordinates (correct for SVG origin offset)
   * segments: number of segments into which totalAngle is divided
   * fillColor: HTML format color string
   * bkColor: HTML format color string
   * straight: If true, straight lines used to join segments
   * returns a Group3D.
   * -----------------------------------------------------------------------*/
  Cango3D.prototype.objectOfRevolution3D = function(path, xOfs, segments, fillColor, bkCol, straight)
  {
    /*=========================================================
     * function genSvgArc()
     * Generate the SVG format array for a circular arc with
     * center as start piont (canvas style) convert to SVG style
     * The actual arc will compile to Bezier curves by Cango
     * (these can be rotated in 3D and hold their shape).
     * Assumes Cango coords, y +ve up, angles +ve CCW.
     * The arc center is at cx, cy. Arc starts from startAngle
     * and ends at endAngle. startAngle and endAngle are in
     * degrees. The arc radius is r (in world coords). If
     * antiClockwise is true the arc is traversed ccw, if false
     * it is traversed cw.
     *---------------------------------------------------------*/
    var pathObj = this.compilePath3D(path),
        grp = this.createGroup3D(),
        startX = 0,
        startY = 0,
        endX = 0,
        endY = 0,
        panel, pp1Cmds, panelObj,
        topRim, botRim,
        topRimObj, botRimObj, topRimCmds,
        segs = segments || 6,
        segAng = 360 / segs,           // included angle of each segment
        segRad = segAng*Math.PI/180,
        color = fillColor || this.paintCol.toRGBA(),
        bkColor = bkCol || color,
        i, r,
        st, sp,
        topObj, botObj, topData, botData,
        profile_0, profile_1,
        n, m;

    function genSvgArc(cx, cy, r, startAngle, endAngle, antiClockwise)
    {
      var stRad = startAngle * Math.PI/180,
          edRad = endAngle * Math.PI/180,
          mj = 0.55228475,                 // magic number for drawing circle with 4 Bezier curve
          oy = cy + r*Math.sin(stRad),   // coords of start point for circlular arc with center (cx,cy)
          ox = cx + r*Math.cos(stRad),
          ey = cy + r*Math.sin(edRad),   // coords of end point for circlular arc with center (cx,cy)
          ex = cx + r*Math.cos(edRad),
          ccw = (antiClockwise? 1 : 0),
          delta,
          lrgArc,
          swp,
          svgData;

      swp = 1 - ccw;          // 0=ccw 1=cw   (flipped for this ccw +ve world)
      delta = ccw? edRad - stRad :stRad - edRad;
      if (delta &lt; 0)
      {
        delta += 2*Math.PI;
      }
      if (delta &gt; 2* Math.PI)
      {
        delta -= 2*Math.PI;
      }
      lrgArc = delta &gt; Math.PI? 1: 0;

      // dont try to draw full circle or no circle
      if ((Math.abs(delta) &lt; 0.01) || (Math.abs(delta) &gt; 2*Math.PI-0.01))
      {
        svgData = ["M",cx, cy-r,"C",cx+mj*r, cy-r, cx+r, cy-mj*r, cx+r, cy,
                                    cx+r, cy+mj*r, cx+mj*r, cy+r, cx, cy+r,
                                    cx-mj*r, cy+r, cx-r, cy+mj*r, cx-r, cy,
                                    cx-r, cy-mj*r, cx-mj*r, cy-r, cx, cy-r];
      }
      else
      {
        svgData = ["M", ox, oy, "A", r, r, 0, lrgArc, swp, ex, ey];
      }

      return svgData;
    }

    st = 1;         // which segment to start building from
    sp = pathObj.drawCmds.length;
    // Check if top can be made in a single piece
    if (((pathObj.drawCmds[0].ep.x+xOfs)*this.xscl &lt; 3)&amp;&amp;(pathObj.drawCmds[0].ep.y === pathObj.drawCmds[1].ep.y))
    {
      // make the top
      r = pathObj.drawCmds[1].ep.x;
      if (straight)
      {
        topData = ['M',r,0,0];
        for (i=1; i&lt;segments; i++)
        {
          topData.push('L',r*Math.cos(i*segRad),r*Math.sin(i*segRad),0);
        }
        topData.push('Z');
        topObj = this.compileShape3D(topData, color, bkColor);
      }
      else
      {
        topObj = this.compileShape3D(shapes3D.circle(2*r), color, bkColor);
      }
      // flip over to xz plane
      topObj.rotate(1, 0, 0, -90);
      // lift up to startY
      topObj.translate(0,pathObj.drawCmds[0].ep.y,0);
      grp.addObj(topObj);
      st = 2;  // skip the first section of the profile its done
    }
    // Check if bottom can be made in a single piece
    if (((pathObj.drawCmds[sp-1].ep.x+xOfs)*this.xscl &lt; 3)&amp;&amp;(pathObj.drawCmds[sp-1].ep.y === pathObj.drawCmds[sp-2].ep.y))
    {
      // make the bottom
      r = pathObj.drawCmds[sp-2].ep.x;
      if (straight)
      {
        botData = ['M',r,0,0];
        for (i=1; i&lt;segments; i++)
        {
          botData.push('L',r*Math.cos(i*segRad),r*Math.sin(i*segRad),0);
        }
        botData.push('Z');
        botObj = this.compileShape3D(botData, color, bkColor);
      }
      else
      {
        botObj = this.compileShape3D(shapes3D.circle(2*r), color, bkColor);
      }
      // flip over to xz plane
      botObj.rotate(1, 0, 0, 90);
      // lift up to end Y
      botObj.translate(0,pathObj.drawCmds[sp-1].ep.y,0);
      grp.addObj(botObj);
      sp -= 1;  // skip the last section of the profile its done
    }
    profile_0 = pathObj.dup(); // make a copy
    profile_1 = pathObj.dup(); // two needed (not new reference)
    // move the profile by xOfs, useful for SVG copied profiles
    profile_0.translate(xOfs, 0, 0);
    profile_1.translate(xOfs, 0, 0);
    // now this profile must be rotated by the segment angle to form the other side
    profile_1.rotate(0, 1, 0, segAng);   // rotate segment by segAng out of screen
    for (n=0; n&lt;segs; n++)
    {
      for (m=st; m&lt;sp; m++)
      {
        // construct a panel from top and bottom arcs and 2 copies of profile segment
        if (profile_0.drawCmds[m-1].ep.x*this.xscl &lt; 3)   // truncate to 1st Quadrant
        {
          profile_0.drawCmds[m-1].ep.x = 0;
          profile_1.drawCmds[m-1].ep.x = 0;
        }
        startX = profile_0.drawCmds[m-1].ep.x;
        startY = profile_0.drawCmds[m-1].ep.y;
        endX = profile_0.drawCmds[m].ep.x;
        endY = profile_0.drawCmds[m].ep.y;
        if (startX*this.xscl &gt;= 3) // make a topRim if profile doesn't start at center
        {
          // top rim (drawn in xy), endpoint will be where this profile slice starts
          if (straight)
          {
            topRim = ['M',startX*Math.cos(segRad),startX*Math.sin(segRad), 'L',startX,0];
          }
          else
          {
            topRim = genSvgArc(0, 0, startX, segAng, 0, 0);  // generate SVG cmds for top arc
          }
          // shove them into an object to enable rotate and translate
          topRimObj = this.compilePath3D(svgToCgo3D(topRim), color);
          // topRim is in xy plane must be rotated to be in xz plane to join profile
          topRimObj.rotate(1, 0, 0, -90);      // flip top out of screen
          topRimObj.translate(0, startY, 0);   // move up from y=0 to top of profile slice
          // use topRim drawCmds to start the panel array of DrawCmd3Ds
          panel = topRimObj.drawCmds;
        }
        else
        {
          // construct a moveTo command from end point of last command
          topRimCmds = new DrawCmd3D("moveTo", [], profile_0.drawCmds[m-1].ep);
          panel = [topRimCmds];     // use this to start the panel DrawCmd3Ds array
        }
        // push this profile_0 segment DrawCmd3D into panel array
        panel.push(profile_0.drawCmds[m]);
        if (endX &gt; 3)  // make the bottom rim if it has any size
        {
          if (straight)
          {
            botRim = ['M',endX,0, 'L',endX*Math.cos(-segRad),endX*Math.sin(-segRad)];
          }
          else
          {
            botRim = genSvgArc(0, 0, endX, 0, -segAng, 0);
          }
          // shove them into an object to enable rotate and translate
          botRimObj = this.compilePath3D(svgToCgo3D(botRim), color);
          // rim is in xy plane rotate to be in xz plane
          botRimObj.rotate(1, 0, 0, 90);      // flip bottom up to be out of screen
          botRimObj.translate(0, endY, 0);    // move down from y=0 to bottom of profile
          // now this is an moveTo and a bezierCurveTo, drop the 'moveTo'
          panel.push(botRimObj.drawCmds[1]);  // only 1 Bezier here
        }
        // construct a DrawCmd3D going backward up profile_1
        pp1Cmds = new DrawCmd3D(profile_1.drawCmds[m].drawFn.slice(0), [], profile_1.drawCmds[m-1].ep);
        if (profile_1.drawCmds[m].cPts.length === 1)
        {
          pp1Cmds.cPts.push(profile_1.drawCmds[m].cPts[0]);
        }
        // change order of cPts if its a Cubic Bezier
        if (profile_1.drawCmds[m].cPts.length === 2)
        {
          pp1Cmds.cPts.push(profile_1.drawCmds[m].cPts[1]);
          pp1Cmds.cPts.push(profile_1.drawCmds[m].cPts[0]);
        }
        panel.push(pp1Cmds);  // now add retrace path to the panel commands
        // make an Obj3D for this panel
        panelObj = new Obj3D(drawCmd3DToCgo3D(panel), "SHAPE", {"fillColor":color, "backColor":bkColor});
        // now add the complete panel to the array which makes the final shape
        grp.addObj(panelObj);
      }
      // rotate the previously made panels out of the way of next segment
      grp.rotate(0, 1, 0, segAng);
    }

    return grp;
  };

  svgToCgo3D = svgParser.svg2cgo3D;
  cgo3DtoDrawCmd3D = svgParser.cgo3DtoDrawcmd;

  return Cango3D;
}());
</t>
<t tx="amd.20151125105508.1">http://2015fallhw.github.io/spurgear/</t>
<t tx="amd.20151204234542.1">import random
# 產生標準答案
# 利用 list 數列資料型別建立顏色選項
# Red 紅色, White 白色, Yellow 黃色, Green 綠色, Blue 藍色, Purple 紫色, 假設顏色值不會重複
print('''遊戲規則說明: 可選顏色值, \nRed 紅色, White 白色, Yellow 黃色, Green 綠色, \nBlue 藍色, Purple 紫色, \nRBYGBP, \nX 表示位置與顏色都對, O 表示顏色對, 但是位置不對.
''')
 
顏色選項 = ["R", "W", "Y", "G", "B", "P"]
標準答案 = random.sample(顏色選項, 4)    
print (標準答案)
 
顏色字串 = ""
幾次決勝 = 9
猜測次數 = 0
遊戲進行中 = True
 
print ("總共有", 幾次決勝 - 猜測次數, "次機會,可以猜!")
  
for i in range(len(顏色選項)):
    顏色字串 += 顏色選項[i]
#print (顏色字串)
   
while 遊戲進行中:
    位置顏色都正確 = ""
    顏色對位置錯 = ""
    # 將使用者的輸入轉為大寫英文字母
    使用者猜測輸入 = input("請從下列顏色值中選四個, "+顏色字串+": ").upper()
    猜測次數 += 1
       
    # 檢驗是否輸入四個顏色字母
    if len(使用者猜測輸入) != len(標準答案):
        print ("\n只能猜四個顏色, 請重猜!")
        print ("\n剩下", 幾次決勝 - 猜測次數, "次機會,可以猜: ")
        continue
    # 判斷是否重複選擇相同顏色
    if len(使用者猜測輸入) &gt; len(set(使用者猜測輸入)):
        print ("\n顏色值不能重複！")
        print ("\n剩下", 幾次決勝 - 猜測次數, "次機會,可以猜: ")
        continue
    for i in range(4):
        # 判斷是否從顏色選項輸入
        if 使用者猜測輸入[i] not in 顏色選項:
            print ("\n只能從下列顏色選項中輸入!", 顏色選項)
            print ("\n剩下", 幾次決勝 - 猜測次數, "次機會,可以猜: ")
            continue
               
    if 位置顏色都正確 != "XXXX":
        for i in range(4):
            if 使用者猜測輸入[i] == 標準答案[i]:
                位置顏色都正確 += "X"
            if  使用者猜測輸入[i] != 標準答案[i] and 使用者猜測輸入[i] in 標準答案:
                顏色對位置錯 += "O"
        print (位置顏色都正確 +  顏色對位置錯 + "\n")       
           
    if 位置顏色都正確 == "XXXX":
        if 猜測次數 == 1:
            print ("太神奇了, 1 次就猜對!")
        else:
            print ("還不錯... 總共猜了 " + str(猜測次數) + " 次, 終於猜對!")
        遊戲進行中 = False
           
    if 猜測次數&gt;= 1 and 猜測次數 = 幾次決勝:
        print ("沒有猜對! 願賭服輸, 答案顏色值為: " + str(標準答案))  
        遊戲進行中 = False
   
    # 詢問要不要再玩
    while 遊戲進行中 == False:
        遊戲結束詢問 = input("\n要不要再玩 (Y/N)?").upper()  
        # 猜測次數歸零
        猜測次數 = 0
        if 遊戲結束詢問 =="N":
            print ("歡迎再回來玩!")
        elif 遊戲結束詢問 == "Y":
            遊戲進行中 = True
            # 重新產生標準答案
            標準答案 = random.sample(顏色選項, 4)     
            #print (標準答案)
            print ("好, 再玩一次...")
            print ("總共有", 幾次決勝 - 猜測次數, "次機會,可以猜!")</t>
<t tx="amd.20151204234812.1">@language python
@tabwidth -4
&lt;&lt;declarations&gt;&gt;
@others</t>
<t tx="amd.20151204234907.1">@language python

from flask import Flask, request, redirect, render_template, session
import os
import sys

# 確定程式檔案所在目錄, 在 Windows 有最後的反斜線
_curdir = os.path.join(os.getcwd(), os.path.dirname(__file__))
# 將所在目錄設為系統搜尋目錄
sys.path.append(_curdir)
if 'OPENSHIFT_REPO_DIR' in os.environ.keys():
    # while program is executed in OpenShift
    download_root_dir = os.environ['OPENSHIFT_DATA_DIR']
    data_dir = os.environ['OPENSHIFT_DATA_DIR']
else:
    # while program is executed in localhost
    download_root_dir = _curdir + "/local_data/"
    data_dir = _curdir + "/local_data/"
</t>
<t tx="amd.20151204235016.1">class Guesscolor(object):
    @others
</t>
<t tx="amd.20151204235016.2">def __init__(self):
    # hope to create downloads and images directories　
    if not os.path.isdir(download_root_dir+"downloads"):
        try:
            os.makedirs(download_root_dir+"downloads")
        except:
            print("mkdir error")
    if not os.path.isdir(download_root_dir+"images"):
        try:
            os.makedirs(download_root_dir+"images")
        except:
            print("mkdir error")
    if not os.path.isdir(download_root_dir+"tmp"):
        try:
            os.makedirs(download_root_dir+"tmp")
        except:
            print("mkdir error")
</t>
<t tx="amd.20151204235016.3">def index():
    #這是猜數字遊戲的起始表單, 主要在產生答案, 並且將 count 歸零
    # 將標準答案存入 answer session 對應區
    colors = ["R", "W", "Y", "G", "B", "P"]
    theanswer = random.sample(colors, 4)  
    thecount = 0
    # 將答案與計算次數變數存進 session 對應變數
    session['answer'] = theanswer
    session['count'] = thecount

    return render_template("index.html", answer=theanswer, count=thecount)</t>
<t tx="amd.20151204235323.1">def guessform():
    session["count"] += 1
    guess = session.get("guess")
    theanswer = session.get("answer")
    count = session.get("count")
    
    return render_template("guessform.html", guess=guess, answer=theanswer, count=count)</t>
<t tx="amd.20151204235349.1">def docheck():
    # session[] 存資料
    # session.get() 取 session 資料
    # 利用 request.form[] 取得表單欄位資料, 然後送到 template
    guess = request.form["guess"]
    session["guess"] = guess
    # 假如使用者直接執行 doCheck, 則設法轉回根方法
    if guess is None:
        redirect("/")
    # 從 session 取出 answer 對應資料, 且處理直接執行 docheck 時無法取 session 值情況
    try:
        theanswer = int(session.get('answer'))
    except:
        redirect("/")
    # 經由表單所取得的 guess 資料型別為 string
    try:
        theguess = int(guess)
    except:
        return redirect("/guessform")
    # 每執行 doCheck 一次,次數增量一次
    session["count"] += 1
    count = session.get("count")
    # 答案與所猜數字進行比對
    if theanswer &lt; theguess:
        return render_template("toobig.html", guess=guess, answer=theanswer, count=count)
    elif theanswer &gt; theguess:
        return render_template("toosmall.html", guess=guess, answer=theanswer, count=count)
    else:
        # 已經猜對, 從 session 取出累計猜測次數
        thecount = session.get('count')
        return "猜了 "+str(thecount)+" 次, 終於猜對了, 正確答案為 "+str(theanswer)+": &lt;a href='/'&gt;再猜&lt;/a&gt;"
    # 應該不會執行下列一行
    return render_template("docheck.html", guess=guess)</t>
<t tx="amd.20160105222759.1">@language python
@tabwidth -4
&lt;&lt; declarations &gt;&gt;
@others
if __name__ == "__main__":
    #env = Environment(OneMax, maxgenerations=1000, optimum=30)
    #env = Environment(Volume, size=500, maxgenerations=100)
    env = Environment(Intersect, size=500, maxgenerations=100)
    env.run()
</t>
<t tx="amd.20160105223221.10"># sample mutation method
def _pick(self, gene):
    "chooses a random allele to replace this gene's allele."
    self.chromosome[gene] = random.choice(self.alleles)
</t>
<t tx="amd.20160105223221.11"># sample crossover method
def _twopoint(self, other):
    "creates offspring via two-point crossover between mates."
    left, right = self._pickpivots()
    def mate(p0, p1):
        chromosome = p0.chromosome[:] # 交配時,以p0的基因為基礎(複製整個 p0 的染色體內容
        chromosome[left:right] = p1.chromosome[left:right] # 接續上一個 p0 的染色體內容,將索引 left 至 right 的內容,替換成 p1 的基因
        #child = p1.__class__(chromosome) 這是原先的程式,但是應該子代要指向 p0 的內容才對
        child = p0.__class__(chromosome)
        child._repair(p0, p1)
        return child
    return mate(self, other), mate(other, self)
</t>
<t tx="amd.20160105223221.12"># some crossover helpers ...
def _repair(self, parent1, parent2):
    "override this method, if necessary, to fix duplicated genes."
    pass
</t>
<t tx="amd.20160105223221.13">def _pickpivots(self):
    left = random.randrange(1, self.length-2)
    right = random.randrange(left, self.length-1)
    return left, right
</t>
<t tx="amd.20160105223221.14">#
# other methods
#
def __repr__(self):
    "returns string representation of self"
    '''
    return '&lt;%s chromosome="%s" score=%s var=%s&gt;' % \
           (self.__class__.__name__,
            self.seperator.join(map(str,self.chromosome)), self.score,self._getvar(self.chromosome))
    '''
    return '&lt;%s score=%s var=%s&gt;' % \
           (self.__class__.__name__,self.score,self._getvar(self.chromosome))
</t>
<t tx="amd.20160105223221.15"># since the __cmp__ special function is gone  use the __lt__ in stead
# use the expression (a &gt; b) - (a &lt; b) as the equivalent for cmp(a, b)
#def __cmp__(self, other):
# these are for python 3
def __cmp__(self, other):
    if self.optimization == MINIMIZE:
        #return cmp(self.score, other.score)
        return (self.score &gt; other.score) - (self.score &lt; other.score)
    else: # MAXIMIZE
        #return cmp(other.score, self.score)
        return (other.score &gt; self.score) - (other.score &lt; self.score)
        
</t>
<t tx="amd.20160105223221.16">def __lt__(self, other):
    return self.__cmp__(other) &lt; 0
</t>
<t tx="amd.20160105223221.17">def __le__(self, other):
    return self.__cmp__(other) &lt;= 0
</t>
<t tx="amd.20160105223221.18">def __gt__(self, other):
    return self.__cmp__(other) &gt; 0
</t>
<t tx="amd.20160105223221.19">def __ge__(self, other):
    return self.__cmp__(other) &gt;= 0 
</t>
<t tx="amd.20160105223221.2">#encoding=utf8
# genetic.py
#
import random
#import operator
# for Intersect
from math import *
MAXIMIZE, MINIMIZE = 11, 22
</t>
<t tx="amd.20160105223221.20">def copy(self):
    twin = self.__class__(self.chromosome[:])
    twin.score = self.score
    return twin
</t>
<t tx="amd.20160105223221.21">class Environment(object):
    x = [0]
    y = [0]
    @others
</t>
<t tx="amd.20160105223221.22">def __init__(self, kind, population=None, size=100, maxgenerations=100,
             crossover_rate=0.90, mutation_rate=0.07, optimum=None):
    self.kind = kind
    self.size = size
    self.optimum = optimum
    self.population = population or self._makepopulation()
    for individual in self.population:
        individual.evaluate(self.optimum)
    self.crossover_rate = crossover_rate
    self.mutation_rate = mutation_rate
    self.maxgenerations = maxgenerations
    self.generation = 0
    self.report()
</t>
<t tx="amd.20160105223221.23">def _makepopulation(self):
    return [self.kind() for individual in range(self.size)]
</t>
<t tx="amd.20160105223221.24">def run(self):
    while not self._goal():
        self.step()
</t>
<t tx="amd.20160105223221.25">def _goal(self):
    return self.generation &gt; self.maxgenerations or \
           self.best.score == self.optimum
</t>
<t tx="amd.20160105223221.26">def step(self):
    # this sort is not working with python 3.0, modification is needed
    self.population.sort()
    self._crossover()
    self.generation += 1
    self.report()
    self.x.append(self.generation)
    # 設定為只附加所選定範圍的值,這裡只取大於或等於 0 的 score 值
    if self.best.score &lt;=5:
        self.y.append(self.best.score)
    else:
        self.y.append(5)
</t>
<t tx="amd.20160105223221.27">def _crossover(self):
    next_population = [self.best.copy()]
    while len(next_population) &lt; self.size:
        mate1 = self._select()
        if random.random() &lt; self.crossover_rate:
            mate2 = self._select()
            offspring = mate1.crossover(mate2)
        else:
            offspring = [mate1.copy()]
        for individual in offspring:
            self._mutate(individual)
            individual.evaluate(self.optimum)
            next_population.append(individual)
    self.population = next_population[:self.size]
</t>
<t tx="amd.20160105223221.28">def _select(self):
    "override this to use your preferred selection method"
    return self._tournament()
</t>
<t tx="amd.20160105223221.29">def _mutate(self, individual):
    for gene in range(individual.length):
        if random.random() &lt; self.mutation_rate:
            individual.mutate(gene)
</t>
<t tx="amd.20160105223221.3">class Individual:
    chromosome = None
    score = None
    # Here the size of var depends on var_number
    var = []
    var_number = 2
    for i in range(var_number):
        var.append(0)
    alleles = (0,1)
    # 以下為參數可負數時的編碼考量
    #前10為小數,後10為整數,第21則為正負號
    #0~9表示小數,10~19表示整數,而指標第20則表示第一數的正號或負號,若為0則表示正,若為1表示負號.
    #21~30表示第二數的小數部分,31~40則表示第二數的整數部分,第41指標則表示第二數的正號或負號
    #42~51表示第三數的小數部分,52~61則表示第二數的整數部分,第62指標則表示第三數的正號或負號
    # -1023 ~ 1023
    #length = 21*var_number,若接受負數參數,則必須同步修改 20-&gt;21
    length = 20*var_number
    seperator = ''
    # 內建為最小化題目
    optimization = MINIMIZE
    @others
</t>
<t tx="amd.20160105223221.30">#
# sample selection method
#
def _tournament(self, size=8, choosebest=0.90):
    competitors = [random.choice(self.population) for i in range(size)]
    competitors.sort()
    if random.random() &lt; choosebest:
        return competitors[0]
    else:
        return random.choice(competitors[1:])
</t>
<t tx="amd.20160105223221.31">def best():
    doc = "individual with best fitness score in population."
    def fget(self):
        return self.population[0]
    return locals()
</t>
<t tx="amd.20160105223221.32">best = property(**best())
def report(self):
    print ("="*70)
    print ("generation: ", self.generation)
    print ("best:       ", self.best)

</t>
<t tx="amd.20160105223221.33"># 以上為 genetic.py 目前將兩者結合在一起
#encoding=utf8
# volume.py - useage example
#
# the fittest individual will have a chromosome consisting of 40 '1's
#
#
#import genetic
#此一加總函式在 Volume 最大化中,並未使用, 只用於 Onemax
def sum(seq):
    def add(x,y): return x+y
    return reduce(add, seq, 0)
</t>
<t tx="amd.20160105223221.34">class Volume(Individual):
    optimization = MAXIMIZE
    @others
</t>
<t tx="amd.20160105223221.35">def evaluate(self, optimum=None):
    SURFACE = 80
    # self.score is the fitness value
    self._getvar(self.chromosome)
    
    x = self.var[0]
    y = self.var[1]
    z=(SURFACE - x*y)/(2.*(x+y))
    fitness_value = x*y*z
    
    self.score = fitness_value
    
</t>
<t tx="amd.20160105223221.36">def mutate(self, gene):
    self.chromosome[gene] = not self.chromosome[gene] # bit flip

</t>
<t tx="amd.20160105223221.37">class Intersect(Individual):
    optimization = MINIMIZE
    @others
</t>
<t tx="amd.20160105223221.38">def evaluate(self, optimum=None):
    # self.score is the fitness value
    self._getvar(self.chromosome)
    
    t = self.var[0]
    deg = pi/180
    theta = self.var[1]*deg
    xtarget = 0.75/2
    ytarget = 0.5
    x = t*sqrt(-225*sin(theta)**2 + 529)/10 - sqrt(-225*sin(theta)**2 + 529)/92 + 3*cos(theta)/2
    y = (-3*t/2 + 123/92)*sin(theta)
    # 適應值
    fitness_value = pow(x-xtarget, 8)+pow(y-ytarget, 8)

    # 指定 t 的範圍, 小於 1 大於 0, 否則給予處罰
    if t &gt; 1:
        fitness_value += 1000
    if t &lt; 0:
        fitness_value += 1000
    # 指定 theta 的範圍, 小於 2pi 大於 0, 否則給予處罰
    if theta &gt; 2*pi:
        fitness_value += 1000
    if theta &lt; 0:
        fitness_value += 1000

    
    self.score = fitness_value
    
</t>
<t tx="amd.20160105223221.39">def mutate(self, gene):
    self.chromosome[gene] = not self.chromosome[gene] # bit flip
    
    

</t>
<t tx="amd.20160105223221.4">def __init__(self, chromosome=None):
    self.chromosome = chromosome or self._makechromosome()
    self.score = None  # set during evaluation
</t>
<t tx="amd.20160105223221.5">def _getvar(self,chromosome=None):
    x = 0
    for i in range(0,self.var_number):
        for j in range(i*20,i*20+10):
            x +=self.chromosome[j]&lt;&lt;(j-(i*20))
        if (x&gt;999):
            x=999
        x/=1000.
        for j in range(i*20+10,i*20+20):
            x +=self.chromosome[j]&lt;&lt;(j-(i*20+10))
        self.var[i] = x
    return self.var
    ''' for -1023 ~ 1023,當設計變數可以接受負值時使用,每一變數使用21個 bit strings
    #for design variable -1023 ~1023
    for i in range(self.var_number):
        x = 0
        for j in range(i*21,i*21+10):
            x +=self.chromosome[j]&lt;&lt;(j-(i*21))
        if (x&gt;999):
            x=999
        x/=1000.
        for j in range(i*(21)+10,i*(21)+20):
            x +=self.chromosome[j]&lt;&lt;(j-(i*21+10))
        if(self.chromosome[i*(21)+20] == 1):
            self.var[i] = -x
        else:
            self.var[i] = x
        x = 0
    return self.var
    '''
</t>
<t tx="amd.20160105223221.6">def _makechromosome(self):
    "makes a chromosome from randomly selected alleles."
    return [random.choice(self.alleles) for gene in range(self.length)]
</t>
<t tx="amd.20160105223221.7">def evaluate(self, optimum=None):
    "this method MUST be overridden to evaluate individual fitness score."
    pass
</t>
<t tx="amd.20160105223221.8">def crossover(self, other):
    "override this method to use your preferred crossover method."
    return self._twopoint(other)
</t>
<t tx="amd.20160105223221.9">def mutate(self, gene):
    "override this method to use your preferred mutation method."
    self._pick(gene)
</t>
<t tx="amd.20160105224401.1">class OneMax(Individual):
    optimization = MAXIMIZE 
    @others</t>
<t tx="amd.20160105224431.1">def evaluate(self, optimum=None):
    self.score = sum(self.chromosome)
</t>
<t tx="amd.20160105224459.1">def mutate(self, gene):
    self.chromosome[gene] = not self.chromosome[gene] # bit flip</t>
</tnodes>
</leo_file>
